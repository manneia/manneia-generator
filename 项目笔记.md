# 项目介绍

基于React + SpringBoot + Vert.x 响应式编程的定制化代码生成项目

# 项目背景

## 解决的问题

1.  代码生成器本身的作用就是自动生成常见,重复性的代码片段,解决重复编码,效率低下的问题
2.  网上的代码生成器,无法满足实际开发中定制化的需求
3.  在团队开发中,要生成的代码可能是需要频繁变化和持续更新维护的.如果有一个线上平台来维护多个不同的代码生成器,支持在线编辑和共享生成器,在提高开发效率的同时,将有利于协作共建,打造更高质量的代码生成器

## 实际应用

1.  经常写算法的同学,可能需要一套`ACM`代码输入模板,能够支持多种不同输入模式 (例如单次读取和循环读取)
2.  经常开发新项目的同学,可能需要一套初始化项目模板代码,比如一键生成`Controller`层代码,整合`Redis`和`MySQL`依赖等.
3.  还可以制作项目换皮工具,一键给网络热门项目换皮

# 技术选型

## 前端

React开发框架 + 组件库 + 代码编辑器

前端工程化: ESLint + Prettier + TypeScript

## 后端

-   Java Spring Boot+MySQL+小yBatis Plus(万用后端模板)
-   Java命令行应用开发
-   FreeMarker模板引擎
-   Vertx响应式编程
-   Caffeine+Redis多级缓存
-   分布式任务调度系统
-   多种设计模式
-   多种系统设计的虹巧思
-   对象存储

# 项目设计

## 代码生成器的核心原理

参数 + 模板文件 = 生成的完整的代码

比如参数: 

```C++
作者 = manneia
```

模板文件代码: 

```Java
----------
我是 ${作者}
----------
```

将参数注入到模板文件,得到生成的完整代码:

```Java
----------
我是 manneia
----------
```

# 第一阶段 本地代码生成器

开发一个离线版本的代码生成器, 实现一个简易的 JAVA ACM模板项目的定制化生成

## 业务流程

1.  准备用于制作代码生成器的原始代码,用于后续生成
2.  开发者基于原始带啊吗,设置参数,编写动态模板
3.  制作可交互的命令行工具,支持用户输入参数,得到代码生成器 jar 包
4.  使用者得到代码生成器 jar 包, 执行程序并输入参数,从而生成完整代码

暂时无法在飞书文档外展示此内容

## 实现思路

1.  先根据本地项目，扫描文件树，实现同样铂的静态代码生成
2.  根据本地的项目，预设部分动态参数、编写模板文件，能够传入配置对象进行生成
3.  制作可交互的命令行工具，接受用户输入的参数，并动态生成代码
4.  封装制作代码生成器 jar包文件，并简化使用命令

### 关键问题

如何根据一套项目文件,完整地生成同样一套项目?

如何编写动态模板文件? 怎么根据模板和参数生成代码?

如何制作命令行工具?如何交互式接受用户的输入?

怎么将命令行工具制作为 jar 包? 怎么简化使用命令? 

# 第二阶段 代码生成器制作工具

### 业务流程

1.  准备用于制作代码生成器的原始代码（比如Spring Boot项目模板），用于后续生成
2.  开发者基于原始代码，使用代码生成器制作工具，来快速设置参数、生成动态模板
3.  使用代码生成器制作工具，动态生成代码生成器jar包
4.  使用者得到代码生成器jar包，执行程序并输入参数，从而生成完整代码

### 实现思路

1.  使用独立空间来存储管理要生成的原始文件、动态模板文件等
2.  使用配置文件来记录要生成的参数和模板文件信息、自定义配置等元信息
3.  代码生成器制作工具需要有多种可单独或组合使用的功能，比如从原始文件中抽取参数、动态生成命令行工具、打jar包等

暂时无法在飞书文档外展示此内容

### 关键问题

1.  如何使用配置文件来记录参数和模板文件信息？何种结构？
2.  怎么能够提高代码生成器的制作效率？工具应该提供哪些能力？
3.  如何从原始文件中抽取参数？有哪些类型的参数？有哪些抽取规则？比如布尔类型参数（是否生成）、字符串类型参数（生成指定的值）等
4.  如何动态生成配置类? 如何动态生成命令行工具? 如何动态打jar包

# 第三阶段 在线代码生成器平台

### 业务流程

1.  获取用于制作代码生成器的原始代码（手动准备或者远程拉取代码）
2.  开发者基于原始代码，使用在线代码生成器制作工具，来快速制作代码生成器
3.  开发者发布代码生成器至平台
4.  使用者在平台上搜索代码生成器，支持在线使用或者下载离线jar包（甚至还可以支持接口调用）

业务流程图: 

暂时无法在飞书文档外展示此内容

### 实现思路

1.  使用Wb开发框架实现代码生成器信息的增删改查
2.  将本地的配置和文件上云，存储到数据库、对象存储等云服务。
3.  通过可视化界面来操作第二阶段的代码生成器制作工具，复用阶段二的成果。

### 关键问题

1.  怎么在云上存储管理代码生成器？
2.  如何通过前端开发，提高代码生成器的制作效率？
3.  如何通过后端优化，提高代码生成器的制作性能？
4.  如何保证代码生成器的存储空间不超邹限、如何优化存储？

# 本地代码生成器开发

## 一、项目初始化

### 1、初始化根目录

由于项目包含多个阶段,本质上是多个项目,为了统一管理整个项目,我们创建一个干净的`manneia-generator`空文件夹,作为整个项目的根目录,后续各阶段的项目和目录都放到它之下.

这样做还有一个好处,可以让不同的模块之间采用相对路径寻找文件,便于整个项目开源共享.

建议使用Git 管理项目.使用IDEA 开发工具来创建新项目,可以直接勾选`create Git repository`,工具会自动帮你初始化项目为Git仓库

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MjdmNzFmMDcwMmFmZDgzNjIzNzA2ZTQ3YTFmMjRiYTFfNUd2N1ZaUDQzNlQyTWdLNHpMQXRRYm1yREhKMnlSMGZfVG9rZW46Rzh2YmIwSWVYb3JtbHZ4bkFuRGNTeUZqbkpmXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

>   当前也可以在项目根目录,执行`git init`命令创建Git 仓库

### 2、忽略无用提交

创建好新项目后，使用IDEA开发工具打开项目，进入底部的Git标签，会发现很多和项目无关的IDEA自动

生成的工程文件被添加到了Git托管。

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MGM0ZTEwYzA5ZjYwODBmYzYzMDY0YzJmNTRkMGJmYjhfdFdhRkVzNXJpaE14VFM3Z05wTUF5empoRDFETWN0WklfVG9rZW46VFFSRmJ4OGRIb1hJbGd4NnNCa2NERzFkbjllXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

但我们是不希望提交这些文件的，没有意义，所以需要使用`·gitignore`文件来忽略这些文件，不让它们被

Git托管。

如何编写.gitignore文件呢？

其实很简单，不用自己编写！我们在IDEA的Settings=>Plugins中搜索`.ignore`插件并安装：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NmRlOWYyMTQ0ZjUyYmRkMDAwOGRhZDhiZTJiNzY3NDRfTGhSMkpVeE5TVWt2N0lHdGtWMG9EZzkwMU80TmlZMXRfVG9rZW46WHJKaWJucE9Hb3FwUll4eFJiVGNjdXRYbmxoXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

然后在项目根目录处选中右键，使用`.ignore`插件创建`.gitignore`文件

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MDBmZjZlZDg4ODRlNTY4MTg2OGVmNDFhM2E0ZjZhMDNfRWVmdW1KOU45ZVFKVzVlMjhGSndCcFVwMDBKRk51MzlfVG9rZW46VGh6QWIwdVBnbzBWT3F4aWlWSWNvQmhIbmdnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

`.ignore`插件提供了很多默认的`.gitignore`模板，根据自己的项目类型和使用的开发工具进行选择，此处我们选择Java和JetBrains模板：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Y4MzcwMjJjODcxMTUzYzI4YjIwZTdmNTI5ZTE1ZDBfZkhPdG1uSHJLSmhjWGJLcmZxTHY2M1p2WmJXVnhnNE5fVG9rZW46RmhCM2JqTmpsb0RwNHB4U3VHOWNYN2hqbmdkXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

然后可以在项日根日录看到生成的`.gitignore`文件，模板已经包含了常用的Java项目忽略清单，比如编译后的文

件、日志文件、压缩包等：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NTc3MmU3OTk4MzgyMjYxNzU4NzFiM2RmMDc0MTQ1Y2VfSlg5S2pnTHh2VTQ4SWtuU2tCQUE3NGNjeUEyVGYzd2FfVG9rZW46RjRNemJldWhZb3dXRDF4TlNaZGNtOWhjbnZoXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

让我们再手动添加几个要忽略的目录和文件，比如打包生成的target目录

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjAwODFmOTRmZmUyMjkxYjAzMDE1MDdmYWNmNzk3YTJfVUhMRWVmYzVGWXRIcTMyWFJFM2s3TGJybFh1Qk1iV01fVG9rZW46QWVrZGJKdk0yb0pjbDd4NXY5bGM0OHh0bmdmXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

但是，我们会发现，即使有些文件已经添加到了`.gitignore`文件中，在IDEA中显示的还是绿色（已被Git托

管)状态。如下图：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YjZmYTVjYTU5NDNmNTU3N2I4ZTEwNzg3ZjI3YjNjY2VfY1FJRXJKNkdSS09MVTNQcDBKNWF5c3ZiOGFDdmtXOEJfVG9rZW46S2picmJzT1ZCb0R4cmt4cnRFZWMwZFdObnFnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

这是因为这些文件已经被Git跟腙。而.gitignore文件仅影响未跟踪的文件，如果文件已经被Git跟腙，那么

gitignore文件对它们没有影响。

所以我们需要打开终端，在项目根目录下执行如下命令，取消Git跟腙：

```Shell
git rm -rf --cached .
```

执行效果如图:

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YWMwYjFhNmIxMzg4YTI5MDYyZDA3NDhiYmJkOWZkYWJfM3U3UVZFWGxsVDQybmtMQ2NnQ0tUUjRsdEJnWnRMSDRfVG9rZW46RkNrdGJEUld3b3AzQ3B4cmhpeGN1RXYxbnphXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

可以看到文件变成了红色（未被 Git 托管）或黄色（被忽略）状态：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YmU3N2JkYzc5ZWUxNTQ3YjQ3OGY3MzM5YWQxNTQ2ODZfQU9pczRrTUYxSm1VQjNQMjhvaktzYkI2M2pEMkg2dFFfVG9rZW46S3g4bmJPSzlBb3NqZ1R4QTdWUWNqU0lybmRlXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

然后，让我们将.gitignore文件添加到Git暂存区，让它能够被Git管理。

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTkxMDIxNjk4MTk0Y2QxYWFhZTViNzJlZTExMWJmMWNfbDBKOVR4NlZtWFUxV0RXQ1ZjMFJuSVJBNTFjQkp2Q05fVG9rZW46RzJaT2JwOW9Hb0Fvem54dk92OWN2NGFMbmpNXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

### 3、创建 Demo 示例代码工程

为了制作代码生成器，我们需要一些示例模板代码，后续会基于这些模板代码来定制生成。

比如第一阶段，我们会用到一套鱼皮提前编写好的ACM示例模板代码，从而制作定制化ACM模板代码生成器：在第二阶段，我们会用到一套Spring Boot初始化项目模板。

让我们新建一个`manneia-generator-demo-projects`目录，统一存放所有的示例代码，然后将准备的ACM模板项目(acm-template)复制到该目录下。

整个项目的目录结构如图下图:

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MjFmNjk4ZjZmYTZkMmI3MDRmY2UzYmJlYTEzNzM4MWZfaWNPZjluZXl3YnFWbjhNMEY4c3phNnFDVGYzbEdMR3NfVG9rZW46WWx6c2JPT0o0b0N6RW94bTlaVGNOT1g5bjZkXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

#### ACM 示例模板代码介绍

MainTemplate是一段 ACM 示例输入代码,作用是计算并输出多数之和.

```Java
package com.manneia.acm;

import java.util.Scanner;

/**
 * ACM 输入模板（多数之和）
 */
public class MainTemplate {
public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    while (scanner.hasNext()) {
        // 读取输入元素个数
        int n = scanner.nextInt();
        // 读取数组
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        // 处理问题逻辑，根据需要进行输出
        // 示例：计算数组元素的和
        int sum = 0;
        for (int num : arr) {
            sum += num;
        }
        System.out.println("Sum: " + sum);
    }
    scanner.close();
    }
}
```

### 4、创建本地代码生成器项目

使用 IDEA 在项目根目录中创建新工程,创建`manneia-generator-basic`项目.需要注意以下几点:

1.  项目存放位置在`manneia-generator`目录下
2.  取消Git仓库勾选（因为已经在外层进行Git托管）
3.  使用Maven管理项目
4.  JDK选择1.8！不要追求新版本
5.  高级设置中，指定Groupld和Artifactld

配置如图:

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YTIyMmEyZDljNjczY2E0YTdlY2RmZTQ2NTU4YjAxNzFfRGc2NTYwWTNqOTkxY0plbEQzcW1BY2hSUFlqS0N1M0xfVG9rZW46RFhoMWJlcDZzb3VpYkt4c0JOamN3WWVTbmtnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

创建好工程后,在新窗口打开

并将文件添加到暂存区

然后在`pom.xml`文件中引入依赖,便于提高开发效率: 

```XML
<dependencies>
    <dependency>
        <groupId>cn.hutool</groupId>
        <artifactId>hutool-all</artifactId>
        <version>5.8.25</version>
    </dependency>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-collections4</artifactId>
        <version>4.4</version>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.30</version>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.13.2</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

引入依赖后, 刷新maven,执行Main文件,得到下图的输出,则项目初始化完成

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmUyZmQzZWQ4YzNmNDhmODhjYzUxYmZhODJiNDUyODFfV3BXWjBjWk9aNDRlTFR1ODFuN3hwMkRKZ3RXRXJxbXVfVG9rZW46Q01FMGJOTUNQb3drSTl4TzdCYWNYUUk4bmFiXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

## 二、实现流程

第一阶段我们的目标是制作本地代码生成器（基于命令行的脚手架），要求能够根据用户的输入生成不同的ACM

示例代码模板。

对于完全没开发过类似以项目的同学来说，可能会觉得比较困难。

### 需求拆解

把需求分为两段: 本地代码生成器 + 基于命令行的脚手架

首先思考如何制作本地代码生成器。先看看我们要生成的项目文件结构吧！前面也提到过，ACM示例代码模板的

核心文件是README.md和MainTemplate.java。

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MjkwNzg1NGJhYTMwOWIwZWVlNjZjYzVhMGZjYTZjZThfTHhRMjhYd0d0aGRONjZRUHJVV3NoQWxldEFpZ2tuMWNfVG9rZW46UVZsWmJWcmhmb1l6YWd4MjZiN2M2T2FRbndoXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

其中，README.md的作用仅仅是描述项目，并不影响开发者的使用。所以我们要生成代码时，完全不用修改

README.md的任何内容，直接复制即可。我们将这类文件定义为"静态文件”。

而MainTemplate.java是开发者实际要使用的ACM输入模板文件，默认是包含了循环接受输入的逻辑的。示

例代码如下：

```Java
Scanner sc = new Scanner();
while(sc.hasNext()) {
    // 读取输入元素个数
    int n = sc.nextInt();
    ...
    System.out.print("sum: " + sum);
}
```

但如果用户不需要循环输入，只要保留其他代码呢？像下面这样删除while代码片段：

```Java
Scanner sc = new Scanner(System.in);
// 读取输入元素个数
int n = sc.nextInt();
...
System.out.print("sum: " + sum);
```

也就是说，这个文件是需要作为一个**基础模板**，能够接受用户的输入从而支持定制化生成的。我们将这类文件定

义为“动态文件”。

将文件划分为静态和动态后，我们就可以将需求拆解为“生成静态文件”和“生成动态文件”两个步骤了。

同理，我们再思考如何制作基于命令行的脚手架。在制作命令行工具前，我们是不是可以先通过直接运行Main方法、在Main方法中写死输入参数如的方式实现完整的代码生成逻辑呢？然后只需要把在Main方法中写死的输入参数改为读取命令行来接收，剩下的逻辑不都可以复用了么？最后，可以再改变执行方式，把Main方法运行改为调用jar包（脚本）。

实现步骤

通过上面的需求拆解后，第一阶段的实现方案和流程就非常清晰了：

1.  生成静态文件，通过Main方法运行
2.  生成动态文件，通过Main方法运行
3.  同时生成静态和动态文件，通过Main方法运行，得到完整代码生成
4.  开发命令行工具，接受用户的输入并生成完整代码
5.  将工具封装为jar包和脚本，供用户调用

明确了实现步骤后，你会发现每一步都只需要解决一个小问题，不再像最初定的目标一样让我们毫无头绪了。接下来我们就一步一步实现即可，本节教程会完成第1-3步，即编写一个通过Main方法生成完整代码的程序。

## 三、静态文件生成

此处的静态文件，是我们根据需求下的一个定义，指生成时可以直接复制、不做任何改动的文件。

我们就先定个小目标：输入一个项目的目录，在另一个位置生成一模一样的项目文件。

你会如何实现呢？

其实本质上就是复制文件嘛！

这里提供2种方法：

1.  使用现成的工具库直接复制完整目录
2.  手动递归复制目录和文件

### 1、现成的工具库复制目录

我们在初始化`manneia-generator-basic`项目时，就已经引入了Hutool库的依赖.

Hutool是一个功非常齐全的工具集，包含了HTTP请求、日期时间处理、集合类处理、文件处理、JSON处理等能够大幅提高开发效率的工具类。

>   Hutoo官方档：https:/www.hutool..cn/

先编写一个公开的静态方法`copyFilesByHutool`,方法中的核心代码就一行，直接调用`Hutool`提供的`FileUtil.copy`方法，就能实现指定目录下所有文件的复制！

```Java
/**
 * 拷贝文件
 * @param inputPath 源路径
 * @param outputPath 输出路径
 */
public static void copyFilesByHuTool(String inputPath, String outputPath) {
    FileUtil.copy(inputPath, outputPath, false);
}
```

然后编写一个Main方法来调用这个方法即可，完整复制我们之前准备好的ACM示例代码模板（建议使用相对路径)。

示例代码如下：

```Java
public static void main(String[] args) {
    // 根目录
    String projectPath = System.getProperty("user.dir");
    File parentFile = new File(projectPath).getParentFile();
    // 源路径
    String inputPath = new File(projectPath,"manneia-generator-demo-projects/acm-template").getPath();
    System.out.println("projectPath: "+projectPath);
    System.out.println("parentFile: " + parentFile);
    System.out.println("inputPath" + inputPath);
    copyFilesByHuTool(inputPath, projectPath);
}
```

### 2、递归遍历

```Java
/**
 * 递归拷贝文件
 *
 * @param inputFile  输入文件
 * @param outputFile 输出文件
 * @throws IOException 异常类
 */
private static void copyFilesByRecursive(File inputFile, File outputFile) throws IOException {
    if (inputFile.isDirectory()) {
        System.out.println(inputFile.getName());
        File destOutputFile = new File(outputFile, inputFile.getName());
        if (!destOutputFile.exists()) {
            destOutputFile.mkdirs();
        }
        File[] files = inputFile.listFiles();
        if (ArrayUtil.isEmpty(files)) {
            return;
        }
        for (File file : files) {
            copyFilesByRecursive(file, destOutputFile);
        }
    } else {
        Path destPath = outputFile.toPath().resolve(inputFile.getName());
        Files.copy(inputFile.toPath(), destPath, StandardCopyOption.REPLACE_EXISTING);
    }
}

/**
 * @param inputPath 源路径
 * @param destPath  输出路径
 */
public static void copyFilesByRecursive(String inputPath, String destPath) {
    File inputFile = new File(inputPath);
    File outputFile = new File(destPath);
    try {
        copyFilesByRecursive(inputFile, outputFile);
    } catch (Exception e) {
        System.out.println("file copy failed");
        e.printStackTrace();
    }

}
```

## 四、动态文件生成思路

#### 明确动态生成需求

对于ACM 示例模板项目,我们可以怎么定制生成呢?

我们可以先明确几个动态生成的需求:

1.  在代码开头增加坐着@Author 注释 (增加代码)
2.  修改程序输出的信息提示 (替换代码)
3.  将循环读取输入改为单词读取 (可选代码)

#### 动态生成的核心原理

用户输入参数:

```Java
author = manneia
```

模板文件代码: 

```Java
/**
 * ACM 输入模板（多数之和）
 * @author ${author}
 */
```

将参数注入到模板中,得到完整的代码:

```Java
/**
 * ACM 输入模板（多数之和）
 * @author manneia
 */
```

## 五、FreeMaker 模板引擎

### 什么是模板引擎?为什么需要它?

模板引擎是一种用于生成动态内容的类库（或框架），通过将预定义的模板与特定数据合并，来生成最终的输出。

使用模板引擎有很多的优点，首先就是提供现成的模板文件语法和解析能力。开发者只要按照特定要求去编写模板文件，比如使用${参数}语法，模板引擎就能自动将参数注入到模板中，得到完整文件，不用再自己编写解析逻辑了。

其次，模板引擎可以将数据和模板分离，让不同的开发人员独立工作。比如后端专心开发业务逻辑提供数据，前端

专心写模板等，让系统更易于维护。

此外，模板引擎可能还具有一些安全特性，比如防止跨站脚本攻击等。所以强烈大家掌握至少一种模板引擎的用

法。

有很多现成的模板引擎技术，比如Java的Thymeleaf, FreeMarker、Velocity,前端的Mustache等。

#### 什么是FreeMarker?

FreeMarker是Apache的开源模板引擎，优点是入门简单、灵活易扩展。它不用和Spring开发框架、Servlet环境、第三方依赖绑定，任何Java项目都可以使用。

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MzM3MDc2YTAyNWZkMTc4NmRiMTMxZDZhMzllN2IxZjFfek1PZHlpYkJXbTBmZlZ2VFJ4WjVvQlFSc1B3dVpwUE1fVG9rZW46UlVEZmJ6V2dkb0FKWWl4cGU0V2NSZFR1bjJiXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

#### 模板引擎的作用

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDdiOTZiZTIxYTdhNDA3NjM1NGJlNGJhNGFjMjI3NzFfUlNHcTZPUU1JMmY3ZDAzUEZudEh4MlNJUlNHZWFWZ0ZfVG9rZW46SFVWNGJJdGowb0dDbld4QzU1Z2NsNkU5bk9jXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

### Demo 实战

1.  #### 引入依赖

```XML
<dependency>
    <groupId>org.freemarker</groupId>
    <artifactId>freemarker</artifactId>
    <version>2.3.31</version>
</dependency>
```

spring-boot项目:

```XML
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-freemarker</artifactId>
    <version>2.7.2</version>
</dependency>
```

1.  #### 创建配置对象

在test/java目录下新建一个单元测试类`FreeMarkerTest`,在Test方法中创建一个FreeMarker的全局配置对象，可以统一指定模板文件所在的路径、模板文件的字符集等。

```Java
Configuration configuration = new Configuration(Configuration.VERSION_2_3_32);
// 指定模板文件所在路径
configuration.setDirectoryForTemplateLoading(new File("src/main/resources/templates"));
// 指定字符集编码
configuration.setDefaultEncoding("UTF-8");
```

1.  #### 加载模板:

```Java
// 创建模板对象,加载指定模板
Template template = configuration.getTemplate("web.html.ftl");
```

1.  #### 创建数据模型

```Java
Map<String, Object> dataModel = new HashMap<>();
dataModel.put("currentYear", 2023);
List<Map<String,Object>> menuItems = new ArrayList<>();
Map<String,Object> menuItem = new HashMap<>();
menuItem.put("url","https://github.com/manneia?tab=repositories");
menuItem.put("label","编程导航");
menuItems.add(menuItem);
dataModel.put("menuItems", menuItems);
```

1.  #### 指定生成的文件

```Java
Writer out = new FileWriter("web.html");
```

## 六、动态文件生成实现

1.  ### 定义数据模型

```Java
package com.manneia.model;

import lombok.Data;

/**
 * 模板动态配置
 *
 * @author lkx
 */
@Data
public class MainTemplateConfig {

    /**
     * 作者
     */
    private String author;

    /**
     * 输出信息
     */
    private String outputText;

    /**
     * 是否开启循环
     */
    private boolean loop;
}
```

1.  ### 编写动态模板

```Java
package com.manneia.acm;

import java.util.Scanner;

/**
* ACM 输入模板（多数之和）
* @author ${author}
*/
public class MainTemplate {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        <#if loop>
        while (scanner.hasNext()) {
        </#if>
            // 读取输入元素个数
            int n = scanner.nextInt();
            // 读取数组
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            // 处理问题逻辑，根据需要进行输出
            // 示例：计算数组元素的和
            int sum = 0;
            for (int num : arr) {
                sum += num;
            }
            System.out.println("${outputText}: " + sum);
<#if loop>
        }
</#if>
        scanner.close();
    }
}
```

1.  ### 组合生成

```Java
package com.manneia.generator;

import com.manneia.model.MainTemplateConfig;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

/**
 * @author lkx
 */
public class DynamicGenerator {
    public static void main(String[] args) throws IOException, TemplateException {
        Configuration configuration = new Configuration(Configuration.VERSION_2_3_32);
        // 指定模板文件所在路径
        configuration.setDirectoryForTemplateLoading(new         File("src/main/resources/templates"));
        // 指定字符集编码
        configuration.setDefaultEncoding("utf-8");
        // 创建模板对象,加载指定模板
        Template template = configuration.getTemplate("MainTemplate.java.ftl");

        MainTemplateConfig templateConfig = new MainTemplateConfig();
        templateConfig.setAuthor("manneia");
        templateConfig.setOutputText("hello world");
        templateConfig.setLoop(true);
        Writer out = new FileWriter("web.html");
        template.process(templateConfig, out);
        out.close();
    }
}
```

1.  ### 完整代码

```Java
package com.manneia.generator;

import com.manneia.model.MainTemplateConfig;
import com.manneia.utils.Utils;
import freemarker.template.TemplateException;

import java.io.File;
import java.io.IOException;

import static com.manneia.generator.StaticGenerator.copyFilesByHuTool;

/**
 * @author lkx
 */
public class MainGenerator {
    public static void main(String[] args) {

        // 1. 静态文件生成
        String projectPath = Utils.getRootProperty();
        // 输入路径
        String inputPath = projectPath + File.separator + "manneia-generator-demo-projects" + File.separator + "acm-template";
        StaticGenerator.copyFilesByRecursive(inputPath, projectPath);

        // 2. 动态文件生成
        String dynamicInputPath = projectPath + File.separator+ "manneia-generator-basic" + File.separator + "src/main/resources/templates/MainTemplate.java.ftl";
        String dynamicOutputPath = projectPath + File.separator + "acm-template/src/com/manneia/acm/MainTemplate.java";
        MainTemplateConfig templateConfig = new MainTemplateConfig();
        templateConfig.setAuthor("manneia");
        templateConfig.setOutputText("你好,结果是");
        templateConfig.setLoop(true);

        try {
            DynamicGenerator.doGenerate(dynamicInputPath, dynamicOutputPath, templateConfig);
        } catch (IOException | TemplateException e) {
            throw new RuntimeException(e);
        }
    }
}
```

# 命令行开发

## 一、Java 命令行开发方案

### 什么是命令行程序?

命令行程序俗称CLI (Command Line Interface) ,是指通过命令行界面运行的应用程序。通过终端窗口接收用户输入的纯文本命令，并执行相应的任务。

一些常见的命令行环境包括Unix/Linux的终端、Windows的命令提示符和PowerShell等。学编程的同学可能没有开发过命令行程序，但一定都接触过终端！

### 命令的结构

-   Command: 命令类型
-   Option: 选项,用于改变命令的行为
-   Parameter: 参数,用于传递给命令行工具的值

### 为什么要开发命令行?

命令行程序的几个优点：

-   不依赖于特定的图形界面，非常轻量
-   通常可以直接在操作系统自带的终端环境中运行可以和用户交互、给用户输入引导和帮助手册
-   内置一些快捷操作（比如查看历史命令、上下切换命令）

还有一个最大的优点一简单直接，比如复制粘贴别人写好的命令就能纳行，而不用像使用网页一样点击多次，非常符合程序员的使用（偷懒）习惯，less is more!

### 命令行的作用

可以使用命令行程序来和用户交互，引导用户输入代码生成的定制参数，并将输入参数封装为配置对象，然后“喂”给之前编写好的代码生成器来生成文件。

比如之间我们的动态模板配置MainTemplateConfig中包含loop、author、outputText这3个参数，那么可以上用户输入下列完整命令，来给模板配置传值：

### 实现方案

1.  #### 自主实现

使用Java内置的类库自主实现,比如通过Scanner读取用户的输入来实现

缺点: 

1.  需要自主解析用户输入的命令
2.  需要自主编写一套获取参数的交互流程
3.  需要自主实现更多高级功能

1.  #### 第三方库

-   picocli : 命令行工具开发框架
-   JLine : 控制台输入处理库

## 二、Picocli 命令行框架入门

### 入门Demo

1.  引入依赖

```XML
<!-- https://picocli.info/ -->
<dependency>
    <groupId>info.picocli</groupId>
    <artifactId>picocli</artifactId>
    <version>4.7.5</version>
</dependency>
```

1.  复制官方快速入门教程中的示例代码到`com.manneia.cli.example`包下,并且略微修改run方法中的代码,打印参数的值:

```Java
package com.manneia.cli.example;

import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;
import picocli.CommandLine.Parameters;

import java.util.Arrays;
// some exports omitted for the sake of brevity

/**
 * @author lkx
 */
@Command(name = "ASCIIArt", version = "ASCIIArt 1.0", mixinStandardHelpOptions = true)
public class ASCIIArt implements Runnable { 

    @Option(names = { "-s", "--font-size" }, description = "Font size") 
    int fontSize = 19;

    @Parameters(paramLabel = "<word>", defaultValue = "Hello, picocli", 
               description = "Words to be translated into ASCII art.")
    private String[] words = { "Hello,", "picocli" }; 

    @Override
    public void run() { 
        // The business logic of the command goes here...
        // In this case, code for generation of ASCII art graphics
        // (omitted for the sake of brevity).
        System.out.println("fontSize= " + fontSize);
        System.out.println("words= " + Arrays.toString(words));
    }

    public static void main(String[] args) {
        int exitCode = new CommandLine(new ASCIIArt()).execute(args); 
        System.exit(exitCode); 
    }
}
```

1.  更改主程序的执行参数测试程序

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ODVjYjM2ZTI0MDQ2ODJlMWMzYzQzYzU0ZDQ3YjE3NjBfZmlNRVJXdFF2WkRFaVhBTzBLdnRGUkt1MXBBcld3RUNfVG9rZW46UWRRbmJxOWROb0ZDdFp4UFkzOGNVNEM1bkNiXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

## 三、命令模式

### 什么是命令模式? 

命令模式是一种行为类设计模式，核心是将每种请求或操作封装为一个独立的对象，从而可以集中管理这些请求或操作，比如将请求队列化依次执行、或者对操作进行记录和澈销。

命令模式通过将请求的发送者（客户端）和接收者（执行请求的对象）解耦，提供了更大的灵活性和可维护性。听不懂上面这句话很正常，我来举个例子。

我们在生活中都用过电视机，我们就相当于客户端，要操作电视来换台；而电视就是执行请求的对象，要根据我们的操作来换台。但是我们一般不会直接按电视上的按钮来换台，而是用一个遥控器，通过点击遥控器上的操作按钮来控制电视。

这样就相当于把我们和电视解耦了。哪怕遥控器丢了，再换一个遥控器就好了；而目现在手机都能作为万能的电视遥控器，我们可以同时遥控多个品牌的设备，不用关心设备的具体品牌型号，提供了更大的方便。

### 命令模式的优点和应用场景

正如上面的例子，命令模式最大的优点就是解耦请求发送者和接受者，让系统更加灵活、可扩展。

由于每个操作都是一个独立的命令类，所以我们需要新增命令操作时，不需要改动现有代码。

命令模式典型的应用场景：

-   系统需要统一处理多种复杂的操作，比如操排队、记录操作历史、撤销重做等。
-   系统需要持续增勖加新的命令、或者要处理复杂的组合命令（子命令），使用命令模式可以实现解耦。

本项目要开发的命令行工具，就符合这两个应用场景。

### 命令模式的要素和实现

#### 1) 命令

命令是一个抽象类或接口,它定义了执行操作的方法, 通常是`excute`,该方法封装了具体的操作:

```Java
public interface Command {
    void execute();
}
```

#### 2) 具体命令

具体命令是命令接口的具体实现类，它负责将请求传递给接收者（设备）并执行具体的操作。

##### 关闭灯光

```Java
package com.manneia.cli.pattern;

/**
 * @author lkx
 */
public class TurnOffCommand implements Command {

    private final Device device;

    public TurnOffCommand(Device device) {
        this.device = device;
    }

    @Override
    public void execute() {
        device.turnOff();
    }
}
```

##### 开启灯光

```Java
package com.manneia.cli.pattern;

/**
 * @author lkx
 */
public class TurnOnCommand implements Command {

    private final Device device;

    public TurnOnCommand(Device device) {
        this.device = device;
    }

    @Override
    public void execute() {
        device.turnOn();
    }
}
```

#### 3) 接收者

```Java
package com.manneia.cli.pattern;

/**
 * @author lkx
 */
public class Device {

    private final String name;

    public Device(String name) {
        this.name = name;
    }

    public void turnOff() {
        System.out.println(name + "关灯");
    }

    public void turnOn() {
        System.out.println(name + "开灯");
    }
}
```

#### 4) 调用者

```Java
package com.manneia.cli.pattern;

/**
 * @author lkx
 */
public class RemoteController {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute();
    }
}
```

#### 5) 客户端

```Java
package com.manneia.cli.pattern;

/**
 * @author lkx
 */
public class Client {
    public static void main(String[] args) {
        Device tv = new Device("TV");
        Device stereo = new Device("Stereo");

        TurnOnCommand turnOnCommand = new TurnOnCommand(tv);
        TurnOffCommand turnOffCommand = new TurnOffCommand(stereo);

        RemoteController remoteController = new RemoteController();

        remoteController.setCommand(turnOnCommand);
        remoteController.pressButton();
        remoteController.setCommand(turnOffCommand);
        remoteController.pressButton();
    }
}
```

整个程序的UML图如下:

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQzODYxMDA3MTFhZWFlNDkyNTI2YTlmMWIxNjQ5ZmFfTkQzajhSOVBFSmhTNnVOUm43MVdRUldOSXlDYXpoOTRfVG9rZW46WllTd2JMbllFb0FWYVh4ckU4UGNOQ0VLbjZmXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

## 四、Picocli 命令行代码生成器开发

整个开发过程分为6个步骤:

1.  创建命令执行器
2.  分别实现每种命令
3.  提供项目的全局调用入口
4.  构建程序jar包
5.  测试使用
6.  简化使用 (封装脚本)

### 1、创建命令执行器

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Y4YzU2MWIwOWUyYWU5NzRjNDcxY2ExOTEzYWFkN2JfcXVDUEpYOFJxaTh1dXQ3NlpESGV4Q01FRVEwYldaZmNfVG9rZW46Q2tPU2J4RGVIb1J2aG14UGJ4WGNYOHNlbm00XzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

然后在`com.manneia.cli`包下创建命令执行器`CommandExecutor`,负责绑定所有子命令,并且提供执行命令的方法.

完整代码如下: 

```Java
package com.manneia.cli;

import com.manneia.cli.command.ConfigCommand;
import com.manneia.cli.command.GeneratorCommand;
import com.manneia.cli.command.ListCommand;
import picocli.CommandLine;
import picocli.CommandLine.Command;

/**
 * @author lkx
 */
@Command(name = "manneia", mixinStandardHelpOptions = true)
public class CommandExecutor implements Runnable {
    private final CommandLine commandLine;

    {
        commandLine = new CommandLine(this)
                .addSubcommand(new GeneratorCommand())
                .addSubcommand(new ConfigCommand())
                .addSubcommand(new ListCommand());
    }


    @Override
    public void run() {
        // 不输入子命令时,给出友好提示
        System.out.println("请输入具体命令,或者输入--help 查看命令提示");
    }

    /**
     * 执行命令
     *
     * @param args 命令数组
     * @return 返回执行结果
     */
    public Integer doExecute(String[] args) {
        return commandLine.execute(args);
    }
}
```

### 2、子命令实现

#### Generator 子命令

是代码生成器的核心命令, 作用是接受参数并生成代码

实现步骤如下: 

1.  定义参数选项。和之前动态生成代码定义的数据模型`MainTemplateConfig`属性一致即可。使用Picocli

提供的注解来交互式获取参数信息`(interactive=true)`,并且对用户显示输入信息`(echo=true)`。

1.  使用`BeanUtil.copyProperties`快速将通过命令接受到的属性复制给`MainTemplateConfig`配置对象。
2.  调用之前开发好的`MainGenerator`代码生成类来生成代码。

完整代码: 

```Java
package com.manneia.cli.command;

import cn.hutool.core.bean.BeanUtil;
import com.manneia.generator.MainGenerator;
import com.manneia.model.MainTemplateConfig;
import picocli.CommandLine.Option;

import java.util.concurrent.Callable;

/**
 * @author lkx
 */
public class GeneratorCommand implements Callable<Integer> {

    @Option(names = {"-l", "--loop"}, arity = "0..1", description = "是否开启循环",
            interactive = true, echo = true)
    private boolean loop;

    @Option(names = {"-a", "--author"}, arity = "0..1", description = "作者",
            interactive = true, echo = true)
    private String author = "manneia";

    @Option(names = {"-o", "--output"}, arity = "0..1", description = "输出文本",
            interactive = true, echo = true)
    private String outputText = "sum = ";

    @Override
    public Integer call() throws Exception {
        MainTemplateConfig config = new MainTemplateConfig();
        BeanUtil.copyProperties(this, config);
        System.out.println("配置信息: " + config);
        MainGenerator.doGenerator(config);
        return 0;
    }
}
```

#### List 子命令

List 是一个辅助命令,作用是遍历输出所有要生成的文件列表.

此处由于我们要生成的项目文件都封装在了`acm-template`目录下,所以直接用Hutool库提供的`FileUtil.loopFiles(inputPath)`方法来遍历该目录下的所有文件.

完整代码:

```Java
package com.manneia.cli.command;

import cn.hutool.core.io.FileUtil;
import picocli.CommandLine.Command;

import java.io.File;
import java.util.List;

/**
 * @author lkx
 */
@Command(name = "list", description = "查看文件列表", mixinStandardHelpOptions = true)
public class ListCommand implements Runnable {
    @Override
    public void run() {
        String projectPath = System.getProperty("user.dir");
        // 整个项目的根路径
        File parentFile = new File(projectPath).getParentFile();
        // 输入路径
        List<File> files = FileUtil.loopFiles(parentFile);
        // 遍历输出文件
        files.forEach(System.out::println);
    }
}
```

#### Config 子命令

Config 是一个辅助命令,作用是输出允许用户传入的动态参数信息(也就是本项目`MainTemplateConfig`类的字段信息).

最简单的方法就是直接手写打印信息,比较灵活,缺点是不利于维护

更推荐的方法是通过 Java 的反射机制,在程序运行时动态打印出对象属性的信息,又有两种方法: 

1.   Jdk 原生反射语法

```Java
package com.manneia.cli.command;

import com.manneia.model.MainTemplateConfig;

import java.lang.reflect.Field;

/**
 * @author lkx
 */
public class ConfigCommand implements Runnable{
    @Override
    public void run() {
        Class<?> mainTemplateConfigClass = MainTemplateConfig.class;
        // 获取类的所有字段
        Field[] declaredField = mainTemplateConfigClass.getDeclaredFields();
        for (Field field : declaredField) {
            System.out.println(field);
        }
    }

    public static void main(String[] args) {
        new ConfigCommand().run();
    }
}
```

1.  Hutool 反射工具类

```Java
package com.manneia.cli.command;

import cn.hutool.core.util.ReflectUtil;
import com.manneia.model.MainTemplateConfig;

import java.lang.reflect.Field;

/**
 * @author lkx
 */
public class ConfigCommand implements Runnable{
    @Override
    public void run() {
        Field[] fields = ReflectUtil.getFields(MainTemplateConfig.class);
        for (Field field : fields) {
            System.out.println(field.getName());
        }
    }
}
```

### 3、全局调用入口

```Java
package com.manneia;

import com.manneia.cli.CommandExecutor;

/**
 * @author lkx
 */
public class Main {
    public static void main(String[] args) {
        //        args = new String[] {"generator", "-l", "-a", "-o"};
        //        args = new String[]{"config"};
        //        args = new String[]{"list"};
        CommandExecutor commandExecutor = new CommandExecutor();
        commandExecutor.doExecute(args);
    }
}
```

### 4、jar包构建

1.  先修改`Main.Main`主类,不再强制指定参数

```Java
package com.manneia;

import com.manneia.cli.CommandExecutor;

/**
 * @author lkx
 */
public class Main {
    public static void main(String[] args) {
        CommandExecutor commandExecutor = new CommandExecutor();
        commandExecutor.doExecute(args);
    }
}
```

1.  使用`maven`打包构建

在`pom.xml`中引入`maven-assembly-plugin`插件

```XML
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-assembly-plugin</artifactId>
            <version>3.3.0</version>
            <executions>
                <execution>
                    <phase>package</phase>
                    <goals>
                        <goal>single</goal>
                    </goals>
                </execution>
            </executions>
            <configuration>
                <descriptorRefs>
                    <descriptorRef>jar-with-dependencies</descriptorRef>
                </descriptorRefs>
                <archive>
                    <manifest>
                        <mainClass>com.manneia.Main</mainClass>
                    </manifest>
                </archive>
            </configuration>
        </plugin>
    </plugins>
</build>
```

### 5、测试使用

```Shell
java -jar manneia-generator-basic-1.0-SNAPSHOT-jar-with-dependencies.jar generate -l -o -a
```

### 6、封装脚本

1.  Linux Bash 脚本

```Shell
#!/bin/bash

java -jar manneia-generator-basic-1.0-SNAPSHOT-jar-with-dependencies.jar "$@"
```

1.  Windows 脚本

```Shell
@echo off

java -jar manneia-generator-basic-1.0-SNAPSHOT-jar-with-dependencies.jar %*
```

# 代码生成器制作工具开发

## 一、代码生成器制作工具规划

### 明确需求和业务

目标是做一个本地的代码生成器制作工具,能够快速的将一个项目制作为可以动态定制部分内容的代码生成器.

### 实现思路

想要实现上述功能,其实还是很复杂的,要考虑很多问题,比如:

1.   工具应该提供哪些能力?怎么提高代码生成器的制作效率?
2.  如何动态生成命令行工具? 如何动态打 jar 包?
3.  如何动态生成模板文件? 怎么从原始文件中抽取参数? 有哪些类型的参数?

### 步骤

1.  开发基础的代码生成器制作工具

移除第一阶段ACM模板生成器项目的硬编码，能在已有项目模板的基础上，通过读取人工配置跑通代码生成器的核心制作流程（不用在代码中找路径、改路径了），生成代码生成器。

1.  配置文件增强

以实现Spring Boot初始化项目模板生成器的生成为目标，给配置文件增加更多参数，可以更灵活地制作更复杂的代码生成器。

1.  工具能力增强

给代码生成器制作工具增加更多能力，可以帮助开发者自动生成/更新配置文件、FTL动态模板文件等，进一步提高制作效率。

## 二、核心设计

### 需求分析

一个基础的代码生成器制作工具,应该具有哪些功能呢?

回顾第一阶段,我们纯手工开发一个代码生成器,大概经过了这些步骤:

1.  基于一个要生成的项目,手动挖坑,制作FTL 动态模板文件
2.  编写数据模型文件
3.  编写Picocli 命令类
4.  编写代码生成文件 Generator (文件路径还是硬编码 "写死" 的)
5.  手动执行 Maven 命令打 jar包
6.  自己封装快捷执行脚本

其中,第一步可能是最复杂的,因为决定了一个项目中哪些参数是可替换的,替换到哪个位置,目前我们可能还不知道怎么提高这一步的效率.

### 元信息定义

为什么需要元信息文件呢? 本质上是把项目中硬编码的内容转换为可以灵活配置的内容

#### 元信息的存储结构

此处我们选用 JSON 格式存储元信息, 将元信息文件定义为`meta.json`,之后放在制作工具项目下的`resources`目录下

#### 元信息的字段配置

元信息文件应该包含哪些配置信息?

可以采用两种方式,来确认这点

1.  参考其他项目的元信息配置,
2.  分析自己的项目,思考项目需要用到哪些配置信息?

结合这两种方式,我们可以根据元信息的作用对配置字段进行分类,便于后面按层级组织配置:

1.  记录代码生成器的基本信息

比如项目名称,作者,版本号等

1.  记录生成文件信息

比如输入文件路径,输出路径,文件类别(目录或文件), 生成类别 (动态或静态)等

1.  记录数据模型信息

比如参数的名称,描述,类型,默认值等

## 三、代码生成器制作工具开发

开发顺序遵循上面需求分析中的步骤:

1.  项目初始化
2.  读取元信息
3.  生成数据模型文件
4.  生成Picocli命令类
5.  生成代码生成文件
6.  程序构建 jar 包
7.  程序封装脚本
8.  测试验证

### 1、maker 项目初始化

首先在项目根目录`manneia-generator`下新建一个代码生成器制作工具项目`manneia-generator-maker`.这次不需要用IDEA新建,直接复制`manneia-generator-basic`项目然后改名,最后在该项目内全局替换`manneia-generator-basic`为`manneia-generator-maker`

#### 代码和目录结构优化

1.  重命名`MainTemplateConfig.java`为`DataModel.java`
2.  优化`DynamicGenerator.java`

包括移除Main方法和多余的注释.补充文件不存在则创建文件和父目录的逻辑.修改文件名为`DynamicFileGenerator.java`

```Java
package com.manneia.maker.generator.file;

import cn.hutool.core.io.FileUtil;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

/**
 * @author lkx
 */
public class DynamicFileGenerator {

    /**
     * 生成文件
     *
     * @param inputPath  模板文件输入路径
     * @param outputPath 输出路径
     * @param model      数据模型
     * @throws IOException       IO异常
     * @throws TemplateException 模板异常
     */
    public static void doGenerate(String inputPath, String outputPath, Object model) throws IOException, TemplateException {
        // 创建模板配置对象, 参数为 FreeMarker 版本号
        Configuration configuration = new Configuration(Configuration.VERSION_2_3_32);
        File templateDir = new File(inputPath).getParentFile();
        // 指定模板文件所在路径
        configuration.setDirectoryForTemplateLoading(templateDir);
        // 指定字符集编码
        configuration.setDefaultEncoding("utf-8");
        // 创建模板对象,加载指定模板
        String templateName = new File(inputPath).getName();
        Template template = configuration.getTemplate(templateName);
        // 如果文件不存在,则创建目录
        if (!FileUtil.exist(outputPath)) {
            FileUtil.touch(outputPath);
        }
        // 生成
        Writer out = new FileWriter(outputPath);
        template.process(model, out);
        out.close();
    }
}
```

1.  优化`StaticGenerator.java`

为了保证后续的代码生成不出错,尽量不要用自己写的递归方法,只保留`copyFilesByHutool`,移除其他代码.然后修改文件名为`StaticFileGenerator.java`

```Java
package com.manneia.maker.generator.file;

import cn.hutool.core.io.FileUtil;
import cn.hutool.core.util.ArrayUtil;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;

/**
 * @author lkx
 */
public class StaticFileGenerator {

    /**
     * 拷贝文件
     *
     * @param inputPath  源路径
     * @param outputPath 输出路径
     */
    public static void copyFilesByHuTool(String inputPath, String outputPath) {
        FileUtil.copy(inputPath, outputPath, false);
    }
}
```

1.  优化`MainGenerator.java`将生成静态文件调用的方法改为`copyFileByHutool`.将文件名修改为`FileGenerator.java`

```Java
StaticFileGenerator.copyFilesByHuTool(inputPath, projectPath);
```

1.  将生成文件相关的类都从`maker.generator`包移动到`maker.generator.file`下,防止和后面的其他生成器混淆
2.  删除多余的无用代码,比如:
    1.  删除`.gitignore`文件,统一在项目根目录管理git文件
    2.  删除现有的`FTL`模板文件
    3.  删除单元测试文件
    4.  删除所有制作好的脚本文件等

#### 生成文件结构目录优化

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NGMxMmUwZGMwZTg1ZjY5NDA3YTNiNGJkZWJhOGE5NmNfVnVaUnBzZktrc3lxUTlLOEZxaVFyY1JsaHFCZnJjOTRfVG9rZW46TFZwcGJvQW5Tb3RxODF4SmhnU2NLTWRtbkZlXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

### 2、读取元信息

#### 元信息定义

我们将`meta.json`存放到maker项目的`resources`目录下

主要包含字段:

```JSON
{
  "name": "acm-template-pro-generator",
  "description" : "ACM 示例模板生成器",
  "basePackage": "com.manneia",
  "version": "1.0",
  "author": "manneia",
  "createTime": "2024-3-3",
  "fileConfig": {
    "inputRootPath": "D:/Project/project/manneia-generator/manneia-generator-demo-projects/acm-template-pro",
    "outputRootPath": "generated",
    "type": "dir",
    "files": [
      {
        "inputPath": "src/com/manneia/acm/MainTemplate.java.ftl",
        "outputPath": "src/com/manneia/acm/MainTemplate.java",
        "type": "file",
        "generateType": "dynamic"
      },
      {
        "inputPath": ".gitignore",
        "outputPath": ".gitignore",
        "type": "file",
        "generateType": "static"
      },
      {
        "inputPath": "README.md",
        "outputPath": "README.md",
        "type": "file",
        "generateType": "static"
      }
    ]
  },
  "modelConfig": {
    "models": [
      {
        "fieldName": "loop",
        "type": "boolean",
        "description": "是否生成循环",
        "defaultValue": false,
    {
  "name": "acm-template-pro-generator",
  "description" : "ACM 示例模板生成器",
  "basePackage": "com.manneia",
  "version": "1.0",
  "author": "manneia",
  "createTime": "2024-3-3",
  "fileConfig": {
    "inputRootPath": "D:/Project/project/manneia-generator/manneia-generator-demo-projects/acm-template-pro",
    "outputRootPath": "generated",
    "type": "dir",
    "files": [
      {
        "inputPath": "src/com/manneia/acm/MainTemplate.java.ftl",
        "outputPath": "src/com/manneia/acm/MainTemplate.java",
        "type": "file",
        "generateType": "dynamic"
      },
      {
        "inputPath": ".gitignore",
        "outputPath": ".gitignore",
        "type": "file",
        "generateType": "static"
      },
      {
        "inputPath": "README.md",
        "outputPath": "README.md",
        "type": "file",
        "generateType": "static"
      }
    ]
  },
  "modelConfig": {
    "models": [
      {
        "fieldName": "loop",
        "type": "boolean",
        "description": "是否生成循环",
        "defaultValue": false,
        "abbr": "l"
      },
      {
        "fieldName": "author",
        "type": "String",
        "description": "作者注释",
        "defaultValue": "manneia",
        "abbr": "a"
      },
      {
        "fieldName": "outputText",
        "type": "String",
        "description": "输出信息",
        "defaultValue": "sum= ",
        "abbr": "o"
      }
    ]
  }
}    "abbr": "l"
      },
      {
        "fieldName": "author",
        "type": "String",
        "description": "作者注释",
        "defaultValue": "manneia",
        "abbr": "a"
      },
      {
        "fieldName": "outputText",
        "type": "String",
        "description": "输出信息",
        "defaultValue": "sum= ",
        "abbr": "o"
      }
    ]
  }
}
```

分别解释:

-   Name: 代码生成器名称,项目的唯一标识
-   Description: 生成器的描述
-   basePackage: 控制生成代码的基础包名
-   Version: 生成器的版本号
-   Author: 作者名称
-   createTime: 创建时间
-   fileConfig: 是一个对象,用于控制文件的生成配置
-   modelConfig: 是一个对象,用于控制数据模型参数

#### 元信息模型类

在`maker.meta`包下创建`Meta`类,用于接受字段

可以通过`GsonFormatPlus`插件一键生成json对象

步骤:

1.  安装插件:

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDM2NTA2MTgwNmQxZjdkNzczMTEzZjQ3Y2RmNTE1MmFfY1Z4SDNKeTlnYlpzUXhPZlM1Q1FGelJaalhETERrNkVfVG9rZW46TEx0emJQT0dvb1d3NEN4eEdGamM3dmZHbnVXXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

1.  打开`Meta`文件.按下`Alt + insert`,选择`GsonFormatPlus`:

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MjM3ZTAxMjhlMTU3YzVhMjdjMTcyZTY2OTRmYWEyNjVfbHlzSENlaEJZQmd6Y3puVW96WDRIZzJtbTgwMEpDNUhfVG9rZW46WGp3d2JRa3hzb3NBdGZ4NkFneWNVQlQ1bm1mXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

1.  将完整的meta.json复制到窗口中

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YjdjYzNmN2Q1Yzg4MWU2MDc3OTZjMWE0ZWI5Yjc5YTVfeDNyTmMwZGl0b1haR2dOZzF5QllyN25wc3JwRHlLZ1VfVG9rZW46R3pUbmJpaEdzb3RXS0h4am5kemM0dkk1bldkXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

1.  点击左下角的setting按钮,弹出高级配置,按照下图规则进行配置:

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NmQ1NDc5YjZkMmZhYjY4YzRhYmMzNWM0OTNlNTFlMzRfM1dyU0FjSTQ3RjJiem9SajZGUHBvZ0IwSzJGTUlkSFhfVG9rZW46VE5sdWJhdEdlb1hiRHF4OWV4eWM2QWUwbm9mXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

1.  最后点击ok,即可生成

```Java
package com.manneia.maker.meta;

import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * 元信息对象
 *
 * @author lkx
 */
@NoArgsConstructor
@Data
public class Meta {

    private String name;
    private String description;
    private String basePackage;
    private String version;
    private String author;
    private String createTime;
    private FileConfig fileConfig;
    private ModelConfig modelConfig;

    @NoArgsConstructor
    @Data
    public static class FileConfig {
        private String inputRootPath;
        private String outputRootPath;
        private String type;
        private List<FileInfo> fileInfoList;

        @NoArgsConstructor
        @Data
        public static class FileInfo {
            private String inputPath;
            private String outputPath;
            private String type;
            private String generateType;
        }
    }

    @NoArgsConstructor
    @Data
    public static class ModelConfig {
        private List<ModelInfo> modelInfoList;

        @NoArgsConstructor
        @Data
        public static class ModelInfo {
            private String fieldName;
            private String type;
            private String description;
            private Object defaultValue;
            private String abbr;
        }
    }
}
```

生成完代码后,一定要人工校验,防止出错.

此处我们要做几个小改动

1.  将`Files`改名为`FileInfo`.复数变单数,更好理解
2.  将`models`改名为`modelInfo`.
3.  修改`ModelInfo.defaultValue`的类型为`Object`.同时兼容多种不同的类型

#### 读取元信息 - 单例模式

如何将json的值填充到实体对象中呢?

很简单,先读取到资源目录下的元信息文件,然后使用Hutool的`JSONUtil.toBean`方法

```Java
String metaJson = ResourceUtil.readUtf8Str("meta.json");
Meat newMeta = JSONUtil.toBean(metaJson,Meta.class);
```

但是我们每次想获取对象时，都要重复执行这些操作么？

当然不需要，因为配置文件在运行时基本不会发生变更，所以我们只需要得到一个Meta对象，保存到内存中，之后就可以复用了，避免重复创建对象的开销。

为了实现这个能力，我们可以使用一种设计模式一单例模式。保证项目运行期间只有一个Meta对象被创建，并且能够轻松获取。

在`maker.meta`包下新建`MetaManager`类，用于实现单例模式，代码如下：

```Java
package com.manneia.maker.meta;

import cn.hutool.core.io.resource.ResourceUtil;
import cn.hutool.json.JSONUtil;

/**
 * @author lkx
 */
public class MetaManager {

    private static volatile Meta meta;

    public static Meta getMetaObject() {
        if (meta == null) {
            synchronized (Meta.class) {
                if (meta == null) {
                    meta = initMeta();

                }
            }
        }
        return meta;
    }

    private static Meta initMeta() {
        String meatJson = ResourceUtil.readUtf8Str("meta.json");
        Meta meta = JSONUtil.toBean(meatJson, Meta.class);
        // todo 校验配置参数是否合法, 处理默认值

        return meta;
    }

}
```

解释一下上述代码: 

1.  定义了`meta`属性,用于接受JSON配置.使用`volatile`关键字修饰,确保多线性环境下的可见性.
2.  定义了一个私有构造函数,防止外部用new的方式创建出多个对象,破坏单例
3.  定义了`getMetaObject`方法,用于获取 meta 对象. 如果是首次获取,则执行`initMeta`方法来初始化meta对象;否则直接获取已有对象.此处使用双检索进行并发控制,既保证了对象获取性能不会被锁影响,也能防止重复实例化
4.  定义了`initMeta`方法,用于从JSON文件中获取对象属性并初始化meta对象.当然后续还可以执行对象校验,填充默认值等操作

之后获取meta对象信息,只需要调用`MetaManager.getMetaObject`方法即可,相比每次获取JSON文件并解析提高了性能并简化代码

单例模式除了双检锁实现外，还有一种很常见的实现方式一饿汉式单例模式。

使用饿汉式单例模式，类加载时即初始化对象实例，从而保证在任何时候都只有一个实例。

饿汉式单例模式的优点是实现更简单，实现关键如下：

1)   将meta属性声明为private static final,并在声明时进行初始化。
2)   将实例初始化逻辑提取到私有方法initMeta中，保特代码的清和可读性。

```Java
package com.manneia.maker.meta;

import cn.hutool.core.io.resource.ResourceUtil;
import cn.hutool.json.JSONUtil;

/**
 * @author lkx
 */
public class MetaManager {

    private static volatile Meta meta = initMeta();
    
    private MetaManager(){
        // 私有构造防止外部实例化
    }

    public static Meta getMetaObject() {
        return meta;
    }

    private static Meta initMeta() {
        String meatJson = ResourceUtil.readUtf8Str("meta.json");
        Meta meta = JSONUtil.toBean(meatJson, Meta.class);
        // todo 校验配置参数是否合法, 处理默认值

        return meta;
    }

}
```

### 3、生成数据模型文件

之前的数据模型文件（MainTemplateConfig.java）是我们自己编写的，现在我们要通过元信息自动生成

#### 元信息定义

```JSON
{
    ...
    "modelConfig": {
      "models": [
        {
          "fieldName": "loop",
          "type": "boolean",
          "description": "是否生成循环",
          "defaultValue": false,
          "abbr": "l"
        },
        {
          "fieldName": "author",
          "type": "String",
          "description": "作者注释",
          "defaultValue": "yupi",
          "abbr": "a"
        },
        {
          "fieldName": "outputText",
          "type": "String",
          "description": "输出信息",
          "defaultValue": "sum = ",
          "abbr": "o"
        }
      ]
    }
  }
```

分别解释:

-   fieldName: 参数名称,模型字段的唯一标识
-   Type: 参数类别,比如字符串
-   Description: 参数的描述信息
-   defaultValue: 参数的默认值
-   Abbr: 参数的缩写,用于生成命令行选项的缩写写法

#### 开发实现

##### **FTL文件**

在`resources/templates/java/model`目录下新建数据模板文件 `DataModel.java.ftl`

**编写步骤（后文的FTL文件都是按照该步骤进行制作，直接在 .ftl 后缀文件进行编写，会打乱原有的格式排版）：**

-   新建`aaa`文件，复制粘贴原来的Java代码（DataModel.java）
-   使用freemarker模板语法，根据**元信息**，进行“挖坑”
-   文件名改为`DataModel.java.ftl`

```Java
package ${basePackage}.model;

import lombok.Data;

/**
 * 数据模型
 *
 * @author ${author}
 */
@Data
public class DataModel {

<#list modelConfig.models as modelInfo>

    <#if modelInfo.description??>
    /**
     * ${modelInfo.description}
     */
    </#if>
    private ${modelInfo.type} ${modelInfo.fieldName}<#if modelInfo.defaultValue??> =<#if modelInfo.type=="String">"${modelInfo.defaultValue?c}"<#else>${modelInfo.defaultValue?c}</#if></#if>;

</#list>
}
```

##### **调用测试**

在`maker.generator.main`包下的`MainGenerator.java`，测试能否按照预期生成文件

调用代码的实现步骤：

-   定义生成文件的根路径，选择当前项目下的`generated/生成器名称`目录，注意在根目录下的`.gitignore`文件中忽略`generated`目录
-   定义要生成的Java代码根路径，需要将元信息中的`basePackage`转换为实际的文件路径
-   调用`DynamicFileGenerator`生成`DataModel`文件

```Java
package com.manneia.maker.generator;

import cn.hutool.core.io.FileUtil;
import cn.hutool.core.io.resource.ClassPathResource;
import cn.hutool.core.util.StrUtil;
import com.manneia.maker.generator.file.DynamicFileGenerator;
import com.manneia.maker.generator.utils.Utils;
import com.manneia.maker.meta.Meta;
import com.manneia.maker.meta.MetaManager;
import freemarker.template.TemplateException;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;

/**
 * @author lkx
 */
public class MainGenerator {
    public static void main(String[] args) {
        Meta meta = MetaManager.getMetaObject();
        System.out.println(meta);
        // 输出的根路径
        String projectPath = Utils.getRootProperty();
        String outputPath = projectPath + File.separator + "generated";
        if (FileUtil.exist(outputPath)) {
            FileUtil.mkdir(outputPath);
        }

        // 读取resources 目录
        ClassPathResource classPathResource = new ClassPathResource("");
        String resourceAbsolutePath = classPathResource.getAbsolutePath();

        // java包的基础路径
        // com.manneia
        String outputBasePackage = meta.getBasePackage();
        // com/manneia
        String outputBasePackagePath = StrUtil.join("/", StrUtil.split(outputBasePackage,
                "."));
        // generated/src/main/java/com/manneia/xxx
        String outputBaseJavaPackagePath = outputPath + File.separator + "src/main/java/" +
                outputBasePackagePath;

        String inputFilePath;
        String outputFilePath;

        // model.DataModel
        inputFilePath = resourceAbsolutePath + File.separator + "templates/java/model/DataModel.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "model/DataModel.java";
        try {
            DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);
        } catch (IOException | TemplateException e) {
            throw new RuntimeException(e);
        }
    }
}
```

生成结果

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=OWRkZTQ2MjZmNzY2N2IxYjY4MWRiMGNjZWRkYjk2ZTdfamhLdlR4Q2tqOUNkU1JoNk4zampQbHNMblBFWDRXd3RfVG9rZW46VG1FaGI5dWZ4b3d1V1d4TmgzNmN2Tk02bkdiXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

### 4、生成 Picocli 命令类

之前的Picocli 命令类相关代码是我们自己编写的，包括：

1.  具体命令：`GenerateCommand.java`、`ListCommand.java`和`ConfigCommand.java`
2.  命令执行器：`CommandExecutor.java`
3.  调用命令执行器的主类：`Main.java`

现在我们要通过元信息自动生成

#### 开发实现

##### FTL 文件

1）在`resources/templates/java/cil/command`目录下编写三个具体命令的FTL文件

GenerateCommand.java.ftl

```Java
package ${basePackage}.cli.command;

import cn.hutool.core.bean.BeanUtil;
import ${basePackage}.generator.MainGenerator;
import ${basePackage}.model.DataModel;
import lombok.Data;
import picocli.CommandLine.Option;
import picocli.CommandLine.Command;

import java.util.concurrent.Callable;

/**
 * @author lkx
 */
@Command(name = "generate", description = "生成代码", mixinStandardHelpOptions = true)
@Data
public class GenerateCommand implements Callable<Integer> {

    <#list modelConfig.models as modelInfo>
    /**
     * ${modelInfo.description}
     */
    @Option(names = {<#if modelInfo.abbr??>"-${modelInfo.abbr}",</#if>"--${modelInfo.fieldName}" }, arity = "0..1", <#if modelInfo.description??>description = "${modelInfo.description}",</#if>
            interactive = true, echo = true)
    private ${modelInfo.type} ${modelInfo.fieldName} <#if modelInfo.defaultValue??>= <#if modelInfo.type=="String">"${modelInfo.defaultValue?c}"<#else>${modelInfo.defaultValue?c}</#if></#if>;
    </#list>

    @Override
    public Integer call() throws Exception {
        DataModel config = new DataModel();
        BeanUtil.copyProperties(this, config);
        System.out.println("配置信息: " + config);
        MainGenerator.doGenerator(config);
        return 0;
    }
}
```

ListCommand.java.ftl

```Java
package ${basePackage}.cli.command;

import cn.hutool.core.io.FileUtil;
import picocli.CommandLine.Command;

import java.io.File;
import java.util.List;

/**
 * @author lkx
 */
@Command(name = "list", description = "查看文件列表", mixinStandardHelpOptions = true)
public class ListCommand implements Runnable {
    @Override
    public void run() {
        String inputPath = "${fileConfig.inputRootPath}";
        // 输入路径
        List<File> files = FileUtil.loopFiles(inputPath);
        // 遍历输出文件
        files.forEach(System.out::println);
    }
}
```

ConfigCommand.java.ftl

```Java
package ${basePackage}.cli.command;

import cn.hutool.core.util.ReflectUtil;
import ${basePackage}.model.DataModel;
import picocli.CommandLine.Command;

import java.lang.reflect.Field;

/**
 * @author lkx
 */
@Command(name = "config", description = "查看参数信息", mixinStandardHelpOptions = true)
public class ConfigCommand implements Runnable {
    @Override
    public void run() {
        System.out.println("查看参数信息");
        Field[] fields = ReflectUtil.getFields(DataModel.class);
        for (Field field : fields) {
            System.out.println("字段名称: " + field.getName());
            System.out.println("字段类型: " + field.getType());
            System.out.println("---");
        }
    }
}
```

2）在`resources/templates/java/cil`目录下编写`CommandExecutor.java.ftl`

CommandExecutor.java.ftl

```Java
package ${basePackage}.cli;

import ${basePackage}.cli.command.ConfigCommand;
import ${basePackage}.cli.command.GenerateCommand;
import ${basePackage}.cli.command.ListCommand;
import picocli.CommandLine;
import picocli.CommandLine.Command;

/**
 * @author lkx
 */
@Command(name = "${name}", mixinStandardHelpOptions = true)
public class CommandExecutor implements Runnable {
    private final CommandLine commandLine;

    {
        commandLine = new CommandLine(this)
                .addSubcommand(new GenerateCommand())
                .addSubcommand(new ConfigCommand())
                .addSubcommand(new ListCommand());
    }


    @Override
    public void run() {
        // 不输入子命令时,给出友好提示
        System.out.println("请输入具体命令,或者输入--help 查看命令提示");
    }

    /**
     * 执行命令
     *
     * @param args 命令数组
     * @return 返回执行结果
     */
    public Integer doExecute(String[] args) {
        return commandLine.execute(args);
    }
}
```

3）在`resources/templates/java`目录下编写`Main.java.ftl`

Main.java.ftl

```Java
package ${basePackage};

import ${basePackage}.cli.CommandExecutor;

/**
 * 全局调用入口
 */
public class Main {

    public static void main(String[] args) {
        CommandExecutor commandExecutor = new CommandExecutor();
        commandExecutor.doExecute(args);
    }
}
```

#### **调用测试**

```Java
package com.manneia.maker.generator;

import cn.hutool.core.io.FileUtil;
import cn.hutool.core.io.resource.ClassPathResource;
import cn.hutool.core.util.StrUtil;
import com.manneia.maker.generator.file.DynamicFileGenerator;
import com.manneia.maker.generator.utils.Utils;
import com.manneia.maker.meta.Meta;
import com.manneia.maker.meta.MetaManager;
import freemarker.template.TemplateException;

import java.io.File;
import java.io.IOException;

/**
 * @author lkx
 */
public class MainGenerator {
    public static void main(String[] args) throws TemplateException, IOException {
        Meta meta = MetaManager.getMetaObject();
        System.out.println(meta);
        // 输出的根路径
        String projectPath = Utils.getRootProperty();
        String outputPath = projectPath + File.separator + "generated";
        if (FileUtil.exist(outputPath)) {
            FileUtil.mkdir(outputPath);
        }

        // 读取resources 目录
        ClassPathResource classPathResource = new ClassPathResource("");
        String resourceAbsolutePath = classPathResource.getAbsolutePath();

        // java包的基础路径
        // com.manneia
        String outputBasePackage = meta.getBasePackage();
        // com/manneia
        String outputBasePackagePath = StrUtil.join("/", StrUtil.split(outputBasePackage,
                "."));
        // generated/src/main/java/com/manneia/xxx
        String outputBaseJavaPackagePath = outputPath + File.separator + "src/main/java/" +
                outputBasePackagePath;

        String inputFilePath;
        String outputFilePath;

        // model.DataModel
        inputFilePath = resourceAbsolutePath + File.separator + "templates/java/model/DataModel.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "model/DataModel.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // cli.command.GenerateCommand
        inputFilePath = resourceAbsolutePath + File.separator + "templates/java/cli/command/GenerateCommand.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "cli/command/GenerateCommand.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // cli.command.ListCommand
        inputFilePath = resourceAbsolutePath + File.separator + "templates/java/cli/command/ListCommand.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "cli/command/ListCommand.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // cli.command.ConfigCommand
        inputFilePath = resourceAbsolutePath + File.separator + "templates/java/cli/command/ConfigCommand.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "cli/command/ConfigCommand.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // cli.commandExecutor
        inputFilePath = resourceAbsolutePath + File.separator + "templates/java/cli/commandExecutor.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "cli/commandExecutor.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);
        // Main
        inputFilePath = resourceAbsolutePath + File.separator + "templates/java/Main.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "/Main.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);
    }
}
```

结果

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YzVjZmJkMzdlMTA1NjBkMzJhMmI0NmQ2MGYzMDQ1OGNfQlFtWThJenRVTUVHdVZlS3FFMnVqRzBwMDRWVlZoQnpfVG9rZW46TWZIUWJkS01Wb1YySDF4Q0xsamNMUFdibkxkXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

这样就能把maker项目中的`cli`包删掉了，**连同调用cli包的代码**也要注释或者删掉

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NmJjMWRiZWFhMDQ1NmRhODMwYWE2ZjhmNzhjNGIzNWRfWnRZVE12bEx1ZnNxNjc4MkdMQjA4UjFaQUEwUlBONW5fVG9rZW46WXE2R2I0bW9Xb3E3bGF4Q2NWOWNINkRFbmFlXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

### 5、生成代码生成文件

之前第一阶段的`dexcode-generator-basic`项目中，我们编写了代码生成的相关代码，包括：`StaticFileGenerator`、`DynamicFileGenerator`，最后调用`MainGenerator`来生成代码.

但是都**非常不优雅**地将文件路径**硬编码**到了生成文件中

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MjI4YWJlYjkyNzljZDYwZmEwNmM5NGU2ZTg2MGE0MzFfa3ZFaGk3ejllV0NKMk5zVkluUHpxeEZ3QUVJZDBpQ2NfVG9rZW46QjFDc2J5dXpHbzQ1TWF4UURlWGM3eVNxblJoXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

关于生成静态文件、动态文件的路径，现在我们要通过元信息自动生成

#### 元信息定义

```JSON
{
  "fileConfig": {
    "inputRootPath": "D:/Project/project/manneia-generator/manneia-generator-demo-projects/acm-template-pro",
    "outputRootPath": "generated",
    "type": "dir",
    "files": [
      {
        "inputPath": "src/com/manneia/acm/MainTemplate.java.ftl",
        "outputPath": "src/com/manneia/acm/MainTemplate.java",
        "type": "file",
        "generateType": "dynamic"
      },
      {
        "inputPath": ".gitignore",
        "outputPath": ".gitignore",
        "type": "file",
        "generateType": "static"
      },
      {
        "inputPath": "README.md",
        "outputPath": "README.md",
        "type": "file",
        "generateType": "static"
      }
    ]
  },
}
```

#### FTL文件

在`resources/templates/java/generator`目录下编写

1)   StaticGenerator.java.ftl

```Java
package ${basePackage}.generator;

import cn.hutool.core.io.FileUtil;

/**
 * @author lkx
 */
public class StaticGenerator {

    /**
     * 拷贝文件
     *
     * @param inputPath  源路径
     * @param outputPath 输出路径
     */
    public static void copyFilesByHuTool(String inputPath, String outputPath) {
        FileUtil.copy(inputPath, outputPath, false);
    }
}
```

2)   DynamicGenerator.java.ftl

```Java
package ${basePackage}.generator;

import cn.hutool.core.io.FileUtil;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

/**
 * @author lkx
 */
public class DynamicGenerator {

    /**
     * 生成文件
     *
     * @param inputPath  模板文件输入路径
     * @param outputPath 输出路径
     * @param model      数据模型
     * @throws IOException       IO异常
     * @throws TemplateException 模板异常
     */
    public static void doGenerate(String inputPath, String outputPath, Object model) throws IOException, TemplateException {
        // 创建模板配置对象, 参数为 FreeMarker 版本号
        Configuration configuration = new Configuration(Configuration.VERSION_2_3_32);
        File templateDir = new File(inputPath).getParentFile();
        // 指定模板文件所在路径
        configuration.setDirectoryForTemplateLoading(templateDir);
        // 指定字符集编码
        configuration.setDefaultEncoding("utf-8");
        // 创建模板对象,加载指定模板
        String templateName = new File(inputPath).getName();
        Template template = configuration.getTemplate(templateName);

        // 如果文件不存在,则创建目录
        if (!FileUtil.exist(outputPath)) {
            FileUtil.touch(outputPath);
        }
        // 生成
        Writer out = new FileWriter(outputPath);
        template.process(model, out);
        out.close();
    }
}
```

3)   MainGenerator.java.ftl

```Java
package ${basePackage}.generator;

import freemarker.template.TemplateException;

import java.io.File;
import java.io.IOException;

/**
 * @author ${author}
 */
public class MainGenerator {

    public static void doGenerator(Object model) throws TemplateException, IOException {
        String inputRootPath = "${fileConfig.inputRootPath}";
        String outputRootPath = "${fileConfig.outputRootPath}";
        String inputPath;
        String outputPath;
        <#list fileConfig.files as fileInfo>
            inputPath = new File(inputRootPath, "${fileInfo.inputPath}").getAbsolutePath();
            outputPath = new File(outputRootPath, "${fileInfo.outputPath}").getAbsolutePath();
        <#if fileInfo.generateType=="dynamic">
            DynamicGenerator.doGenerate(inputPath, outputPath, model);
        <#elseif fileInfo.generateType=="static">
            StaticGenerator.copyFilesByHuTool(inputPath, outputPath);
        </#if>
        </#list>
    }
}
```

#### 调用测试

`MainGenerator.java`新增代码：

```Java
package com.manneia.maker.generator;

import cn.hutool.core.io.FileUtil;
import cn.hutool.core.io.resource.ClassPathResource;
import cn.hutool.core.util.StrUtil;
import com.manneia.maker.generator.file.DynamicFileGenerator;
import com.manneia.maker.generator.utils.Utils;
import com.manneia.maker.meta.Meta;
import com.manneia.maker.meta.MetaManager;
import freemarker.template.TemplateException;

import java.io.File;
import java.io.IOException;

/**
 * @author lkx
 */
public class MainGenerator {
    public static void main(String[] args) throws TemplateException, IOException {
        Meta meta = MetaManager.getMetaObject();
        System.out.println(meta);
        // 输出的根路径
        String projectPath = Utils.getRootProperty();
        String outputPath = projectPath + File.separator + "generated";
        if (FileUtil.exist(outputPath)) {
            FileUtil.mkdir(outputPath);
        }

        // 读取resources 目录
        ClassPathResource classPathResource = new ClassPathResource("");
        String resourceAbsolutePath = classPathResource.getAbsolutePath();

        // java包的基础路径
        // com.manneia
        String outputBasePackage = meta.getBasePackage();
        // com/manneia
        String outputBasePackagePath = StrUtil.join("/", StrUtil.split(outputBasePackage,
                "."));
        // generated/src/main/java/com/manneia/xxx
        String outputBaseJavaPackagePath = outputPath + File.separator + "src/main/java/" +
                outputBasePackagePath;

        String inputFilePath;
        String outputFilePath;

        inputFilePath = resourceAbsolutePath + File.separator + "templates/java/generator/StaticGenerator.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + "/generator/StaticFileGenerator.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // generator.DynamicFileGenerator
        inputFilePath = resourceAbsolutePath + File.separator + "templates/java/generator/DynamicGenerator.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + "/generator/DynamicFileGenerator.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // generator.MainGenerator
        inputFilePath = resourceAbsolutePath + File.separator + "templates/java/generator/MainGenerator.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + "/generator/MainGenerator.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);
    }
}
```

结果:

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MzYwMmFmYzk3YTk3ZmFlZmE2Y2VkYzQ3ODliZDQyYWJfRmZKOTZGckZtM3dLTHlWN3M4a0JEWEZOMjhPeURVQlRfVG9rZW46RlZsaGJrblpFb2Y0dEd4VkVCVGNzbDJTbnVmXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

### 6、程序构建 jar 包

#### 环境准备

首先需要在本地（或服务器）安装Maven并配置环境变量，参考教程：

[Window10配置Maven详细教程_windows maven-CSDN博客](https://blog.csdn.net/qq_45344586/article/details/130935169)

安装完成后在终端执行`mvn -v`命令，检测是否安装成功，鱼皮本地的环境是Maven 3.9.5，我的是Maven 3.8.8

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NmFhODI3NmZjYjk2Y2IyNmM4YTM4YWIwNDY4NzE3MThfMk9weGFvemY0MXJDMWFPVWpCSnN1aGE3eHZ6SG56WGZfVG9rZW46QlpLZGJOQXNGb1owME94cFB2VWNVVHF2bk5oXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

#### 开发实现

1.  在`maker.generator`目录下新建`JarGenerator.java`类，编写**jar包构建**逻辑. 注意：不同的操作系统，执行Maven打包的命令代码不同

```Java
package com.manneia.maker.generator;

import java.io.*;

/**
 * 程序构建jar包
 *
 * @author lkx
 */
public class JarGenerator {

    public static void doGenerate(String projectDir) throws IOException, InterruptedException {
        // 调用Process类,执行命令
        // 清理之前的构建并打包
        String winMavenCommand = "mvn.cmd clean package -DskipTests=true";
        String otherMavenCommand = "mvn clean package -DskipTests=true";
        // 注意不同操作系统，执行的命令不同，默认Windows系统

        ProcessBuilder processBuilder = new ProcessBuilder(winMavenCommand.split(" "));
        processBuilder.directory(new File(projectDir));

        Process process = processBuilder.start();

        InputStream inputStream = process.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        String line;
        while ((line = bufferedReader.readLine()) != null) {
            System.out.println(line);
        }
        int exitCode = process.waitFor();
        if (exitCode != 0) {
            System.out.println("命令执行结束");
            throw new RuntimeException("生成jar包失败");
        } else {
            System.out.println("生成jar包成功");
        }
    }

    public static void main(String[] args) throws Exception {
        doGenerate("D:\\Project\\project\\manneia-generator\\manneia-generator-basic");
    }
}
```

### 7、程序封装脚本

#### 开发实现

在`maker.generator`目录下新建`ScriptGenerator.java`类，编写**脚本文件生成**逻辑

首先将生成逻辑封装在一个doGenerate方法里，方法需传入jar包路径（jarPath），因为不同的元信息构建出来的jar包名称和路径是不同的

脚本文件用StringBuilder拼接字符串，再写入文件

注意：如果不是Windows系统，还需要在生成文件后，使用`PosixFilePermissions`类给文件默认添加可执行权限

```Java
package com.manneia.maker.generator;

import cn.hutool.core.io.FileUtil;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.attribute.PosixFilePermission;
import java.nio.file.attribute.PosixFilePermissions;
import java.util.Set;

/**
 * 脚本生成器
 *
 * @author lkx
 */
public class ScriptGenerator {

    public static void doGenerate(String outputPath, String jarPath) {
        // Linux 脚本
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("#!/bin/bash").append("\n");
        stringBuilder.append(String.format("java -jar %s \"$@\"", jarPath)).append("\n");
        FileUtil.writeBytes(stringBuilder.toString().getBytes(StandardCharsets.UTF_8), outputPath);
        // 添加可执行权限
        try {
            Set<PosixFilePermission> permissions = PosixFilePermissions.fromString("rwxrwxrwx");
            Files.setPosixFilePermissions(Paths.get(outputPath), permissions);
        } catch (Exception e) {
        }
        // Windows 脚本
        stringBuilder = new StringBuilder();
        stringBuilder.append("@echo off").append("\n");
        stringBuilder.append(String.format("java -Dfile.encoding=utf-8 -jar %s %%*", jarPath)).append("\n");
        FileUtil.writeBytes(stringBuilder.toString().getBytes(StandardCharsets.UTF_8), outputPath
                + ".bat");
    }
}
```

#### 调用测试

```Java
public class MainGenerator {

    public static void main(String[] args) throws TemplateException, IOException, InterruptedException {
        
        ...
        
        // 封装脚本
        String shellOutputFilePath = outputPath + File.separator + "generator";
        String jarName = String.format("%s-%s-jar-with-dependencies.jar", meta.getName(), meta.getVersion());
        String jarPath = "target/" + jarName;
        ScriptGenerator.doGenerate(shellOutputFilePath, jarPath);
    }
}
```

## 四、代码生成器制作工具优化

1.  ### 可移植性

#### 什么是可移植性?

现在的制作工具存在一个很严重的问题，由于生成代码所依赖的原始模板文件并没有打包到生成的代码生成器项目中，导致我们把代码生成器脚本分享给别人、或者换一个电脑就无法使用了。

如下图，`MainGenerator`生成代码时依赖的inputRootPath(模板文件路径)是固定的：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=OTA0MzJmNzQwY2QxMDk5YzJmYTQzY2M3ZWNjZDhkZjRfVWpaYk9LQlloTXhvZXdCWDVTNTNFRDBhZTRnektMQlhfVG9rZW46Qk9wamJ1MHYzb3BxYk94RHJ0VWNTb0dGbldnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

用一个专业术语总结，现在的程序不具备可移植性。

一般来说，程序的可移植性是指程序在不同计算机、操作系统或编程语言环境下能够正确运行的能力。具有良好可移植性的程序能够在不同的环境中轻松运行，而不需要大量的修改或适应工作。

对应到咱们的项目，可移植性是指能够上程序在不同的计算机上正常运行，而不需要再人工复制项目模板文件和调整路径。

实现可移植性是至关重要的，有利于代码生成器的分享，并且为了以后将平台线上化做好准备。

#### 实现方式

如何实现可移植性呢？

其实很简单，核心思路是"把绝对路径改为相对路径”。只需要把代码生成器依赖的模板文件移动到生成后的代码生成器目录下，比如.source/项目名；然后在生成器中，就可以通过相对路径找到模板文件了。

之前的元信息中，我们已经定义了`fileConfig.inputRootPath`,用于控制实际生成时的模板文件路径。那么现在我们可以新增`fileConfig.sourceRootPath`字段，表示模板文件所在的原始路径（相当于之前的`fileConfig.inputRootPath`)。然后将`fileConfig.inputRootPath`改为相对路径，这样就不用修改生成器的代码了。

修改后的元信息文件如下：

```JSON
"fileConfig": {
    "inputRootPath": ".source/acm-template-pro",
    "sourceRootPath": "D:/Project/project/manneia-generator/manneia-generator-demo-projects/acm-template-pro",
    "outputRootPath": "generated",
    "type": "dir"
}
```

需要同步修改`Meta.java`实体类,增加`sourceRootPath`字段

```Java
@NoArgsConstructor
@Data
public static class FileConfig {
    private String inputRootPath;
    private String sourceRootPath;
    private String outputRootPath;
    private String type;
    private List<FileInfo> files;

    @NoArgsConstructor
    @Data
    public static class FileInfo {
        private String inputPath;
        private String outputPath;
        private String type;
        private String generateType;
    }
}
```

然后在`MainGenerator`中增加复制原始模板文件的逻辑,放到所有生成代码操作之前(即 "读取resources"目录前).

修改代码如下: 

```Java
// 从原始模板文件路径复制到生成的代码包中
String sourceRootPath = meta.getFileConfig().getSourceRootPath();
String sourceCopyDestPath = outputPath + File.separator + ".source";
FileUtil.copy(sourceRootPath, sourceCopyDestPath, true);
```

然后执行测试，成功在生成的项目中复制了原始模板文件：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzc3NWRjNjI4YzljMjI5MDBiYTQ4ZmRmNzNlZjcyYTlfeWppWXdqOTVMT0dSamJDY3ZGOHN0ZlFSRFlEcFU1VDdfVG9rZW46SG4zU2IxSU1Qb0dwTUl4eVYzbGNIWEc0bjhkXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

1.  ### 功能优化

#### 1、增加项目介绍文件

标准规范的开源项目一般都会在根目录下编写一个`README.md`项目介绍文件，可以帮助用户快速了解整个项目的背景、价值、用法、参与方式等

我们也需要让**制作工具**为`代码生成器`编写一个项目介绍文件 （README.md 还可以加上作者的水印，为项目引流）

实现方式和之前类似，读取元信息并使用 FreeMarker 动态生成即可

在`resources/templates`目录下新建 `README.md.ftl`模板文件，完整代码如下**（仅供参考）**：

~~~Java
# ${name}

> ${description}
>
> 作者：${author}
>
> 基于 [manneia] 的 [定制代码生成器项目](https://github.com/manneia/manneia-generator) 制作，感谢您的使用！

可以通过命令行交互式输入的方式动态生成想要的项目代码

## 使用说明

执行项目根目录下的脚本文件：

```
generator <命令> <选项参数>
```

示例命令：

```
generator generate <#list modelConfig.models as modelInfo>-${modelInfo.abbr} </#list>
```

## 参数说明

<#list modelConfig.models as modelInfo>
${modelInfo?index + 1}）${modelInfo.fieldName}

类型：${modelInfo.type}

描述：${modelInfo.description}

默认值：${modelInfo.defaultValue?c}

缩写： -${modelInfo.abbr}


</#list>
~~~

#### 2、制作精简版代码生成器

在 `MainGenerator.java` 中新增**生成精简版项目**的逻辑，放在之前代码的末尾

```Java
// 生成精简版本的程序(产物包)
String distOutputPath = outputPath + "-dist";
// 拷贝jar包,
String targetAbsolutePath = distOutputPath + File.separator + "target";
FileUtil.mkdir(targetAbsolutePath);
String jarAbsolutePath = outputPath + File.separator + jarPath;
FileUtil.copy(jarAbsolutePath, targetAbsolutePath, true);
// 拷贝脚本文件,
FileUtil.copy(shellOutputFilePath, distOutputPath, true);
FileUtil.copy(shellOutputFilePath + ".bat", distOutputPath, true);
// 拷贝原始模板文件
FileUtil.copy(sourceCopyDestPath, distOutputPath, true);
```

#### **其他扩展思路**

可以根据元信息配置，让用户选择使用开启`Git版本控制功能`

实现思路：通过 Process 执行`git init`命令，并复制Java的`.gitignore`模板文件到代码生成器中

### 3、健壮性优化

#### **什么是健壮性？**

健壮性通常是指程序**在不同条件下**能否稳定运行。

一个健壮的程序能够在各种不同的用户输入和使用方式下，**保持正常运行**，并且正确处理异常情况，而不是整个程序崩溃或导致严重错误。

#### **健壮性优化策略**

常用的健壮性优化方式有：输入校验、异常处理、故障恢复（比如事务）、自动重试（比如网络请求、调用别人的API）、降级等

对于制作工具，影响代码生成结果的、也就是需要用户修改的核心内容是**元信息配置文件**，所以一定要对元信息进行校验，并且用默认值来填充空值，防止用户错误输入导致的异常，从而提高健壮性。

#### **元信息校验和默认值填充**

##### **规则梳理**

| 字段                            | 默认值                                              | 校验规则 |
| ------------------------------- | --------------------------------------------------- | -------- |
| name                            | my-generator                                        |          |
| description                     | 我的模板代码生成器                                  |          |
| basePackage                     | com.polaris                                         |          |
| version                         | 1                                                   |          |
| author                          | Polaris                                             |          |
| createTime                      | 当前日期                                            |          |
| fileConfig.sourceRootPath       |                                                     | 必填     |
| fileConfig.inputRootPath        | .source + sourceRootPath 的最后一个层级路径         |          |
| fileConfig.outputRootPath       | 当前路径下的 generated                              |          |
| fileConfig.type                 | dir                                                 |          |
| fileConfig.files.inputPath      |                                                     | 必填     |
| fileConfig.files.outputPath     | 等于 inputPath                                      |          |
| fileConfig.files.type           | inputPath 有文件后缀（如.java）为 file，否则为 dir  |          |
| fileConfig.files.generateType   | 如果文件结尾不为 .ftl，默认为static，否则为 dynamic |          |
| modelConfig.models.fieldName    |                                                     | 必填     |
| modelConfig.models.type         | String                                              |          |
| modelConfig.models.description  |                                                     |          |
| modelConfig.models.defaultValue |                                                     |          |
| modelConfig.models.abbr         |                                                     |          |

##### 自定义异常类

专门定义一个元信息异常类，便于后续集中处理由于元信息输入错误导致的异常

在 `maker.meta` 目录下新建 `MetaException.java` 文件

```Java
package com.manneia.maker.meta;

/**
 * 元信息异常
 *
 * @author lkx
 */
public class MetaException extends RuntimeException{

    /**
     * 异常处理
     *
     * @param message 异常信息
     */
    public MetaException(String message) {
        super(message);
    }

    /**
     * 异常处理
     *
     * @param message 异常信息
     * @param cause 异常原因
     */
    public MetaException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

##### 编写校验类

由于要检验很多字段、有不同的规则，所以新建一个独立的校验类，而不是把校验和填充默认值的代码一起放在初始化 `Meta` 对象的方法中

由于校验和填充默认值操作都要遍历元信息，所以直接用一个类同时完成这两个操作，简化开发

在 `maker.meta` 目录下新建 `MetaValidator.java` 文件，编写校验逻辑

```Java
package com.manneia.maker.meta;

import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.date.DateUtil;
import cn.hutool.core.io.FileUtil;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;

import java.nio.file.Paths;
import java.util.List;

/**
 * 元信息校验
 *
 * @author lkx
 */
public class MetaValidator {

    public static void doValidateAndFillDefaultValue(Meta meta) {
        // 基础信息校验
        validAndFillMetaRoot(meta);

        // 文件配置信息校验
        validAndFillMetaFileConfig(meta);

        // 模板配置信息校验
        validAndFillMetaModelConfig(meta);

    }

    private static void validAndFillMetaFileConfig(Meta meta) {
        // fileConfig 校验和默认值
        Meta.FileConfig fileConfig = meta.getFileConfig();

        if (fileConfig == null) {
            return;
        }
        // 必填
        String sourceRootPath = fileConfig.getSourceRootPath();
        // inputRootPath .source + sourceRootPath的最后一个层级目录
        String inputRootPath = fileConfig.getInputRootPath();
        // outputRootPath 默认为当前路径下的generated
        String outputRootPath = fileConfig.getOutputRootPath();
        // 文件类型
        String fileConfigType = fileConfig.getType();

        List<Meta.FileConfig.FileInfo> fileInfoList = fileConfig.getFiles();

        if (StrUtil.isBlank(sourceRootPath)) {
            throw new MetaException("未填写 sourceRootPath");
        }

        String defaultInputRootPath = StrUtil.emptyToDefault(inputRootPath, ".source/" +
                FileUtil.getLastPathEle(Paths.get(sourceRootPath)).getFileName().toString());
        meta.getFileConfig().setInputRootPath(defaultInputRootPath);

        String defaultOutputRootPath = StrUtil.emptyToDefault(outputRootPath, "generated");
        meta.getFileConfig().setOutputRootPath(defaultOutputRootPath);

        String defaultType = StrUtil.emptyToDefault(fileConfigType, "dir");
        meta.getFileConfig().setType(defaultType);

        if (CollUtil.isEmpty(fileInfoList)) {
            return;
        }
        fileInfoList.forEach(fileInfo -> {
            // 必填
            String inputPath = fileInfo.getInputPath();
            // outputPath 默认等于 inputPath
            String outputPath = fileInfo.getOutputPath();
            // type: inputPath 有文件后缀（如.java）为 file，否则为 dir
            String type = fileInfo.getType();
            // 如果文件结尾不为 .ftl，默认为static，否则为 dynamic
            String generateType = fileInfo.getGenerateType();

            if (StrUtil.isBlank(inputPath)) {
                throw new MetaException("未填写 inputPath");
            }
            String defaultOutputPath = StrUtil.emptyToDefault(outputPath, inputPath);
            fileInfo.setOutputPath(defaultOutputPath);
            // 无文件后缀则默认为 dir,否则为 file
            String defaultFileConfigType = StrUtil.blankToDefault(type,
                    StrUtil.isBlank(FileUtil.getSuffix(inputPath)) ? "dir" : "file");
            fileInfo.setType(defaultFileConfigType);
            // 无 ftl后缀,则默认为 static,否则为 dynamic
            String defaultGenerateType = StrUtil.blankToDefault(generateType,
                    inputPath.endsWith(".ftl") ? "dynamic" : "static");
            fileInfo.setGenerateType(defaultGenerateType);
        });
    }

    private static void validAndFillMetaModelConfig(Meta meta) {
        // modelConfig 校验和默认值
        Meta.ModelConfig modelConfig = meta.getModelConfig();
        if (modelConfig == null) {
            return;
        }
        List<Meta.ModelConfig.ModelInfo> modelInfoList = modelConfig.getModels();
        if (CollUtil.isEmpty(modelInfoList)) {
            return;
        }
        modelInfoList.forEach(modelInfo -> {
            String fieldName = modelInfo.getFieldName();
            String type = modelInfo.getType();
            if (StrUtil.isBlank(fieldName)) {
                throw new MetaException("未填写 filedName");
            }

            if (StrUtil.isBlankIfStr(type)) {
                modelInfo.setType("String");
            }
        });

    }

    /**
     * 基础信息校验和默认值
     *
     * @param meta 元信息
     */
    private static void validAndFillMetaRoot(Meta meta) {
        // 项目名称
        String name = StrUtil.blankToDefault(meta.getName(), "my-generator");
        // 项目描述
        String description = StrUtil.emptyToDefault(meta.getDescription(), "我的模板代码生成器");
        // 项目基础包名
        String basePackage = StrUtil.blankToDefault(meta.getBasePackage(), "com.manneia");
        // 项目版本
        String version = StrUtil.emptyToDefault(meta.getVersion(), "1.0");
        // 项目作者
        String author = StrUtil.emptyToDefault(meta.getAuthor(), "manneia");
        // 是否使用Git托管
        Boolean isGit = meta.getIsGit();
        // 项目创建时间
        String createTime = StrUtil.emptyToDefault(meta.getCreateTime(), DateUtil.now());
        if (BooleanUtil.isBoolean(isGit.getClass())) {
            isGit = true;
            meta.setIsGit(isGit);
        }

        meta.setName(name);
        meta.setDescription(description);
        meta.setBasePackage(basePackage);
        meta.setVersion(version);
        meta.setAuthor(author);
        meta.setCreateTime(createTime);
    }
}
```

##### 圈复杂度优化

上面的代码虽然能够运行，但是过于复杂了，所有的校验规则都写在一起，会导致圈复杂度过高

圈复杂度（Cyclomatic complexity）是一种用于评估代码复杂性的软件度量方法，代码的分支判断越多，圈复杂度越高，**一般情况下，代码圈复杂度建议<=10，不建议超过20！**

在 IDEA 中下载安装 `MetricsReloaded` 插件来检测代码圈复杂度

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MDEyNDc2YjZlYTA1NDFkZGI4YjJiMTA3NTk3MjY0YTZfMlhQR1Jhc25VeU5jQlNQTEhPbmRrZUoycFVWNkJ5Y1NfVG9rZW46U3R5QWI3bjBVb3ZLeEJ4d3dQa2NEUWExbmliXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

右键点击`MetaValidator`=> `Analyze`=> `Calculate Metrics...`，选择默认的 `Complexity metrics`，即可查看圈复杂度 CogC

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTViYjhkYWI2YzI5ZGM2ODVhZjBmNWZlYTQ2YTBjYzBfVkczZGIxVXZZek9haElpMGtvZDhaek9XUDdyMmZMaUtfVG9rZW46QVFlNGJoSmVGb1puV294S3owcGN4WDlmblFkXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

发现圈复杂度过高

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MjhiNzI1Y2M1OTAyZDgwMzg4ZjQ3OGIwZWJmMjZiNzhfYW5hVURzaDgyRlNGbkRBbUFiNmYzc1lGOGJnZEhWS3VfVG9rZW46UktsY2JFTkxkbzlmd0p4a2EycWNZQTNEbmZiXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

优化方法:

-    抽取方法 我们可以按照元信息配置的层级，将整段代码抽为3个方法：基础元信息校验、fileConfig校验、modelConfig校验。

```Java
public static void doValidAndFill(Meta meta) {
    validAndFillMetaRoot(meta);
    validAndFillFileConfig(meta);
    validAndFillModelConfig(meta);
}
```

-    在抽取方法中使用**卫语句** 在进入主要逻辑之前添加的条件检查语句，以确保程序**在执行主要逻辑之前**提前满足某些条件，这种技术有助于提高代码的可读性和可维护性 在 IDEA 中，在`if`语句代码上使用快捷键`Alt + Enter`，使用 Invert if 选项快速反转 if 条件
-    使用工具类减少判断代码 比如基础元信息的校验中，使用 Hutool 的 `StrUtil.blankToDefault`代替 `if (StrUtil.isBlank(xxx))`

```Java
String name = StrUtil.blankToDefault(meta.getName(),"my-generator");
meta.setName(name);
```

在初始化对象时，调用校验方法，修改后的 `MetaManager` 代码如下:

```Java
private static Meta initMeta() {
    String metaJson = ResourceUtil.readUtf8Str("meta.json");
    Meta newMeta = JSONUtil.toBean(metaJson, Meta.class);
    // 校验配置文件，处理默认值
    MetaValidator.doValidAndFill(newMeta);
    return newMeta;
}
```

### 可扩展性优化

#### **什么是可扩展性？**

可扩展性是指程序在不修改结构或代码的情况下，能够灵活地添加新的功能，并适应新的需求和项目变化。

可做以下细分：

-   功能可扩展性
-   性能可扩展性
-   资源可扩展性
-   ……

#### **1、枚举值定义**

在元信息中的字段定义枚举值，代替程序中的魔法值，使得代码更规范、更好理解、更利于维护和扩展

新建 `meta.enums` 包，用于存放元信息相关的枚举类

1.   文件类型枚举类 

```Java
package com.manneia.maker.meta.enums;

import lombok.Getter;

/**
 * 文件类型枚举
 *
 * @author lkx
 */
@Getter
public enum FileTypeEnum {
    DIR("目录", "dir"),
    FILE("文件", "file");

    private final String text;

    private final String value;

    FileTypeEnum(String text, String value) {
        this.text = text;
        this.value = value;
    }

}
```

1.  文件生成类型枚举类 

```Java
package com.manneia.maker.meta.enums;

import lombok.Getter;

/**
 * 文件生成方式类型枚举
 *
 * @author lkx
 */
@Getter
public enum FileGenerateTypeEnum {
    DYNAMIC("动态", "dynamic"),
    STATIC("静态", "static");

    private final String text;

    private final String value;

    FileGenerateTypeEnum(String text, String value) {
        this.text = text;
        this.value = value;
    }

}
```

1.  模型类型枚举类

```Java
package com.manneia.maker.meta.enums;

import lombok.Getter;

/**
 * 模型类型枚举
 *
 * @author lkx
 */
@Getter
public enum ModelTypeEnum {
    MODEL_STRING("动态", "String"),
    MODEL_BOOLEAN("静态", "boolean");

    private final String text;

    private final String value;

    ModelTypeEnum(String text, String value) {
        this.text = text;
        this.value = value;
    }

}
```

有了枚举值以后，就可以把 `MetaValidator` 中的默认值改为读取枚举值的 `value`

```Java
package com.manneia.maker.meta;

import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.date.DateUtil;
import cn.hutool.core.io.FileUtil;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import com.manneia.maker.meta.enums.FileGenerateTypeEnum;
import com.manneia.maker.meta.enums.FileTypeEnum;
import com.manneia.maker.meta.enums.ModelTypeEnum;

import java.nio.file.Paths;
import java.util.List;

/**
 * 元信息校验
 *
 * @author lkx
 */
public class MetaValidator {

    public static void doValidateAndFillDefaultValue(Meta meta) {
        // 基础信息校验
        validAndFillMetaRoot(meta);

        // 文件配置信息校验
        validAndFillMetaFileConfig(meta);

        // 模板配置信息校验
        validAndFillMetaModelConfig(meta);

    }

    private static void validAndFillMetaFileConfig(Meta meta) {
        // fileConfig 校验和默认值
        Meta.FileConfig fileConfig = meta.getFileConfig();

        if (fileConfig == null) {
            return;
        }
        // 必填
        String sourceRootPath = fileConfig.getSourceRootPath();
        // inputRootPath .source + sourceRootPath的最后一个层级目录
        String inputRootPath = fileConfig.getInputRootPath();
        // outputRootPath 默认为当前路径下的generated
        String outputRootPath = fileConfig.getOutputRootPath();
        // 文件类型
        String fileConfigType = fileConfig.getType();

        List<Meta.FileConfig.FileInfo> fileInfoList = fileConfig.getFiles();

        if (StrUtil.isBlank(sourceRootPath)) {
            throw new MetaException("未填写 sourceRootPath");
        }

        String defaultInputRootPath = StrUtil.emptyToDefault(inputRootPath, ".source/" +
                FileUtil.getLastPathEle(Paths.get(sourceRootPath)).getFileName().toString());
        meta.getFileConfig().setInputRootPath(defaultInputRootPath);

        String defaultOutputRootPath = StrUtil.emptyToDefault(outputRootPath, "generated");
        meta.getFileConfig().setOutputRootPath(defaultOutputRootPath);

        String defaultType = StrUtil.emptyToDefault(fileConfigType, FileTypeEnum.DIR.getValue()); // 这里
        meta.getFileConfig().setType(defaultType);

        if (CollUtil.isEmpty(fileInfoList)) {
            return;
        }
        fileInfoList.forEach(fileInfo -> {
            // 必填
            String inputPath = fileInfo.getInputPath();
            // outputPath 默认等于 inputPath
            String outputPath = fileInfo.getOutputPath();
            // type: inputPath 有文件后缀（如.java）为 file，否则为 dir
            String type = fileInfo.getType();
            // 如果文件结尾不为 .ftl，默认为static，否则为 dynamic
            String generateType = fileInfo.getGenerateType();

            if (StrUtil.isBlank(inputPath)) {
                throw new MetaException("未填写 inputPath");
            }
            String defaultOutputPath = StrUtil.emptyToDefault(outputPath, inputPath);
            fileInfo.setOutputPath(defaultOutputPath);
            // 无文件后缀则默认为 dir,否则为 file     
            String defaultFileConfigType = StrUtil.blankToDefault(type,
                    StrUtil.isBlank(FileUtil.getSuffix(inputPath)) ?
                            FileTypeEnum.DIR.getValue() : // 这里
                            FileTypeEnum.FILE.getValue()); // 这里
            fileInfo.setType(defaultFileConfigType);
            // 无 ftl后缀,则默认为 static,否则为 dynamic
            String defaultGenerateType = StrUtil.blankToDefault(generateType,
                    inputPath.endsWith(".ftl") ?
                            FileGenerateTypeEnum.DYNAMIC.getValue() :// 这里
                            FileGenerateTypeEnum.STATIC.getValue()); // 这里
            fileInfo.setGenerateType(defaultGenerateType);
        });
    }

    private static void validAndFillMetaModelConfig(Meta meta) {
        // modelConfig 校验和默认值
        Meta.ModelConfig modelConfig = meta.getModelConfig();
        if (modelConfig == null) {
            return;
        }
        List<Meta.ModelConfig.ModelInfo> modelInfoList = modelConfig.getModels();
        if (CollUtil.isEmpty(modelInfoList)) {
            return;
        }
        modelInfoList.forEach(modelInfo -> {
            String fieldName = modelInfo.getFieldName();
            String type = modelInfo.getType();
            if (StrUtil.isBlank(fieldName)) {
                throw new MetaException("未填写 filedName");
            }

            if (StrUtil.isBlankIfStr(type)) {
                modelInfo.setType(ModelTypeEnum.MODEL_STRING.getValue()); // 这里
            }
        });

    }

    /**
     * 基础信息校验和默认值
     *
     * @param meta 元信息
     */
    private static void validAndFillMetaRoot(Meta meta) {
        // 项目名称
        String name = StrUtil.blankToDefault(meta.getName(), "my-generator");
        // 项目描述
        String description = StrUtil.emptyToDefault(meta.getDescription(), "我的模板代码生成器");
        // 项目基础包名
        String basePackage = StrUtil.blankToDefault(meta.getBasePackage(), "com.manneia");
        // 项目版本
        String version = StrUtil.emptyToDefault(meta.getVersion(), "1.0");
        // 项目作者
        String author = StrUtil.emptyToDefault(meta.getAuthor(), "manneia");
        // 是否使用Git托管
        Boolean isGit = meta.getIsGit();
        // 项目创建时间
        String createTime = StrUtil.emptyToDefault(meta.getCreateTime(), DateUtil.now());
        if (BooleanUtil.isBoolean(isGit.getClass())) {
            isGit = true;
            meta.setIsGit(isGit);
        }

        meta.setName(name);
        meta.setDescription(description);
        meta.setBasePackage(basePackage);
        meta.setVersion(version);
        meta.setAuthor(author);
        meta.setCreateTime(createTime);
    }
}
```

#### 模板方法模式⭐

除了前面提到的检验类，项目中还有一个实现流程比较复杂的文件 ——`MainGenerator`，这个文件的作用就是读取元信息，然后根据流程生成不同的代码或者执行不同的操作

之前把所有的流程都写在了 main 方法里，大概 130 行代码：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MjIxMjVkNzg3NTcwOTkxMzcxYTQyODJjNDg4Yjg1Y2FfMEhiU0xCQlBFQkpBSHhEZTdMNE56cGYwZ0d4TEQ0aW5fVG9rZW46R2dObmJYWHR5b3JEWDd4U0tndWM1SHNpbmJiXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

-   对于不熟悉这个项目的开发者来说代码读起来会非常费力
-   如果后续要新增新的流程或者根据元信息指定不同的生成方式***（VIP定制）**，会比较麻烦

**优化 ——> 模板方法设计模式**

**什么是模板方法模式？**

模板方法模式通过父类定义了一套算法的标准执行流程，然后由子类具体实现每个流程的操作，使得子类在不改变流程结构的情况下，可以自主定义某些步骤的实现

比如**模板中**要求每人每天必须做三件事：

1.  吃饭
2.  睡觉
3.  支持鱼皮

那么不同的人都必须遵循这个流程，但是可以有不同的做法

比如**小王**可以：

1.  吃方便面
2.  站着睡觉
3.  给鱼皮三连

换成**小李**可以：

1.  吃馒头
2.  躺着睡觉
3.  给鱼皮点赞

这样可以规范子类的行为，使其复用**父类现成的执行流程**，也可以通过创建新的子类来自主定义**每一步的具体操作**，提高了程序的可扩展性

##### 实现过程

1.   流程梳理 当前的 `MainGenerator` 程序流程如下： 
    1.  复制原始文件
    2.  代码生成
    3.  构建 jar 包
    4.  封装脚本
    5.  生成精简版的程序
2.   新建父类，定义生成器程序的流程 在 `maker.generator.main` 包下新建 `GenerateTemplate` 抽象类，把原先 `MainGenerator`中的 main 方法 复制过来，改为 `doGenerate` 方法 

```Java
public abstract class GenerateTemplate {

    public void doGenerate() throws TemplateException, IOException, InterruptedException {
        Meta meta = MetaManager.getMetaObject();
        System.out.println(meta);

        // 之前的代码
        ...
    }
}
```

1.   抽取方法 在 `doGenerate` 方法中，将每一个步骤都单独抽取为一个独立的方法确保每个方法的**修饰符**为 `protected`，而且不能为 `static`，使得这些方法可以被子类重写抽取之后的示例代码如下，可以看到 `doGenerate` 方法中的代码**被大大简化**，主流程更加清晰 

```Java
package com.manneia.maker.generator.main;

import cn.hutool.core.io.FileUtil;
import cn.hutool.core.io.resource.ClassPathResource;
import cn.hutool.core.util.StrUtil;
import com.manneia.maker.GitGenerator;
import com.manneia.maker.generator.JarGenerator;
import com.manneia.maker.generator.ScriptGenerator;
import com.manneia.maker.generator.file.DynamicFileGenerator;
import com.manneia.maker.generator.file.StaticFileGenerator;
import com.manneia.maker.generator.utils.Utils;
import com.manneia.maker.meta.Meta;
import com.manneia.maker.meta.MetaManager;
import freemarker.template.TemplateException;

import java.io.File;
import java.io.IOException;

/**
 * @author lkx
 */
public class GenerateTemplate {

    public static void doGenerate() throws TemplateException, IOException, InterruptedException {
        Meta meta = MetaManager.getMetaObject();
        // 输出的根路径
        String projectPath = Utils.getRootProperty();
        String outputPath = projectPath + File.separator + "generated" +
                File.separator + meta.getName();
        if (FileUtil.exist(outputPath)) {
            FileUtil.mkdir(outputPath);
        }

        // 1. 复制原始文件
        String sourceCopyDestPath = copySource(meta, outputPath);

        // 2. 代码生成
        generateCode(meta, outputPath);

        // 3. 构建jar包
        buildJar(outputPath);

        // 4. 封装脚本
        Result result = buildScript(outputPath, meta);

        // 5. 生成精简版本的程序(产物包)
        buildDist(outputPath, result, sourceCopyDestPath);
    }

    private static void buildDist(String outputPath, Result result, String sourceCopyDestPath) {
        String distOutputPath = outputPath + "-dist";
        // 拷贝jar包,
        String targetAbsolutePath = distOutputPath + File.separator + "target";
        FileUtil.mkdir(targetAbsolutePath);
        String jarAbsolutePath = outputPath + File.separator + result.jarPath;
        FileUtil.copy(jarAbsolutePath, targetAbsolutePath, true);
        // 拷贝脚本文件,
        FileUtil.copy(result.shellOutputFilePath, distOutputPath, true);
        FileUtil.copy(result.shellOutputFilePath + ".bat", distOutputPath, true);
        // 拷贝原始模板文件
        FileUtil.copy(sourceCopyDestPath, distOutputPath, true);
    }

    private static Result buildScript(String outputPath, Meta meta) {
        String shellOutputFilePath = outputPath + File.separator + "generator";
        String jarName = String.format("%s-%s-jar-with-dependencies.jar",
                meta.getName(), meta.getVersion());
        String jarPath = "target/" + jarName;
        ScriptGenerator.doGenerate(shellOutputFilePath, jarPath);
        return new Result(shellOutputFilePath, jarPath);
    }

    private static class Result {
        public final String shellOutputFilePath;
        public final String jarPath;

        public Result(String shellOutputFilePath, String jarPath) {
            this.shellOutputFilePath = shellOutputFilePath;
            this.jarPath = jarPath;
        }
    }

    private static void buildJar(String outputPath) throws IOException, InterruptedException {
        JarGenerator.doGenerate(outputPath);
    }

    private static void generateCode(Meta meta, String outputPath) throws IOException, TemplateException, InterruptedException {
        // 读取resources 目录
        ClassPathResource classPathResource = new ClassPathResource("");
        String resourceAbsolutePath = classPathResource.getAbsolutePath();

        // java包的基础路径
        // com.manneia
        String outputBasePackage = meta.getBasePackage();
        // com/manneia
        String outputBasePackagePath = StrUtil.join("/", StrUtil.split(outputBasePackage,
                "."));
        // generated/src/main/java/com/manneia/xxx
        String outputBaseJavaPackagePath = outputPath + File.separator + "src/main/java/" +
                outputBasePackagePath;

        String inputFilePath;
        String outputFilePath;

        // model.DataModel
        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/model/DataModel.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "model/DataModel.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // cli.command.GenerateCommand
        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/cli/command/GenerateCommand.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator +
                "cli/command/GenerateCommand.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // cli.command.ListCommand
        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/cli/command/ListCommand.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "cli/command/ListCommand.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // cli.command.ConfigCommand
        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/cli/command/ConfigCommand.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "cli/command/ConfigCommand.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // cli.commandExecutor
        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/cli/CommandExecutor.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "cli/CommandExecutor.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);
        // Main
        inputFilePath = resourceAbsolutePath + File.separator + "templates/java/Main.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "/Main.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/generator/StaticGenerator.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + "/generator/StaticGenerator.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // generator.DynamicFileGenerator
        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/generator/DynamicGenerator.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + "/generator/DynamicGenerator.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // generator.MainGenerator
        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/generator/MainGenerator.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + "/generator/MainGenerator.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // pom.xml
        inputFilePath = resourceAbsolutePath + File.separator + "templates/pom.xml.ftl";
        outputFilePath = outputPath + File.separator + "pom.xml";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        inputFilePath = resourceAbsolutePath + File.separator + "templates/README.md.ftl";
        outputFilePath = outputPath + File.separator + "README.md";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        if (meta.getIsGit()) {
            GitGenerator.doGenerate(outputPath);
            inputFilePath = resourceAbsolutePath + File.separator + "templates/.gitignore.ftl";
            outputFilePath = outputPath + File.separator + ".gitignore";
            StaticFileGenerator.copyFilesByHuTool(inputFilePath, outputFilePath);
        }
    }

    private static String copySource(Meta meta, String outputPath) {
        // 从原始模板文件路径复制到生成的代码包中
        String sourceRootPath = meta.getFileConfig().getSourceRootPath();
        String sourceCopyDestPath = outputPath + File.separator + ".source";
        FileUtil.copy(sourceRootPath, sourceCopyDestPath, true);
        return sourceCopyDestPath;
    }
}
```

1.   编写模板方法的具体实现子类

`MainGenerator` 继承模板类，通过方法覆写实现不同的行为，比如覆写 `buildDist` 方法，不再生成精简版程序 

```Java
package com.manneia.maker.generator.main;

import freemarker.template.TemplateException;

import java.io.IOException;

/**
 * @author lkx
 */
public class MainGenerator extends GenerateTemplate{
    @Override
    protected void buildDist(String outputPath, String sourceCopyDestPath, String shellOutputFilePath, String jarPath) {
        System.out.println("不需要了");
    }
}
```

1.  调用生成器

```Java
package com.polaris.maker;


import com.polaris.maker.generator.main.MainGenerator;
import freemarker.template.TemplateException;

import java.io.IOException;

/**
 * @author lkx
 */
public class Main {

    public static void main(String[] args) throws TemplateException, IOException, InterruptedException {
        MainGenerator mainGenerator = new MainGenerator();
        mainGenerator.doGenerate();
    }
}
```

**完整代码**

```Java
package com.manneia.maker.generator.main;

import cn.hutool.core.io.FileUtil;
import cn.hutool.core.io.resource.ClassPathResource;
import cn.hutool.core.util.StrUtil;
import com.manneia.maker.GitGenerator;
import com.manneia.maker.generator.JarGenerator;
import com.manneia.maker.generator.ScriptGenerator;
import com.manneia.maker.generator.file.DynamicFileGenerator;
import com.manneia.maker.generator.file.StaticFileGenerator;
import com.manneia.maker.generator.utils.Utils;
import com.manneia.maker.meta.Meta;
import com.manneia.maker.meta.MetaManager;
import freemarker.template.TemplateException;

import java.io.File;
import java.io.IOException;

/**
 * @author lkx
 */
public class GenerateTemplate {

    public void doGenerate() throws TemplateException, IOException, InterruptedException {
        Meta meta = MetaManager.getMetaObject();
        // 输出的根路径
        String projectPath = Utils.getRootProperty();
        System.out.println(projectPath);
        String outputPath = projectPath + File.separator + "generated" +
                File.separator + meta.getName();
        if (FileUtil.exist(outputPath)) {
            FileUtil.mkdir(outputPath);
        }

        // 1. 复制原始文件
        String sourceCopyDestPath = copySource(meta, outputPath);

        // 2. 代码生成
        generateCode(meta, outputPath);

        // 3. 构建jar包
        String jarPath = buildJar(outputPath, meta);

        // 4. 封装脚本
        String shellOutputFilePath = buildScript(outputPath, jarPath);

        // 5. 生成精简版本的程序(产物包)
        buildDist(outputPath, shellOutputFilePath, sourceCopyDestPath, jarPath);
    }

    /**
     * 复制原始模板文件
     *
     * @param meta       元信息对象
     * @param outputPath 输出路径
     * @return 返回原始模板文件的路径
     */
    protected String copySource(Meta meta, String outputPath) {
        // 从原始模板文件路径复制到生成的代码包中
        String sourceRootPath = meta.getFileConfig().getSourceRootPath();
        String sourceCopyDestPath = outputPath + File.separator + ".source";
        FileUtil.copy(sourceRootPath, sourceCopyDestPath, true);
        return sourceCopyDestPath;
    }

    /**
     * 代码生成
     *
     * @param meta       元信息对象
     * @param outputPath 输出路径
     * @throws IOException          IO流异常
     * @throws TemplateException    模板异常
     * @throws InterruptedException 线程异常
     */
    protected void generateCode(Meta meta, String outputPath) throws IOException, TemplateException, InterruptedException {
        // 读取resources 目录
        ClassPathResource classPathResource = new ClassPathResource("");
        String resourceAbsolutePath = classPathResource.getAbsolutePath();

        // java包的基础路径
        // com.manneia
        String outputBasePackage = meta.getBasePackage();
        // com/manneia
        String outputBasePackagePath = StrUtil.join("/", StrUtil.split(outputBasePackage,
                "."));
        // generated/src/main/java/com/manneia/xxx
        String outputBaseJavaPackagePath = outputPath + File.separator + "src/main/java/" +
                outputBasePackagePath;

        String inputFilePath;
        String outputFilePath;

        // model.DataModel
        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/model/DataModel.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "model/DataModel.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // cli.command.GenerateCommand
        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/cli/command/GenerateCommand.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator +
                "cli/command/GenerateCommand.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // cli.command.ListCommand
        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/cli/command/ListCommand.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "cli/command/ListCommand.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // cli.command.ConfigCommand
        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/cli/command/ConfigCommand.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "cli/command/ConfigCommand.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // cli.commandExecutor
        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/cli/CommandExecutor.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "cli/CommandExecutor.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);
        // Main
        inputFilePath = resourceAbsolutePath + File.separator + "templates/java/Main.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + File.separator + "/Main.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/generator/StaticGenerator.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + "/generator/StaticGenerator.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // generator.DynamicFileGenerator
        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/generator/DynamicGenerator.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + "/generator/DynamicGenerator.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // generator.MainGenerator
        inputFilePath = resourceAbsolutePath + File.separator +
                "templates/java/generator/MainGenerator.java.ftl";
        outputFilePath = outputBaseJavaPackagePath + "/generator/MainGenerator.java";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        // pom.xml
        inputFilePath = resourceAbsolutePath + File.separator + "templates/pom.xml.ftl";
        outputFilePath = outputPath + File.separator + "pom.xml";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        inputFilePath = resourceAbsolutePath + File.separator + "templates/README.md.ftl";
        outputFilePath = outputPath + File.separator + "README.md";
        DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);

        if (meta.getIsGit()) {
            GitGenerator.doGenerate(outputPath);
            inputFilePath = resourceAbsolutePath + File.separator + "templates/.gitignore.ftl";
            outputFilePath = outputPath + File.separator + ".gitignore";
            StaticFileGenerator.copyFilesByHuTool(inputFilePath, outputFilePath);
        }
    }

    /**
     * 构建jar包
     *
     * @param outputPath 输出路径
     * @param meta       元信息对象
     * @return 返回jar包路径
     * @throws IOException          IO流异常
     * @throws InterruptedException 线程异常
     */
    protected String buildJar(String outputPath, Meta meta) throws IOException, InterruptedException {
        JarGenerator.doGenerate(outputPath);
        String jarName = String.format("%s-%s-jar-with-dependencies.jar",
                meta.getName(), meta.getVersion());
        return "target/" + jarName;
    }

    /**
     * 封装脚本
     *
     * @param outputPath 输出路径
     * @param jarPath    jar包路径
     * @return 返回shell脚本路径
     */
    protected String buildScript(String outputPath, String jarPath) {
        String shellOutputFilePath = outputPath + File.separator + "generator";
        ScriptGenerator.doGenerate(shellOutputFilePath, jarPath);
        return shellOutputFilePath;
    }

    /**
     * 构建dist精简版代码
     *
     * @param outputPath          输出路径
     * @param sourceCopyDestPath  原始模板复制到的路径
     * @param shellOutputFilePath shell脚本路径
     * @param jarPath             jar包路径
     */
    protected void buildDist(String outputPath, String sourceCopyDestPath, String shellOutputFilePath, String jarPath) {
        String distOutputPath = outputPath + "-dist";
        // 拷贝jar包,
        String targetAbsolutePath = distOutputPath + File.separator + "target";
        FileUtil.mkdir(targetAbsolutePath);
        String jarAbsolutePath = outputPath + File.separator + jarPath;
        FileUtil.copy(jarAbsolutePath, targetAbsolutePath, true);
        // 拷贝脚本文件,
        FileUtil.copy(shellOutputFilePath, distOutputPath, true);
        FileUtil.copy(shellOutputFilePath + ".bat", distOutputPath, true);
        // 拷贝原始模板文件
        FileUtil.copy(sourceCopyDestPath, distOutputPath, true);
    }
}
```

之后，如果我们要根据元信息配置指定不同的生成规则，只需要覆写某个步骤的方法，或者新增具体的实现子类，就可以在不修改模板类代码的基础上，实现灵活的扩展了

### **总结**

本期从可移植性、功能完善、健壮性、可扩展性等多个维度对制作工具项目进行了优化，重点掌握**圈复杂度优化**和**模板方法模式**

今后，能将本期学到的优化思维和优化方法**（软实力）**自主运用到开发过程中，能保证功能尽量不出问题、没有Bug！😍

## 五、配置能力增强

### 1、需求分析

还记得我们第二阶段的目标么？通过制作工具得到一个Spring Boot项目模板代码生成器，能够让开发者快速定

制生成自己的Spring Boot项目。

接下来，先给大家介绍一下预期生成的Spring Boot项目模板代码。

将准备好的 Spring Boot 项目模板代码解压,放到 `manneia-generator-demo-projects`目录下.

#### **模板能力、项目文件**

在项目的`README.md`里可以看到关于该项目的介绍,比如应用的技术,业务特性等

模板拥有的能力如下：

1)实现了用户登绿、注册、注销、更新、检索、权限管理口

2)帖子创建、删除、编辑、更新、数据库检索、S灵活检索

3)使用了MySQL、Redis、Elasticsearch数据存储

4)使用Swagger+Knife4jD实现接口文档生成

5)支持全局跨域处理

#### **生成器应具备的能力**

1.  替换生成的代码包名
2.  控制是否生成帖子相关功能
3.  控制是否需要开启跨域
4.  自定义Knife4jConfig接口文档配置
5.  自定义MySQL配置信息
6.  控制是否开启Redis
7.  控制是否开启Elasticsearch

### **2、实现思路**

以上Spring Boot模板项目只是一个例子，我们的目标是通过这个示例，从特定需求中抽象出制作工具应具备的

通用能力。

上我们依次分析上述功能的实现思路，并挖掘出通用能力。

#### 依次分析

1)需求：替换生成的代码包名

实现思路：和之前替换包名的实现方式类以，可以将代码中所有出现包名的地方"挖坑”，指定类以`basePackage`的模型参数，让用户自己输入。

通用能力：由于用到包名的代码非常多，如果都要自己"挖坑”并制作「TL动态模板，不仅成本高、而且也容易出现遗漏（比如@MapperScan注解里也有包名）。

所以我们需要利用制作工具来自动“挖坑”并生成模板文件。

2)需求：控制是否生成办帖子相关功能

实现思路：允许用户输入一个开关参数来控制帅帖子功能相关的文件是否生成，比如`PostController、PostService、PostMapper、.PostMapper,Xml、Post`实体类等。

通用能力：用一个参数同时控制多个文件是否生成，而不是仅仅是某段代码是否生成。

3)需求：控制是否需要开启跨域

实现思路：允许用户输入一个开关参数来控制跨域相关的文件是否生成，比如`CorsConfig0java`文件。

通用能力：用一个参数控制某个文件是否生成，而不是仅能控制代码是否生成。

4)需求：自定义`Knife4jConfig`接口文档配置

实现思路：修改`Knife4jConfig`文件中的配置，比如`title、description、version、apis`扫描包路径等。

通用能力：由于要支持用户输入的参数较多，可以用一个参数控制是否要开启接口文档配置。如果开启，再让用户输入一组配置参数。

5)需求：自定义MySQL配置信息

实现思路：修改`application.yml`配置文件中MySQL的url、username、password参数。

通用能力：由于要支持用户输入的参数较多，可以定义一组隔离的配置参数。

6)需求：控制是否开启Redis

实现思路：修改和开启Redis相关的代码，比如application.yml、.pom,Xml、MainApplication,java等多个文

件的部分代码

通用能力：用一个参数同时控制多个文件的代码修改（已满足）

7)需求：控制是否开启Elasticsearch

实现思路：

-   修改和Elasticsearch相关的代码，如PostController,PostService,PostServicelmpl,application.yml等多个文件的部分代码
-   用参数控制PostEsDTO整个文件是否生成

通用能力：用一个参数同时控制多个文件的代码、以及某文件是否生成

根据以上7点需求，分析功能的实现思路，泛化成通用能力

| 需求                            | 实现思路                                                     | 通用能力                                                     |
| ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 替换生成的代码包名              | 所有包名位置挖坑，指定类似basePackage的模型参数，让用户自己输入 | 自己挖坑易漏易错、成本高，最佳实现方式：利用制作工具自动挖坑来生成FTL模板文件 |
| 控制是否生成帖子相关功能        | 用户输入一个开关参数来控制PostController、PostService、PostMapper、PostMapper.xml、Post实体类等文件是否生成 | 一个参数控制多个文件是否生成                                 |
| 控制是否需要开启跨域            | 用户输入一个开关参数来控制CorsConfig.java文件是否生成        | 一个参数控制某个文件是否生成                                 |
| 自定义Knife4jConfig接口文档配置 | 修改Knife4jConfig文件中的配置，比如title、description、version、apis扫描包路径等 | 先开关是否需要开启配置，若开启，则输入一组配置参数           |
| 自定义MySQL配置信息             | 修改application.yml配置文件中MySQL的url、username、password参数 | 由于用户输入参数较多，可以定义一组隔离的配置参数             |
| 控制是否开启Redis               | 修改和开启Redis相关的代码，比如application.yml、pom.xml、MainApplication.java等多个文件的部分代码 | 一个参数控制多个文件的代码修改（已满足）                     |
| 控制是否开启Elasticsearch       | 修改与Elasticsearch相关的代码，比如PostController、PostService、PostService.Impl、application.yml等多个文件的部分代码用参数控制PostEsDTO文件是否生成 | 一个参数控制多个文件的代码以及某文件是否生成 （3+6）         |

给通用能力排序：

1.  一个参数对应某个文件是否生成
2.  一个参数对应多个文件是否生成
3.  一个参数控制多处代码修改以及文件是否生成
4.  定义一组参数，控制代码修改或文件生成
5.  定义一组参数，通过其他**开关参数控制**是否需要输入该参数

这些基本上都和**元信息配置文件**有关，即我们需要增强它的能力，允许开发者通过修改元信息文件，得到使输入更加灵活的代码生成器

给需求排期：

1.  控制是否开启Redis
2.  控制是否需要开启跨域控制
3.  是否生成帖子相关功能
4.  控制是否开启Elasticsearch
5.  自定义MySQL配置信息
6.  自定义Knife4jConfig接口文档配置

### 3、开发实现

在开发实现的过程中，我们会持续增强元信息配置文件的能力，为了防止随着能力增多出现的罗辑冲突，我们要明确2点原则.

1)配置文件中的fileConfig应专注于文件生成相关的逻辑。

2)配置文件中的modelConfig应专注于数据模型的定义。只是定义有某个参数，但该参数具体的作用是什么，不应该放在modelConfig中来控制。比如modl可以用作配置开关、替换代码内容、控制文件是否生成等。

1.  #### 参数控制文件生成

以ACM模板为例，用一个模型参数`needGit`来控制是否生成`.gitignore`静态文件

##### **元信息修改**

1）在`meta.json`中，在`modelConfig.models`下新增`needGit`参数 

-   直播中鱼皮没有给`needGit`缩写，因为鱼皮的代码生成不包含`README.md`
-   如果要生成`README.md`，在不修改`README.md.ftl`的情况下，不写缩写，会有FreeMarker语法问题，导致打包出错。所以我这里给了一个`ng`的缩写 

```JSON
  "modelConfig": {
    "models": [
      {
        "fieldName": "needGit",
        "type": "boolean",
        "description": "是否生成 .gitignore文件",
        "defaultValue": true,
        "abbr": "ng"
      },
      ...
    ]
  }
```

##### 代码生成器实现

在idea中新开一个窗口，打开生成的`代码生成器acm-template-pro-generator`项目：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MTZmYTAwYmE4YjZiMmIwYjc2NjA2ZjM5NmVlYjkzZWJfeHpGbm03OXZCb3hkOHpOZmd2aTA0VDZmWTNsQ054SlZfVG9rZW46UlMwYWJ0Z3lwbzF0UGJ4bUxwZGNtb3lEblFnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

然后用IDEA打开生成的项目，在该项目中编写能够实现需求的MainGenerator代码。

修改的代码如下：

```Java
/**
 * 核心生成器
 */
public class MainGenerator {

    /**
     * 生成
     *
     * @param model 数据模型
     * @throws TemplateException
     * @throws IOException
     */
    public static void doGenerate(DataModel model) throws TemplateException, IOException {
        
        ...

        // 修改的代码
        boolean needGit = model.isNeedGit();
        if (needGit) {
            inputPath = new File(inputRootPath, ".gitignore").getAbsolutePath();
            outputPath = new File(outputRootPath, ".gitignore").getAbsolutePath();
            StaticFileGenerator.copyFilesByHutool(inputPath, outputPath);
        }

        ...
    }
}
```

1）先在`MainGenerator`中，进行一下两点修改

-   将doGenerate 方法的入参类型，改`Object model`为`DataModel model`，便于后续获取对象的属性
-   通过模型的`needGit`作为if条件，来判断是否生成`.gitignore`文件

然后修改Main方法代码，命令行参数指定--needGit=false并运行，发现这次没有生成.gitignore文件，符合预期。

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=M2M0NzAxYTkzMzJkNDIxZGZhNTUwNGExNDZjNzI1ZTdfcUdSU3FCc0NabXd5UGNYNERjbTU5TTd6OTB1bHowSEdfVG9rZW46VjFuSGI2elF1b1FRbUx4d2l6Z2NiYzhzbndlXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

##### 制作工具实现

1)   修改模板文件 `MainGenerator.java.ftl`

-   修改入参类型为`DataModel model`，最上方的引包加上`import ${basePackage}.model.DataModel;`

```Java
package ${basePackage}.generator;

import ${basePackage}.generator.StaticFileGenerator;
import ${basePackage}.generator.DynamicFileGenerator;
import ${basePackage}.model.DataModel;
import freemarker.template.TemplateException;

import java.io.File;
import java.io.IOException;

/**
 * 核心生成器
 */
public class FileGenerator {

    /**
     * 生成
     *
     * @param model 数据模型
     * @throws TemplateException
     * @throws IOException
     */
    public static void doGenerate(DataModel model) throws TemplateException, IOException {
        String inputRootPath = "${fileConfig.inputRootPath}";
        String outputRootPath = "${fileConfig.outputRootPath}";

        String inputPath;
        String outputPath;

    <#list modelConfig.models as modelInfo>
        ${modelInfo.type} ${modelInfo.fieldName} = model.${modelInfo.fieldName};
    </#list>
    <#list fileConfig.files as fileInfo>

        <#if fileInfo.condition??>
        if (${fileInfo.condition}) {
            inputPath = new File(inputRootPath, "${fileInfo.inputPath}").getAbsolutePath();
            outputPath = new File(outputRootPath, "${fileInfo.outputPath}").getAbsolutePath();
            <#if fileInfo.generateType == "static">
            StaticFileGenerator.copyFilesByHutool(inputPath, outputPath);
            <#else >
            DynamicFileGenerator.doGenerate(inputPath, outputPath, model);
            </#if>
        }
        <#else>
        inputPath = new File(inputRootPath, "${fileInfo.inputPath}").getAbsolutePath();
        outputPath = new File(outputRootPath, "${fileInfo.outputPath}").getAbsolutePath();
        <#if fileInfo.generateType == "static">
        StaticFileGenerator.copyFilesByHutool(inputPath, outputPath);
        <#else >
        DynamicFileGenerator.doGenerate(inputPath, outputPath, model);
        </#if>
        </#if>
    </#list>
    }
}
```

2)然后我们怎么将模型参数和文件生成进行关联呢？

在上面的代码中，我们先获取了模型对象的needGit属性值，然后将其作为if条件，来判断是否生成.gitignore文件。那么只需要在文件配置中增加一个条件字段condition,作为f代码块中的内容，就可以生成同样的代码了：

```Java
boolean needGit = model.isNeedGit();
if (needGit) {
    inputPath = new File(inputRootPath, ".gitignore").getAbsolutePath();
    outputPath = new File(outputRootPath, ".gitignore").getAbsolutePath();
    StaticGenerator.copyFilesByHuTool(inputPath, outputPath);
}
```

修改元信息配置文件，给fileConfig.files对象新增condition字段。它的值可以是某个模型参数的名称，甚至还可以是表达式。

比如指定值为needGit,配置如下：

```JSON
{
  ...
  
    "files": [
      ...
      {
        "inputPath": ".gitignore",
        "outputPath": ".gitignore",
        "type": "file",
        "generateType": "static",
        "condition": "needGit"
      },
      ...
  },
}
```

同步修改`Meta`类，给`FileInfo`新增`String`类型的`condition`属性：

```Java
@NoArgsConstructor
@Data
public static class FileInfo {
    private String inputPath;
    private String outputPath;
    private String type;
    private String generateType;
    // 新增 condition 属性
    private String condition;
}
```

3)想要在if中直接使用模型参数的名称，我们可以先通过get/set方法获取到DataModel的所有属性值，并使用模型参数的名称作为变量名，比如：

```Java
boolean needGit = model.isNeedGit();
boolean loop = model.isLoop();
String author = model.getAuthor();
String outputText = model.getOutputText();
```

***注意：***关于model.allget，如下所示，对于boolean类型的变量，获取对象属性的get方法是以`is`为前缀的，而不是`get`这样会给生成代码的过程造成一定的麻烦

```Java
boolean needGit = model.isNeedGit();
boolean loop = model.isLoop();
String author = model.getAuthor();
String outputText = model.getOutputText();
```

***（推荐）***解决方法1：直接把`DataModel`类中的所有字段修饰符改成`public`，就可以直接使用属性名获取到值了

```Java
package com.dexcode.model;
import lombok.Data;
/**
数据模型
*/
@Data
public class DataModel {
    /**
    * 是否生成 .gitignore文件
    */
    public boolean needGit = true;
    /**
    * 是否生成循环
    */
    public boolean loop = false;
    /**
    * 作者注释
    */
    public String author = "dexter";
    /**
    * 输出信息
    */
    public String outputText = "sum = ";
}
boolean needGit = model.needGit;
boolean loop = model.loop;
String author = model.author;
String outputText = model.outputText;
```

解决方式2：使用lombok的插件 `@Accessors`注释，自定义 get/set 方法代码的生成规则

可以将`fluent`设置为true ，表示 get/set 方法名称都来自于属性名，从而保证统一

参考文档：https://projectlombok.org/features/experimental/Accessors

但是这种方式会影响FreeMarker模板获取对象的值，默认是通过getXXX方法获取的，所以不推荐

4)   修改模板文件 `DataModeol.java.ftl`，修饰符改为`public`

```Java
package ${basePackage}.model;

import lombok.Data;

/**
 * 数据模型
 *
 * @author ${author}
 */
@Data
public class DataModel {

<#list modelConfig.models as modelInfo>

    <#if modelInfo.description??>
    /**
     * ${modelInfo.description}
     */
    </#if>
    public ${modelInfo.type} ${modelInfo.fieldName}<#if modelInfo.defaultValue??> =${modelInfo.defaultValue?c}</#if>;

</#list>
}
```

5)最后，修改MainGenerator.java.ftl模板文件，补充DataModel参数的获取、以及条件判断的逻辑.完整代码如下：

```Java
package ${basePackage}.generator;

import ${basePackage}.generator.StaticFileGenerator;
import ${basePackage}.generator.DynamicFileGenerator;
import ${basePackage}.model.DataModel;
import freemarker.template.TemplateException;

import java.io.File;
import java.io.IOException;

/**
 * 核心生成器
 */
public class FileGenerator {

    /**
     * 生成
     *
     * @param model 数据模型
     * @throws TemplateException
     * @throws IOException
     */
    public static void doGenerate(DataModel model) throws TemplateException, IOException {
        String inputRootPath = "${fileConfig.inputRootPath}";
        String outputRootPath = "${fileConfig.outputRootPath}";

        String inputPath;
        String outputPath;

    <#list modelConfig.models as modelInfo>
        ${modelInfo.type} ${modelInfo.fieldName} = model.${modelInfo.fieldName};
    </#list>
    <#list fileConfig.files as fileInfo>

        <#if fileInfo.condition??>
        if (${fileInfo.condition}) {
            inputPath = new File(inputRootPath, "${fileInfo.inputPath}").getAbsolutePath();
            outputPath = new File(outputRootPath, "${fileInfo.outputPath}").getAbsolutePath();
            <#if fileInfo.generateType == "static">
            StaticFileGenerator.copyFilesByHutool(inputPath, outputPath);
            <#else >
            DynamicFileGenerator.doGenerate(inputPath, outputPath, model);
            </#if>
        }
        <#else>
        inputPath = new File(inputRootPath, "${fileInfo.inputPath}").getAbsolutePath();
        outputPath = new File(outputRootPath, "${fileInfo.outputPath}").getAbsolutePath();
        <#if fileInfo.generateType == "static">
        StaticFileGenerator.copyFilesByHutool(inputPath, outputPath);
        <#else >
        DynamicFileGenerator.doGenerate(inputPath, outputPath, model);
        </#if>
        </#if>
    </#list>
    }
}
```

1.  #### 同参数控制多个文件生成

想要用同一个参数来控制多个文件是否生成，最简单的方式是直接给多个文件配置指定相同参数的condition就好了，比如：

```JSON
"files": [
    {
      "inputPath": "src/com/dexcode/acm/MainTemplate.java.ftl",
      "outputPath": "src/com/dexcode/acm/MainTemplate.java",
      "type": "file",
      "generateType": "dynamic",
      "condition": "needGit"
    },
    {
      "inputPath": ".gitignore",
      "outputPath": ".gitignore",
      "type": "file",
      "generateType": "static",
      "condition": "needGit"
    },
]
```

但如果之后我想统一更改这些字段的condition条件，或者查看某个condition(或者模型参数)同时控制的多个

文件怎么办？文件越多，会不会越难维护和管理？

为了解决这个问题，我们可以根据生成条件，来对文件进行分组。

这里有2种方案：

##### 方案一

给元信息的 fileInfo 增加 group 字段，指定每个文件所属的组

参考代码

```JSON
"files": [
    {
      "inputPath": "src/com/dexcode/acm/MainTemplate.java.ftl",
      "outputPath": "src/com/dexcode/acm/MainTemplate.java",
      "type": "file",
      "generateType": "dynamic",
      "group": "post"
    },
]
```

再给 fileConfig 增加 groupConfig 组配置，包括组名、生成条件等

```JSON
"fileConfig": {
  ...
  "groupConfig": {
    "groups": [
      {
        "name": "post",
              "condition": "needCors"
      }
    ]
  }
}
```

这种方式很像设计库表，把组、文件分别定义，再通过文件指定所属组实现关联。

优点是结构清晰，可以通过读取groupConfig直接获取到所有组的信息。

但这种方式的缺点是，不好通过配置文件直接获取到同组下的所有文件。还可能会导致文件生成的代码不够优雅、

会有很多重复的if块判断，比如：

```Java
boolean needGit = model.isNeedGit();

if (needGit) {
    inputPath = new File(inputRootPath, ".gitignore").getAbsolutePath();
    outputPath = new File(outputRootPath, ".gitignore").getAbsolutePath();
    StaticFileGenerator.copyFilesByHutool(inputPath, outputPath);
}

if (needGit) {
    inputPath = new File(inputRootPath, "README.md").getAbsolutePath();
    outputPath = new File(outputRootPath, ".README.md").getAbsolutePath();
    StaticFileGenerator.copyFilesByHutool(inputPath, outputPath);
}
```

##### 方案二

直接把文件组当成一个特殊的文件夹，可以把同组文件都放到该组配置下。

```JSON
"files": [
  {
    "inputPath": "src/com/dexcode/acm/MainTemplate.java.ftl",
    "outputPath": "src/com/dexcode/acm/MainTemplate.java",
    "type": "file",
    "generateType": "dynamic"
  },
  {
    "groupKey": "git",
    "groupName": "开源",
    "type": "group",
    "condition": "needGit",
    "files":[
      {
        "inputPath": ".gitignore",
        "outputPath": ".gitignore",
        "type": "file",
        "generateType": "static",
      },
      {
        "inputPath": "README.md",
        "outputPath": "README.md",
        "type": "file",
        "generateType": "static"
      }
    ]
  }
]
```

上述代码中新增字段：

-   groupKey:表示组的唯一表示
-   groupName:组的名称
-   type:值为group代表是分组
-   condition:该分组共享的生成条件，同时控制组内多个文件的生成

这种方式的优点显而易见，可以直接从fileConfig配置中看出文件的层级关系，便于理解；且更容易获取同组文

件信息、控制同组文件的生成。

但缺点是：生成代码的时候，如果filelnfo的type为group组类别，就要多遍历一层fles了。

不过还是建议选择这种方式，多遍历一层fls的开发成本并不大，应当为长期的可维护、可扩展性考虑。

采用这种方式后，MainGenerator生成代码的逻辑会更清晰，同组文件可以放到同一个if块里。示例代码如下：

```Java
boolean needGit = model.isNeedGit();

// groupKey = git
if (needGit) {
    // 同组下的文件都放在一个 if 判断中了
    inputPath = new File(inputRootPath, ".gitignore").getAbsolutePath();
    outputPath = new File(outputRootPath, ".gitignore").getAbsolutePath();
    StaticFileGenerator.copyFilesByHutool(inputPath, outputPath);

    inputPath = new File(inputRootPath, "README.md").getAbsolutePath();
    outputPath = new File(outputRootPath, ".README.md").getAbsolutePath();
    StaticFileGenerator.copyFilesByHutool(inputPath, outputPath);
}
```

##### 方案实现

1.  首先修改Meta实体类的FileInfo文件信息配置，新增分组相关属性:

```Java
@NoArgsConstructor
@Data
public static class FileInfo {
    private String inputPath;
    private String outputPath;
    private String type;
    private String generateType;
    private String condition;
    private String groupKey;
    private String groupName;
    private List<FileInfo> files;
}
```

1.  修改`FileTypeEnum`枚举类，增加`GROUP`分组枚举：

```Java
package com.dexcode.maker.meta.enums;

/**
 * 文件类型枚举
 */
public enum FileTypeEnum {

    DIR("目录", "dir"),
    FILE("文件", "file"),
    GROUP("文件组","group");
    
    private final String text;
    private final String value;

    FileTypeEnum(String text, String value) {
        this.text = text;
        this.value = value;
    }

    public String getText() {
        return text;
    }

    public String getValue() {
        return value;
    }
}
```

1.  由于新增了分组类别，当文件类别为group时可以不填写文件输入输出路径等信息。所以需要修改`MetaValidator`校验逻辑，类型为group时不做后续校验。

```Java
for (Meta.FileConfig.FileInfo fileInfo : fileInfoList) {
    // 第六期，新增 group 分组类别
    String type = fileInfo.getType();
    if (FileTypeEnum.GROUP.getValue().equals(type)){
        continue;
    }

    // inputPath 必填
    String inputPath = fileInfo.getInputPath();
    if (StrUtil.isBlank(inputPath)) {
        throw new MetaException("未填写 inputPath");
    }
    ...
}
```

1.  修改`MainGenerator.java.ftl` 完整代码如下:

```Java
package ${basePackage}.generator;

import ${basePackage}.model.DataModel;
import freemarker.template.TemplateException;

import java.io.File;
import java.io.IOException;

/**
 * @author ${author}
 */
public class MainGenerator {

    public static void doGenerator(DataModel model) throws TemplateException, IOException {
        String inputRootPath = "${fileConfig.inputRootPath}";
        String outputRootPath = "${fileConfig.outputRootPath}";
        String inputPath;
        String outputPath;
        <#list modelConfig.models as modelInfo>
        ${modelInfo.type} ${modelInfo.fieldName} = model.${modelInfo.fieldName};
        </#list>
    <#list fileConfig.files as fileInfo>
        <#if fileInfo.groupKey??>
        // groupKey = ${fileInfo.groupKey}
            <#if fileInfo.condition??>
        if (${fileInfo.condition}) {
            <#list fileInfo.files as fileInfo>
            inputPath = new File(inputRootPath, "${fileInfo.inputPath}").getAbsolutePath();
            outputPath = new File(outputRootPath, "${fileInfo.outputPath}").getAbsolutePath();
            <#if fileInfo.generateType=="dynamic">
            DynamicGenerator.doGenerate(inputPath, outputPath, model);
            <#elseif fileInfo.generateType=="static">
            StaticGenerator.copyFilesByHuTool(inputPath, outputPath);
            </#if>
            </#list>
        }
        <#else>
        <#list fileInfo.files as fileInfo>
        inputPath = new File(inputRootPath, "${fileInfo.inputPath}").getAbsolutePath();
        outputPath = new File(outputRootPath, "${fileInfo.outputPath}").getAbsolutePath();
        <#if fileInfo.generateType=="dynamic">
        DynamicGenerator.doGenerate(inputPath, outputPath, model);
        <#elseif fileInfo.generateType=="static">
        StaticGenerator.copyFilesByHuTool(inputPath, outputPath);
        </#if>
        </#list>
        </#if>
        <#else>
        <#if fileInfo.condition??>
        if (${fileInfo.condition}) {
            inputPath = new File(inputRootPath, "${fileInfo.inputPath}").getAbsolutePath();
            outputPath = new File(outputRootPath, "${fileInfo.outputPath}").getAbsolutePath();
            <#if fileInfo.generateType=="dynamic">
            DynamicGenerator.doGenerate(inputPath, outputPath, model);
            <#elseif fileInfo.generateType=="static">
            StaticGenerator.copyFilesByHuTool(inputPath, outputPath);
            </#if>
        }
        </#if>
        </#if>
    </#list>
    }
}
```

编写过程中，重复代码太多了，不利于维护

解决方法：采用Freemarker的**宏定义**，将重复的代码定义成一个“组件”，支持传递不同的参数，可以在其他地方被引用

>   Freemarker的**宏定义**文档：http://freemarker.foofun.cn/ref_directive_macro.html

比如将文件生成逻辑定义为宏，将 fileInfo 和 indent（缩进）作为参数传递

```Java
<#macro generateFile indent fileInfo>
${indent}inputPath = new File(inputRootPath, "${fileInfo.inputPath}").getAbsolutePath();
${indent}outputPath = new File(outputRootPath, "${fileInfo.outputPath}").getAbsolutePath();
<#if fileInfo.generateType == "static">
${indent}StaticFileGenerator.copyFilesByHutool(inputPath, outputPath);
<#else >
${indent}DynamicFileGenerator.doGenerate(inputPath, outputPath, model);
</#if>
</#macro>
```

1.  #### 同参数控制代码和文件生成

其实该功能已经实现了，只要让这个参数基础**既出现**在condition中控制文件生成，**又出现**在FreeMarker动态模板中作为生成代码的参数即可

1.  #### 定义一组相关的参数

对于一个复杂的代码生成器，可能会有很多允许用户自定义的参数，比如光MySQL的配置，都可能有十几条。

如果把所有这些参数全按顺序写在元信息的模型配置中，可能用户在使用时，会被要求一次性输入大量的参数，增加使用和理解成本。而且配置之间有可能会有名称冲突，比如MySQL和其他数据库可能都有url配置。

对于这种情况，最常用的方式就是分组，和上述文件分组类似，我们也可以对数据模型进行分组。各组下的模型参数互相隔离、保证不会出现命名冲突。

>   TypeScript,FreeMarker 等很多框架都会采用类似命名空间(分组)的概念来隔离变量

##### 元信息修改

```JSON
"modelConfig": {
  "models": [
    {
      "fieldName": "needGit",
      "type": "boolean",
      "description": "是否生成 .gitignore文件",
      "defaultValue": true,
      "abbr": "ng"
    },
    {
      "fieldName": "loop",
      "type": "boolean",
      "description": "是否生成循环",
      "defaultValue": false,
      "abbr": "l"
    },
    {
      "groupKey": "mainTemplate",
      "groupName": "核心模板",
      "type": "MainTemplate",
      "description": "用于生成核心模板文件",
      "models": [{
        "fieldName": "author",
        "type": "String",
        "description": "作者注释",
        "defaultValue": "dexter",
        "abbr": "a"
      },
        {
          "fieldName": "outputText",
          "type": "String",
          "description": "输出信息",
          "defaultValue": "sum = ",
          "abbr": "o"
        }
      ]
    }
  ]
}
```

上述中代码新增字段：

-   groupKey：表示组的唯一标识，有groupKey的表示开启分组，必须为英文
-   groupName：组的名称
-   type：表示对应的 Java class 类型，必须是大写开头

需要同步修改`Meta.java`对应的实体类,为`ModelInfo`补充新字段

```Java
@NoArgsConstructor
@Data
public static class ModelInfo {
    private String fieldName;
    private String type;
    private String description;
    private Object defaultValue;
    private String abbr;
    private String groupKey;
    private String groupName;
    private List<ModelInfo> models;
}
```

还需要修改MetaValidator的校验逻辑，如果模型的groupKey不为空，表示为模型组配置，则不校验fieldName等。

```Java
for (Meta.ModelConfig.ModelInfo modelInfo : modelInfoList) {
    // 第六期，新增 groupKey，标记分组配置
    String groupKey = modelInfo.getGroupKey();
    if (StrUtil.isNotEmpty(groupKey)){
        continue;
    }
    // 输出路径默认值
    String fieldName = modelInfo.getFieldName();
    ...
}
```

##### 代码生成器实现

修改位置：制作工具生成的`acm-template-pro-generator`代码生成器中

1)   同组参数封装

将同一组的参数封装到同一个类中，新建`model.MainTemplate`类：

```Java
package com.dexcode.model;

import lombok.Data;

/**
 * 用于生成核心模板文件
 */
@Data
public class MainTemplate {

    /**
     * 作者注释
     */
    public String author = "dexter";

    /**
     * 输出信息
     */
    public String outputText = "sum = ";
}
```

`model.DataModel`类中定义该类型的属性字段：

```Java
package com.dexcode.model;

import lombok.Data;

/**
* 数据模型
*/
@Data
public class DataModel {

    /**
    * 是否生成 .gitignore文件
    */
    public boolean needGit = true;

    /**
    * 是否生成循环
    */
    public boolean loop = false;

    /**
     * 核心模板
     */
    public MainTemplate mainTemplate;
}
```

2)   如何让用户的输入自动填充到该对象中呢?

最直接方式: 像原来一样让用户依次输入所有的参数,然后将参数一个个地设置到参数组对象中.

但是这种方式并不优雅,Picocli作为一个强大的命令行开发工具,已经帮我们想到了复杂参数的场景,并且提供了参数组特性

>   Picocli参数组特性：https://picocli.info/#_argument_groups

在`GenerateCommand`类的基础上新建`TestArgGroupCommad`类，用于测试参数组特性在该命令类中，定义参数组属性，并添加`@ArgGroup`类，用于标记分组

然后在命令类中新建对应的静态内部类，定义author和outputText属性。并给选项注解的names属性增加参数组的groupKey前缀，比如`-mainTemplate.a`,从而实现同名参数相互隔离。

```Java
package com.dexcode.cli.command;

import lombok.Data;
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;
import picocli.CommandLine.ArgGroup;

@Command(name = "test", mixinStandardHelpOptions = true)
@Data
public class TestArgGroupCommad implements Runnable {

    @Option(names = {"-ng", "--needGit"}, arity = "0..1", description = "是否生成 .gitignore文件", interactive = true, echo = true)
    private boolean needGit = true;

    @Option(names = {"-l", "--loop"}, arity = "0..1", description = "是否生成循环", interactive = true, echo = true)
    private boolean loop = false;

    // 添加@ArgGroup类，用于标记分组
    @ArgGroup(exclusive = false,heading = "核心模板%n")
    MainTemplate mainTemplate;

    // run方法打印属性值
    @Override
    public void run(){
        System.out.println(needGit);
        System.out.println(loop);
        System.out.println(mainTemplate);
    }

    // 静态内部类，定义 mainTemplate.author 和 mainTemplate.outputText 属性
    @Data
    static class MainTemplate{
        @Option(names = {"-mainTemplate.a", "--mainTemplate.author"}, arity = "0..1", description = "作者注释", interactive = true, echo = true)
        private String author = "dexter";

        @Option(names = {"-mainTemplate.o", "--mainTemplate.outputText"}, arity = "0..1", description = "输出信息", interactive = true, echo = true)
        private String outputText = "sum = ";
    }

    // main方法写调用逻辑
    public static void main(String[] args) {
        CommandLine commandLine = new CommandLine(TestArgGroupCommad.class);
//        commandLine.execute("-l", "-mainTemplate.a", "--mainTemplate.outputText");
        commandLine.execute("--help");
    }
}
```

然后在命令类的run方法中打印所有的属性值

```Java
@Override
public void run() {
    System.out.println(loop);
    System.out.println(needGit);
    System.out.println(mainTemplate);
}
```

完整代码如下

```Java
package com.manneia.cli.command;

import cn.hutool.core.bean.BeanUtil;
import com.manneia.generator.MainGenerator;
import com.manneia.model.DataModel;
import lombok.Data;
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;
import picocli.CommandLine.ArgGroup;

import java.util.concurrent.Callable;

/**
 * @author manneia
 */
@Command(name = "generate", description = "生成代码", mixinStandardHelpOptions = true)
@Data
public class TestArgGroupCommand implements Runnable {


    @Option(names = {"-", "--needGit"}, arity = "0..1", description = "是否生成 .gitignore文件",
            interactive = true, echo = true)
    private boolean needGit = true;

    @Option(names = {"-l", "--loop"}, arity = "0..1", description = "是否生成循环",
            interactive = true, echo = true)
    private boolean loop = false;

    @ArgGroup(exclusive = false, heading = "核心模板%n", multiplicity = "1")
    MainTemplate mainTemplate;

    @Data
    static class MainTemplate {
        /**
         * 是否开启循环
         */
        @Option(names = {"-mainTemplate.a", "--mainTemplate.author"}, arity = "0..1", description = "作者",
                interactive = true, echo = true)
        private String author = "manneia" ;

        /**
         * 是否生成 .gitignore 文件
         */
        @Option(names = {"-mainTemplate.o", "--mainTemplate.outputText"}, arity = "0..1", description = "输出信息",
                interactive = true, echo = true)
        private String outputText = "sum= " ;
    }


    @Override
    public void run() {
        System.out.println(loop);
        System.out.println(needGit);
        System.out.println(mainTemplate);
    }

    public static void main(String[] args) {
        CommandLine commandLine = new CommandLine(TestArgGroupCommand.class);
        args = new String[]{"-a=lidog"};
        commandLine.execute(args);
    }
}
```

执行main方法测试，输入`--help`参数时，发现帮助手册已经支持自动分组

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MTg0YWEzOGY5MDA5ODk3OGExY2U1ODViZGExODhhZDVfbzc2c2hhMjhGZzBCcERucmM5bG1zN1p5NnZORTRlY0lfVG9rZW46WTd2MmJ0ak1ob0NJRGV4bDZFMGNuZjA5bktmXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

再测试输入各项参数，从输出结果可以看到用户输入的值已经填充到组对象中了

这种方式虽然能够实现参数分组，但对于用户而言，还是要一次性输入多个参数，或者一步步提示，使用成本过高

所以暂不修改制作工具，思考是否有更优化的方式

1.  #### 定义可选开启的参数组

我们的需求是: 可以根据用户输入的某个开关参数,来控制是否要让用户输入其他的参数组.

也就是说,我们的模型参数之间是存在依赖关系的,必须按照某个顺序依次引导用户输入.

那其实我们可以想一种更优雅的交互方式:首先让用户输入最外层未分组的模型参数.然后再根据用户的输入情况,引导用户依次输入分组的参数.

简单来说,就是对复杂的输入进行了分布,让用户一步步填写.

##### 实现思路

“套娃”，即输入完成一个Command类，再去触发下一个Command类

步骤如下：

1.  每个参数组创建一个独立的 Picocli Command 类，用于通过命令行接收参数
2.  先用最外层的Command类（GenerateCommand）接收最外层的参数
3.  通过run 或者 call方法，确定最外层的结果，为true则再去使用**步骤1.**中的独立类和用户交互

##### 代码生成器具体实现

1)首先在 DataModel 类中新建组参数对应的静态内部类和对应的属性,注意要给属性填充默认值.

```Java
/**
 * 核心模板
 */
public MainTemplate mainTemplate = new MainTemplate();

/**
 * 用于生成核心模板文件
 */
@Data
public static class MainTemplate{
    /**
     * 是否开启循环
     */
    private String author = "manneia" ;

    /**
     * 是否生成 .gitignore 文件
     */
    private String outputText = "sum= " ;
}
```

2)   

 编写Picocli命令类，在类中定义属性

先复制`TestArgGroupCommad`得到`TestGroupCommad`类，以下代码都写在此类中（主类）

命令类中needGit、loop、mainTemplate （`static`标记参数组对象，并以**静态内部类**放在主类中）

```Java
@Option(names = {"-", "--needGit"}, arity = "0..1", description = "是否生成 .gitignore文件",
        interactive = true, echo = true)
private boolean needGit = true;

@Option(names = {"-l", "--loop"}, arity = "0..1", description = "是否生成循环",
        interactive = true, echo = true)
private boolean loop = false;

static DataModel.MainTemplate mainTemplate = new DataModel.MainTemplate();

@Command(name = "mainTemplate", description = "用于生成核心模板文件", mixinStandardHelpOptions = true)
@Data
public static class MainTemplateCommand implements Runnable{
    /**
     * 是否开启循环
     */
    @Option(names = {"-a", "--author"}, arity = "0..1", description = "作者",
            interactive = true, echo = true)
    private String author = "manneia";

    /**
     * 是否生成 .gitignore 文件
     */
    @Option(names = {"-o", "--outputText"}, arity = "0..1", description = "输出信息",
            interactive = true, echo = true)
    private String outputText = "sum= ";

    @Override
    public void run() {
        mainTemplate.setAuthor(author);
        mainTemplate.setOutputText(outputText);
    }
}
```

3)   编写独立的参数组命令类

按照上面的步骤,先根据参数创建一个独立的Picocli命令类,作为静态内部类放在`TestGroupCommand`主类中.于是分步输入,这次`Option`注解的names属性可以不用再带groupKey前缀了.

然后在该类的run方法中,将接受到的用户输入依次赋值给外层的参数组对象

```Java
@Command(name = "mainTemplate", description = "用于生成核心模板文件", mixinStandardHelpOptions = true)
    @Data
    public static class MainTemplateCommand implements Runnable{
        /**
         * 是否开启循环
         */
        @Option(names = {"-a", "--author"}, arity = "0..1", description = "作者",
                interactive = true, echo = true)
        private String author = "manneia";

        /**
         * 是否生成 .gitignore 文件
         */
        @Option(names = {"-o", "--outputText"}, arity = "0..1", description = "输出信息",
                interactive = true, echo = true)
        private String outputText = "sum= ";

        @Override
        public void run() {
            mainTemplate.setAuthor(author);
            mainTemplate.setOutputText(outputText);
        }
    }
```

4)   控制参数组命令交互

在主命令类的run方法中,添加根据条件判断是否要处输入分组参数的逻辑.

可以通过`commandLine.execute`方法以及自己构造的完整命令行参数,来触发分组下所有字段的交互式输入.最后再将获取到的参数对象赋值给DataModel对象

```Java
@Override
public void run() {
    System.out.println(loop);
    System.out.println(needGit);
    if (true) {
        CommandLine commandLine = new CommandLine(MainTemplateCommand.class);
        commandLine.execute("-a", "-o");
    }
    System.out.println(mainTemplate);
    // 赋值给DataModel
    //DataModel dataModel = new DataModel();
    //dataModel.maninTemplate = mainTemplate;
    //BeanUtil.copyProperties(this,dataModel);
    //MainGenerator.doGenerator(dataModel);
}
```

完整代码如下:

```Java
package com.manneia.cli.command;

import cn.hutool.core.bean.BeanUtil;
import com.manneia.generator.MainGenerator;
import com.manneia.model.DataModel;
import lombok.Data;
import picocli.CommandLine;
import picocli.CommandLine.ArgGroup;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;

/**
 * @author manneia
 */
@Command(name = "generate", description = "生成代码", mixinStandardHelpOptions = true)
@Data
public class TestGroupCommand implements Runnable {


    @Option(names = {"-", "--needGit"}, arity = "0..1", description = "是否生成 .gitignore文件",
            interactive = true, echo = true)
    private boolean needGit = true;

    @Option(names = {"-l", "--loop"}, arity = "0..1", description = "是否生成循环",
            interactive = true, echo = true)
    private boolean loop = false;

    static DataModel.MainTemplate mainTemplate = new DataModel.MainTemplate();

    @Command(name = "mainTemplate", description = "用于生成核心模板文件", mixinStandardHelpOptions = true)
    @Data
    public static class MainTemplateCommand implements Runnable{
        /**
         * 是否开启循环
         */
        @Option(names = {"-a", "--author"}, arity = "0..1", description = "作者",
                interactive = true, echo = true)
        private String author = "manneia";

        /**
         * 是否生成 .gitignore 文件
         */
        @Option(names = {"-o", "--outputText"}, arity = "0..1", description = "输出信息",
                interactive = true, echo = true)
        private String outputText = "sum= ";

        @Override
        public void run() {
            mainTemplate.setAuthor(author);
            mainTemplate.setOutputText(outputText);
        }
    }


    @Override
    public void run() {
        System.out.println(loop);
        System.out.println(needGit);
        if (loop) {
            CommandLine commandLine = new CommandLine(MainTemplateCommand.class);
            commandLine.execute("-a", "-o");
        }
        System.out.println(mainTemplate);
        // 赋值给DataModel
        //DataModel dataModel = new DataModel();
        //dataModel.maninTemplate = mainTemplate;
        //BeanUtil.copyProperties(this,dataModel);
        //MainGenerator.doGenerator(dataModel);
    }

    public static void main(String[] args) {
        CommandLine commandLine = new CommandLine(TestGroupCommand.class);
        args = new String[]{"--needGit", "-l"};
        commandLine.execute(args);
    }
}
```

最后执行main方法测试,会按照顺序引导用户输入:

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ODIyMWE2YmMyNjhhZjViNTFlNDk4ZWY3ZGUzNmNkMjZfUDZ2cERxeU41QWZuVE53bWRkSmJRWTNGcDJMWUtZVnNfVG9rZW46RWRhRmJCSjlMb0pZalp4YkJrVGNidGtWbjZjXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

##### 制作工具实现

1)   修改元信息文件的models 组配置, 补充`condition`字段,用loop字段来控制是否开启分组:

```JSON
{
  "groupKey": "mainTemplate",
  "groupName": "核心模板",
  "type": "MainTemplate",
  "description": "用于生成核心模板文件",
  "condition": "loop",
  "models": [
    {
      "fieldName": "author",
      "type": "String",
      "description": "作者",
      "defaultValue": "manneia",
      "abbr": "a"
    },
    {
      "fieldName": "outputText",
      "type": "String",
      "description": "输出信息",
      "defaultValue": "sum= ",
      "abbr": "o"
    }
  ]
}
```

同步修改Meta实体类,给`ModelInfo`补充`condition`字段:

```Java
@NoArgsConstructor
@Data
public static class ModelInfo {
    private String fieldName;
    private String type;
    private String description;
    private Object defaultValue;
    private String abbr;
    private String groupKey;
    private String groupName;
    private List<ModelInfo> models;
    private String condition;
}
```

2)   修改`DataModel.java.ftl`模板文件,目标是生成前面已经跑通流程的代码.

```Java
package ${basePackage}.model;

import lombok.Data;


<#macro generateModel indent modelInfo>
    <#if modelInfo.description??>
${indent}/**
${indent} * ${modelInfo.description}
${indent} */
    </#if>
${indent}public ${modelInfo.type} ${modelInfo.fieldName}<#if modelInfo.defaultValue??> = ${modelInfo.defaultValue?c}</#if>;
</#macro>
/**
 * 数据模型
 *
 * @author ${author}
 */
@Data
public class DataModel {

<#list modelConfig.models as modelInfo>
    <#-- 有分组 -->
    <#if modelInfo.groupKey??>
    /**
     * ${modelInfo.groupName}
     */
    public ${modelInfo.type} ${modelInfo.groupKey} = new ${modelInfo.type}();

    /**
     * ${modelInfo.description}
     */
    @Data
    public static class ${modelInfo.type} {
        <#list modelInfo.models as modelInfo>
        <@generateModel indent="        " modelInfo=modelInfo/>
        </#list>
    }
    <#else>
    <#-- 无分组 -->
    <@generateModel indent="    " modelInfo=modelInfo/>
    </#if>
</#list>
}
```

3)   注意,模型分组后,我们在`MainGenerate`中获取模型字段的代码也要修改,多取一个层级:

```Java
String author = model.mainTemplate.author;
String outputText = model.mainTemplate.outputText;
```

所以需要修改`MainGenerate.java.ftl`模型文件

```Java
<#list modelConfig.models as modelInfo>
<#-- 有分组 -->
<#if modelInfo.groupKey??>
    <#list modelInfo.models as subModelInfo>
${subModelInfo.type} ${subModelInfo.fieldName}=model.${modelInfo.groupKey}.${subModelInfo.fieldName};
    </#list>
<#-- 无分组 -->
<#else>
${modelInfo.type} ${modelInfo.fieldName} = model.${modelInfo.fieldName};
</#if>
```

4)   修改`GenerateCommand.java.ftl`模板文件,目标是生成已经跑通流程的代码

这里复杂的地方在于,如何根据models配置生成包含所有参数的args列表

涉及到遍历(models)、取特定字段((fieldName)、拼接字符串（用逗号连接）等逻辑，都在FreeMarker中实现就大复杂了。所以比处我们选择在Java代码中处理好变量，然后在FreeMarker模板直接引用变量即可。

修改Meta.java实体类，给ModelInfo补充allArgsStr中间参数，记录该分组下所有参数拼接字符串：

```Java
@NoArgsConstructor
@Data
public static class ModelInfo {
    private String fieldName;
    private String type;
    private String description;
    private Object defaultValue;
    private String abbr;
    private String groupKey;
    private String groupName;
    private List<ModelInfo> models;
    private String condition;

    // 中间参数
    // 该分组下所有参数拼接字符串
    private String allArgsStr;
}
```

然后在`MetaValidator.java`中补充生成中间参数的逻辑

```Java
for (Meta.ModelConfig.ModelInfo modelInfo : modelInfoList) {
    String fieldName = modelInfo.getFieldName();
    String type = modelInfo.getType();
    String groupKey = modelInfo.getGroupKey();
    // 为group 不校验
    if (StrUtil.isNotEmpty(groupKey)) {
        // 生成中间参数
        List<Meta.ModelConfig.ModelInfo> subModelInfoList = modelInfo.getModels();
        String allArgsStr = subModelInfoList.stream().map(subModelInfo -> {
            return String.format("\"--%s\"", subModelInfo.getFieldName());
        }).collect(Collectors.joining(", "));
        modelInfo.setAllArgsStr(allArgsStr);
        continue;
    }
}    
```

-   写`GenerateCommand.java.ftl`模板文件（☆ 注意***宏的定义***）

```Java
package ${basePackage}.cli.command;

import cn.hutool.core.bean.BeanUtil;
import ${basePackage}.generator.MainGenerator;
import ${basePackage}.model.DataModel;
import lombok.Data;
import picocli.CommandLine;
import picocli.CommandLine.Option;
import picocli.CommandLine.Command;

import java.util.concurrent.Callable;

<#--生成选项-->
<#macro generateOption indent modelInfo>
${indent}@Option(names = {<#if modelInfo.abbr??>"-${modelInfo.abbr}",</#if>"--${modelInfo.fieldName}"}, arity = "0..1", <#if modelInfo.description??>description = "${modelInfo.description}", </#if>
                interactive = true, echo = true)
${indent}private ${modelInfo.type} ${modelInfo.fieldName}<#if modelInfo.defaultValue??> = ${modelInfo.defaultValue?c}</#if>;
</#macro>


<#macro generateCommand indent modelInfo>
${indent}System.out.println("输入${modelInfo.groupName}配置:");
${indent}CommandLine commandLine = new CommandLine(${modelInfo.type}Command.class);
${indent}commandLine.execute(${modelInfo.allArgsStr});
</#macro>
/**
 * @author ${author}
 */
@Command(name = "generate", description = "生成代码", mixinStandardHelpOptions = true)
@Data
public class GenerateCommand implements Callable<Integer> {

<#list modelConfig.models as modelInfo>
        <#-- 有分组 -->
<#if modelInfo.groupKey??>
    /**
     * ${modelInfo.groupName}
     */
    static DataModel.${modelInfo.type} ${modelInfo.groupKey} = new DataModel.${modelInfo.type}();
    @Command(name = "${modelInfo.groupName}", description = "${modelInfo.description}")
    @Data
    public static class ${modelInfo.type}Command implements Runnable{
        <#list modelInfo.models as subModelInfo>
            <@generateOption indent="        " modelInfo=subModelInfo/>
        </#list>

        @Override
        public void run() {
            <#list modelInfo.models as subModelInfo>
            ${modelInfo.groupKey}.${subModelInfo.fieldName} = ${subModelInfo.fieldName};
            </#list>
        }
    }
    <#else>
    <#--无分组-->
    <@generateOption indent="    " modelInfo=modelInfo/>
    </#if>
</#list>
    <#--生成调用方法-->
    @Override
    public Integer call() throws Exception {
        <#list modelConfig.models as modelInfo>
            <#if modelInfo.groupKey??>
                <#if modelInfo.condition??>
        if(${modelInfo.condition}){
            <@generateCommand indent="            " modelInfo=modelInfo/>
        }
                <#else>
        <@generateCommand indent="        " modelInfo=modelInfo/>
                </#if>
            </#if>
        </#list>
        <#--填充数据模型对象-->
        DataModel datamodel = new DataModel();
        BeanUtil.copyProperties(this, datamodel);
        <#list modelConfig.models as modelInfo>
            <#if modelInfo.groupKey??>
        datamodel.${modelInfo.groupKey} = ${modelInfo.groupKey};
            </#if>
        </#list>
        System.out.println("配置信息: " + datamodel);
        MainGenerator.doGenerator(datamodel);
        return 0;
    }
}
```

由于meta.json的modelConfig被修改了,所以在运行时,README.md文件会生成错误报错. 可以注释掉该文件内的逻辑.

或修改:

~~~Java
# ${name}

> ${description}
>
> 作者：${author}
>
> 基于 [manneia] 的 [定制代码生成器项目](https://github.com/manneia/manneia-generator) 制作，感谢您的使用！

可以通过命令行交互式输入的方式动态生成想要的项目代码

## 使用说明

执行项目根目录下的脚本文件：

```
generator <命令> <选项参数>
```

示例命令：

```
generator generate <#list modelConfig.models as modelInfo><#if modelInfo.models??><#list modelInfo.models as subModelInfo>-${subModelInfo.abbr}</#list><#else>-${modelInfo.abbr}</#if> </#list>
```

## 参数说明

<#list modelConfig.models as modelInfo>
${modelInfo?index + 1}.<#if modelInfo.models??><#list modelInfo.models as subModelInfo>-${subModelInfo.fieldName}</#list><#else>-${modelInfo.fieldName}</#if>

    类型：${modelInfo.type}

    描述：${modelInfo.description}

    默认值：<#if modelInfo.models??><#list modelInfo.models as subModelInfo>-${subModelInfo.defaultValue?c}</#list><#else>-${modelInfo.defaultValue?c}</#if>

    缩写： -<#if modelInfo.models??><#list modelInfo.models as subModelInfo>-${subModelInfo.abbr}</#list><#else>-${modelInfo.abbr}</#if>
</#list>
~~~

5)   测试

最后测试一下效果，输入loop值为true时，工具会接着引导我们输入核心模板配置：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NWNlNzMzMmIzMDA2ZTMwODY4MjNhM2NkYmM5MmY2ZmNfMVNwNnUyMm9XUU9xUFdnNHZ5NGQyTjdqbnRJcVNIMjdfVG9rZW46RmplZWJNMk9xb041OEZ4am1OY2NtaWZ4bmhjXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

而输入loop的值为false时,直接结束,符合预期

但是存在一个问题，我们查看制作工具打包的代码生成器生成的目标代码，发现āuthor的值并没有生成：

## 六、模板制作工具实现

### 1、需求分析

还记得么？在上期教程的最后，我们遇到了一个问题：当我们更改元信息数据模型配置，将模型参数进行分组后，

我们之前已经编写的FreeMarker动态模板就无法正确生成内容了。这是因为使用的模型参数发生了变更，导致无法正确获得值。

通过这个问题，我们会发现，动态模板和元信息配置是有很强的绑定关系的，稍有不慎，就有可能导致代码生成异常。

此外，我们上期教程中，还遗留了一个需求无法解决一替换生成的代码包名。

因为对于Spring Boot项目模板这种相对复杂的项目，里面用到包名的ava文件太多了，如果每个文件都要自己"挖坑”来制作模板，不仅成本高、也容易出现遗漏。

也就是说，虽然制作工具已经能够生成代码生成器了，但还是存在2大问题：

1.  需要人工提前准备动态模板，项目文件越多，使用成本越高
2.  需要根据动态模板编写对应的配置，参数越多，越容易出现和模板不一致的风险

如何解决这个问题呢？

答案很简单。我们可以让制作工具根据我们的想法，自动给项目文件“挖坑”，并生成相互对应的动态模板文件和元信息配置。提高效率的同时，减少模型参数和模板不一致的风险。

这就是我们这次需要完成的需求。

不过需要明确一点: **制作工具只是提高效率,无法覆盖所有的定制需求!**

因为想要如何制作代码生成器,还是取决于开发者.

### 2、核心设计

快速制作模板的公式:

-   向制作工具输入: 基本信息 + 输入文件 + 模型参数 (+ 输出规则)
-   由制作工具输出: 模板文件 + 元信息配置

>   和编写算法题目一样,先明确算法的输入和输出.再去设计实现算法

流程图如下:

暂时无法在飞书文档外展示此内容

分别解释一下上述输入参数：

1)基本信息：要制作的代码生成器的基本信息，对应元信息的名称、描述、版本号、作者等信息

2)输入文件：要“挖坑”的原始文件。可能是一个文件、也可能是多个文件。

3)模型参数：要引导用户输入并填充到模板的模型参数，对应元信息的modelConfig模型配置。

4)输出规则：作为一个后续扩展功能的可选参数，比如多次制作时是否覆盖旧的配置等。

输出参数就比较好理解了，在指定目录下生成FTL模板文件、以及`meta.json`元信息配置文件。

明确了程序的输入输出后，下面我们就先实现一个最基础的模板制作工具，然后再陆续给工具增加功能。

>   小技巧: 开发复杂需求或新项目时,先一切从简,完成核心流程的开发,在这个过程中可以记录想法和扩展思路,后面再按需实现

### 3、基础功能实现

首先打开制作工具(marker)项目,在`maker`包下新建`template`包,所有和模板制作相关的代码都放到该包下,实现功能隔离.

>   目前项目中的`maker.model`目录和`FileGenerate`的`main`方法是多余的,可以删除

1.  #### 基本流程实现

预期是以ACM示例模板项目为根目录，使用`outputText`模型参数来替换其`src/com/yupi/acm/MainTemplate.java`文件中的`Sum:`输出信息，并在同包下生成"挖好坑”的`MainTemplate.java.ftl`模板文件，以及在根目录下生成`meta.json`元信息文件。

实现步骤如下：

1.提供输入参数：包括生成器基本信息、原始项目目录、原始文件、模型参数

2.基于字符串替换算法，使用模型参数的字段名称来替换原始文件的指定内容，并使用替换后的内容来创建FTL动态模板文件

3.使用输入信息来创建`meta.json`元信息文件

在`template`包下新建`TemplateMaker.java`文件，并依次在main方法中实现上述步骤。

1)输入信息

要格外注意文件的路径(windows系统要对路径进行转义),代码如下:

```Java
private static final String PROJECT_PATH = "manneia-generator-demo-projects/acm-template";
// 一、输入信息
// 1. 项目的基本信息
String name = "acm-template-generator";
String description = "Acm 示例模板生成器";
String projectPath = Utils.getRootProperty();
String sourceRootPath = new File(projectPath).
        getParentFile()) + File.separator + PROJECT_PATH;
String fileInputPath = "src/com/manneia/acm/MainTemplate.java";

String fileOutputPath = fileInputPath + ".ftl";
// 3. 项目的模型参数信息
Meta.ModelConfig.ModelInfo modelInfo = new Meta.ModelConfig.ModelInfo();
modelInfo.setFieldName("outputText");
modelInfo.setType("String");
modelInfo.setDescription("输出信息");
modelInfo.setDefaultValue("sum= ");
```

2)   使用字符串替换生成模板文件

```Java
// 二、使用字符串替换,生成模板文件
String fileInputAbsolutePath = sourceRootPath + File.separator + fileInputPath;
String fileContent = FileUtil.readUtf8String(fileInputAbsolutePath);
String replacement = String.format("${%s}", modelInfo.getFieldName());
String newFileContent = StrUtil.replace(fileContent, "求和结果: ", replacement);
// 输出模板文件
String fileOutputAbsolutePath = sourceRootPath + File.separator + fileOutputPath;
FileUtil.writeUtf8String(newFileContent, fileOutputAbsolutePath);
```

上述代码中，使用`FileUtil.`*`readUtf8String`*快速读取文件内容，使用`StrUtil.`*`replace`*快速替换指定

的内容，最后使用`FileUtil.`*`writeUtf8String`*将替换后的内容快速写入到文件。

3)   生成配置文件

思路是先构造`Meta`对象并填充属性，再使用`Hutool`工具库的`JSONUtil.`*`toJsonPrettyStr`*方法将对象转为

格式化后的JSON字符串，最后再写入meta.json文件。

```Java
// 三、生成配置文件
String metaOutputPath = sourceRootPath + File.separator + "meta.json";
// 1. 构造配置参数对象
Meta meta = new Meta();
meta.setName(name);
meta.setDescription(description);
Meta.FileConfig fileConfig = new Meta.FileConfig();
fileConfig.setSourceRootPath(sourceRootPath);
Meta.FileConfig.FileInfo fileInfo = new Meta.FileConfig.FileInfo();
fileInfo.setInputPath(fileInputPath);
fileInfo.setOutputPath(fileOutputPath);
fileInfo.setType(FileTypeEnum.FILE.getValue());
fileInfo.setGenerateType(FileGenerateTypeEnum.DYNAMIC.getValue());
List<Meta.FileConfig.FileInfo> files = new ArrayList<>();
files.add(fileInfo);
fileConfig.setFiles(files);
meta.setFileConfig(fileConfig);
Meta.ModelConfig modelConfig = new Meta.ModelConfig();
List<Meta.ModelConfig.ModelInfo> modelInfoList = new ArrayList<>();
modelInfoList.add(modelInfo);
modelConfig.setModels(modelInfoList);

meta.setModelConfig(modelConfig);

// 2. 输出元信息文件
FileUtil.writeUtf8String(JSONUtil.toJsonPrettyStr(meta), metaOutputPath);
```

完整代码如下:

```Java
package com.manneia.maker.template;

import cn.hutool.core.date.DateUtil;
import cn.hutool.core.io.FileUtil;
import cn.hutool.core.util.IdUtil;
import cn.hutool.core.util.StrUtil;
import cn.hutool.json.JSONUtil;
import com.manneia.maker.meta.Meta;
import com.manneia.maker.meta.enums.FileGenerateTypeEnum;
import com.manneia.maker.meta.enums.FileTypeEnum;
import com.manneia.maker.utils.Utils;

import java.io.File;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

/**
 * 模板制作工具
 *
 * @author lkx
 */
public class TemplateMaker {

    private static final String PROJECT_PATH = "manneia-generator-demo-projects/acm-template";

    public static void main(String[] args) {
        // 指定原始项目路径
        String projectPath = Utils.getRootProperty();
        String originProjectPath = FileUtil.getAbsolutePath(new File(projectPath).
                getParentFile()) + File.separator + PROJECT_PATH;
        // 复制目录
        long id = IdUtil.getSnowflakeNextId();
        String tempDirPath = projectPath + File.separator + ".temp";
        String templatePath = tempDirPath + File.separator + id;
        if (!FileUtil.exist(templatePath)) {
            FileUtil.mkdir(tempDirPath);
        }
        FileUtil.copy(originProjectPath, templatePath, true);
        // 一、输入信息
        // 1. 项目的基本信息
        String name = "acm-template-generator";
        String description = "Acm 示例模板生成器";
        // 2. 项目的输入文件
        // 要挖坑的项目根目录
        String sourceRootPath = templatePath + File.separator + FileUtil.
                getLastPathEle(Paths.get(originProjectPath)).toString();
        // window系统需要对路径进行转义
        sourceRootPath = sourceRootPath.replaceAll("\\\\", "/");
        // 需要挖坑的文件
        String fileInputPath = "src/com/manneia/acm/MainTemplate.java";

        String fileOutputPath = fileInputPath + ".ftl";
        // 3. 项目的模型参数信息
        Meta.ModelConfig.ModelInfo modelInfo = new Meta.ModelConfig.ModelInfo();
        modelInfo.setFieldName("outputText");
        modelInfo.setType("String");
        modelInfo.setDescription("输出信息");
        modelInfo.setDefaultValue("sum= ");
        // 二、使用字符串替换,生成模板文件
        String fileInputAbsolutePath = sourceRootPath + File.separator + fileInputPath;
        String fileContent = FileUtil.readUtf8String(fileInputAbsolutePath);
        String replacement = String.format("${%s}", modelInfo.getFieldName());
        String newFileContent = StrUtil.replace(fileContent, "求和结果: ", replacement);
        // 输出模板文件
        String fileOutputAbsolutePath = sourceRootPath + File.separator + fileOutputPath;
        FileUtil.writeUtf8String(newFileContent, fileOutputAbsolutePath);
        // 三、生成配置文件
        String metaOutputPath = sourceRootPath + File.separator + "meta.json";
        // 1. 构造配置参数对象
        Meta meta = new Meta();
        meta.setName(name);
        meta.setDescription(description);
        Meta.FileConfig fileConfig = getFileConfig(sourceRootPath,
                fileInputPath, fileOutputPath);

        meta.setFileConfig(fileConfig);
        Meta.ModelConfig modelConfig = new Meta.ModelConfig();
        List<Meta.ModelConfig.ModelInfo> modelInfoList = new ArrayList<>();
        modelInfoList.add(modelInfo);
        modelConfig.setModels(modelInfoList);

        meta.setModelConfig(modelConfig);

        // 2. 输出元信息文件
        FileUtil.writeUtf8String(JSONUtil.toJsonPrettyStr(meta), metaOutputPath);
        // 4. 项目的输出规则
    }

    private static Meta.FileConfig getFileConfig(String sourceRootPath,
                                                 String fileInputPath, String fileOutputPath) {
        Meta.FileConfig fileConfig = new Meta.FileConfig();
        fileConfig.setSourceRootPath(sourceRootPath);
        Meta.FileConfig.FileInfo fileInfo = new Meta.FileConfig.FileInfo();
        fileInfo.setInputPath(fileInputPath);
        fileInfo.setOutputPath(fileOutputPath);
        fileInfo.setType(FileTypeEnum.FILE.getValue());
        fileInfo.setGenerateType(FileGenerateTypeEnum.DYNAMIC.getValue());
        List<Meta.FileConfig.FileInfo> files = new ArrayList<>();
        files.add(fileInfo);
        fileConfig.setFiles(files);
        return fileConfig;
    }
}
```

运行main方法测试执行,成功生成了需要的模板和元信息文件

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NTdhYjU5YjFkM2FhMWE3ZGE5NmViMzM3MjIyYWNmMTJfc3M4RXhjUkFyZXdIY0w0Tmc1SFNpeHJDNlZSbUVsSFNfVG9rZW46Wk52S2JPczc3b21JUEt4VUQwWWM5SzZRbk9nXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

1.  #### 工作空间隔离

想解决上面的问题，其实很简单。每次制作模板时，我们都不直接修改原始项目的任何文件，而是先复制原项目到

一个临时的、专门用于制作模板的目录，然后在该目录下完成文件的生成和处理。

可以将上述临时目录称为`工作空间`，每次模板制作应该属于不同的工作空间，互不影响。

我们约定将`maker`项目下的`.temp`临时目录作为工作空间的根目录，并且在项目的`·gitignore`文件中忽略该目录。

在`TemplateMaker`原有代码的基础上新增复制目录的逻辑：

1.  需要用户传入`originProjectPath`变量代表原始项目路径
2.  每次制作分配一个唯一id(使用雪花算法)，作为工作空间的名称，从而实现隔离
3.  通过`FileUtil.copy`复制目录
4.  修改变量`sourceRootPath`的值为复制后的工作空间内的项目根目录

```Java
String projectPath = Utils.getRootProperty();
String originProjectPath = FileUtil.getAbsolutePath(new File(projectPath).
        getParentFile()) + File.separator + PROJECT_PATH;
// 复制目录
long id = IdUtil.getSnowflakeNextId();
String tempDirPath = projectPath + File.separator + ".temp";
String templatePath = tempDirPath + File.separator + id;
if (!FileUtil.exist(templatePath)) {
    FileUtil.mkdir(tempDirPath);
}
FileUtil.copy(originProjectPath, templatePath, true);
// 一、输入信息
// 1. 项目的基本信息
String name = "acm-template-generator";
String description = "Acm 示例模板生成器";
// 2. 项目的输入文件
// 要挖坑的项目根目录
String sourceRootPath = templatePath + File.separator + FileUtil.
        getLastPathEle(Paths.get(originProjectPath)).toString();
// window系统需要对路径进行转义
sourceRootPath = sourceRootPath.replaceAll("\\\\", "/");
// 需要挖坑的文件
String fileInputPath = "src/com/manneia/acm/MainTemplate.java";

String fileOutputPath = fileInputPath + ".ftl";
```

再次测试执行，可以看到maker项目下新建了一个工作空间，并且生成了模板和元信息配置文件，如下图：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ODVkYzE2MjlmNjk0YWNmNDNlZTMzZTliM2NhYmE4NWZfdXRTR3JLT0NYa05NOU5rU2l0QVBpaEp5NVNJcUxBdlBfVG9rZW46UWJXa2J0SENFb3kxRnJ4RlY0SWNYZkZWbmpjXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

1.  #### 分步制作能力

一般来说，我们在制作模板时，不可能只“挖一个坑”，只允许用户自定义输入一个参数；也不可能一次性“挖完所有坑”。而是一步一步地替换参数、制作模板。

所以，我们的制作工具要有分步制作、追加配置的能力，具体要做到以下3点：

1.  输入过一次的信息，不用重复输入，比如基本的项目信息
2.  后续制作时，不用再次复制原始项目；而是可以在原有文件的基础上，多次追加或覆盖新的文件
3.  后续制作时，可以在原有配置的基础上，多次追加或覆盖配置

想要实现这个能力，我们首先要让制作工具“有状态”。

##### 有状态和无状态

什么是有状态？

是指程序或请求多次执行时，下一次执行保留对上一次执行的记忆。比如用户登录后服务器会记住用户的信息，下一次请求就能正常使用系统。

与之相对的是无状态。是指每次程序或请求护行，都像是第一次执行一样，没有任何历史信息。很多`Restful API`川会采用无状态的设计，能够节省服务器的资源占用。

##### 有状态实现

想实现有状态，往往需要2个要素：唯一标识和存储。

其实在上一步“工作空间隔离”中，我们已经给每个工作空间分配了一个唯一的id作为标识；并且将id作为工作空间的目录名称，相当于使用本地文件系统作为了id的存储。

那么我们只要在第一次制作时，生成唯一的id;然后在后续制作时，使用相同的d,就能找到之前的工作空间目

录，从而追加文件或配置。

修改`TemplateMake`r文件，新建`makeTemplate`方法，并将id作为参数，先实现id的生成逻辑。

```Java
private static long makeTemplate(Long id) {
    // 没有id 则生成
    if (id == null) {
        id = IdUtil.getSnowflakeNextId();
    }
    // 业务逻辑...
    return id;
}
```

##### 多次制作实现

如果根据id判断出并非首次制作，我们又应该做哪些调整呢？应该如何追加配置和文件呢？

这里我考虑到3点：

1.  非首次制作，不需要复制原始项目文件
2.  非首次制作，可以在已有模板的基础上再次挖坑
3.  非首次制作，不需要重复输入己有元信息，而是在此基础上覆盖和追加元信息配置
4.  非首次制作，不需要复制原始项目文件

```Java
long id = IdUtil.getSnowflakeNextId();
String tempDirPath = projectPath + File.separator + ".temp";
String templatePath = tempDirPath + File.separator + id;
if (!FileUtil.exist(templatePath)) {
    FileUtil.mkdir(tempDirPath);
    FileUtil.copy(originProjectPath, templatePath, true);
}
```

2)   非首次制作，可以在已有模板的基础上再次挖坑

由于制作好的模板文件名称就是在原始文件名称后增加`.ftl`后缀，所以我们可以将输出文件路径（包含`.ftl`后缀的路径)作为文件是否重复的判断条件。如果已有`.ftl`文件，表示不是第一次制作，可以在这个模板文件的基础上再去替换内容。

```Java
String fileInputAbsolutePath = sourceRootPath + File.separator + fileInputPath;
String fileOutputAbsolutePath = sourceRootPath + File.separator + fileOutputPath;
// 如果已有模板文件,表示不是第一次生成,则在原有模板的基础上再挖坑
String fileContent;
if (FileUtil.exist(fileOutputAbsolutePath)) {
    fileContent = FileUtil.readUtf8String(fileOutputAbsolutePath);
} else {
    fileContent = FileUtil.readUtf8String(fileInputAbsolutePath);
}
String replacement = String.format("${%s}", modelInfo.getFieldName());
String newFileContent = StrUtil.replace(fileContent, searchStr, replacement);

// 输出模板文件
FileUtil.writeUtf8String(newFileContent, fileOutputAbsolutePath);
```

3)   非首次制作，不需要重复输入己有元信息，而是在此基础上覆盖和追加元信息配置

和判断文件模板是否重复的逻辑一致，我们可以通过是否已存在`meta.json`配置文件来判断应该新增还是修改配置。

>   我们将fileInfo对象的构造移动到了前面,使得无论新增还是修改都是用该对象

```Java
// 三、生成配置文件
String metaOutputPath = sourceRootPath + File.separator + "meta.json";
// 文件配置信息
Meta.FileConfig fileConfig = new Meta.FileConfig();
fileConfig.setSourceRootPath(sourceRootPath);
Meta.FileConfig.FileInfo fileInfo = new Meta.FileConfig.FileInfo();
fileInfo.setInputPath(fileInputPath);
fileInfo.setOutputPath(fileOutputPath);
fileInfo.setType(FileTypeEnum.FILE.getValue());
fileInfo.setGenerateType(FileGenerateTypeEnum.DYNAMIC.getValue());
// 如果已有配置文件,表示不是第一次生成,则在原有配置的基础上进行修改
if (FileUtil.exist(metaOutputPath)) {
    Meta oldMeta = JSONUtil.toBean(FileUtil.readUtf8String(metaOutputPath), Meta.class);
    // 1. 追加配置参数
    List<Meta.FileConfig.FileInfo> fileInfoList = oldMeta.getFileConfig().getFiles();
    List<Meta.ModelConfig.ModelInfo> modelInfoList = oldMeta.getModelConfig().getModels();
    fileInfoList.add(fileInfo);
    modelInfoList.add(modelInfo);
    // 去重
    oldMeta.getFileConfig().setFiles(distinctFiles(fileInfoList));
    oldMeta.getModelConfig().setModels(distinctModels(modelInfoList));
    // 2. 生成元信息文件
    FileUtil.writeUtf8String(JSONUtil.toJsonPrettyStr(oldMeta), metaOutputPath);

} else {
    List<Meta.FileConfig.FileInfo> files = new ArrayList<>();
    files.add(fileInfo);
    fileConfig.setFiles(files);
    // 1. 构造配置参数对象
    newMeta.setFileConfig(fileConfig);
    Meta.ModelConfig modelConfig = new Meta.ModelConfig();
    List<Meta.ModelConfig.ModelInfo> modelInfoList = new ArrayList<>();
    modelInfoList.add(modelInfo);
    modelConfig.setModels(modelInfoList);

    newMeta.setModelConfig(modelConfig);

    // 2. 输出元信息文件
    FileUtil.writeUtf8String(JSONUtil.toJsonPrettyStr(newMeta), metaOutputPath);
}
```

一定注意,追加完配置后,需要去重!否则会出现多个一模一样的配置

文件信息根据输入路径`inputPath`去重,使用旧值覆盖新值

```Java
/**
 * 文件配置去重
 *
 * @param fileInfoList 文件配置
 * @return 返回去重后的文件配置
 */
private static List<Meta.FileConfig.FileInfo> distinctFiles(List<Meta.
        FileConfig.FileInfo> fileInfoList) {
    return new ArrayList<>(fileInfoList.stream().collect(Collectors.toMap(
            Meta.FileConfig.FileInfo::getInputPath,
            o -> o,
            (exist, replacement) -> replacement)).values());
}
```

上述代码中，用到了Java8的Stream API和Lambda表达式来简化代码，其中`Collectors.toMap`表示将

列表转换为Map,详细解释一下：

-   通过第一个参数(inputPath)作为key进行分组
-   通过第二个参数作为value存储值(`o->o`表示使用原对象作为value)
-   最后的`(e,r)->r`其实是`(exist,replacement)->replacement`的缩写，表示遇到重复的值是保留新值，返回exist表示保留旧值。

这样一来，相同key对应的文件信息只会保留一个，最后再取所有的values拿到所有的文件信息列表即可。

模型参数根据属性名称`fieldName`去重，使用新值覆盖旧值。和文件信息去重的实现方式完全致，代码如下：

```Java
/**
 * 模型配置去重
 *
 * @param modelInfoList 文件配置
 * @return 返回去重后的文件配置
 */
private static List<Meta.ModelConfig.ModelInfo> distinctModels(List<Meta.
        ModelConfig.ModelInfo> modelInfoList) {
    return new ArrayList<>(modelInfoList.stream().collect(Collectors.toMap(
            Meta.ModelConfig.ModelInfo::getFieldName,
            o -> o,
            (exist, replacement) -> replacement)).values());
}
```

然后修改生成配置文件的代码，使用去重方法，并将去重后的配置更新到元信息中：

```Java
if (FileUtil.exist(metaOutputPath)) {
    Meta oldMeta = JSONUtil.toBean(FileUtil.readUtf8String(metaOutputPath), Meta.class);
    // 1. 追加配置参数
    List<Meta.FileConfig.FileInfo> fileInfoList = oldMeta.getFileConfig().getFiles();
    List<Meta.ModelConfig.ModelInfo> modelInfoList = oldMeta.getModelConfig().getModels();
    fileInfoList.add(fileInfo);
    modelInfoList.add(modelInfo);
    // 去重
    oldMeta.getFileConfig().setFiles(distinctFiles(fileInfoList));
    oldMeta.getModelConfig().setModels(distinctModels(modelInfoList));
    // 2. 生成元信息文件
    FileUtil.writeUtf8String(JSONUtil.toJsonPrettyStr(oldMeta), metaOutputPath);

} else {
    List<Meta.FileConfig.FileInfo> files = new ArrayList<>();
    files.add(fileInfo);
    fileConfig.setFiles(files);
    // 1. 构造配置参数对象
    newMeta.setFileConfig(fileConfig);
    Meta.ModelConfig modelConfig = new Meta.ModelConfig();
    List<Meta.ModelConfig.ModelInfo> modelInfoList = new ArrayList<>();
    modelInfoList.add(modelInfo);
    modelConfig.setModels(modelInfoList);

    newMeta.setModelConfig(modelConfig);

    // 2. 输出元信息文件
    FileUtil.writeUtf8String(JSONUtil.toJsonPrettyStr(newMeta), metaOutputPath);
}
```

##### 抽象方法

由于我们在接下来的测试中，要多次传入不同的参数执行制作，所以可以先抽象出通用的方法，将所有之前我们在main方法中硬编码的值都作为方法的参数。包括`originProjectPath`(原始项目路径)、`inputFilePath`(要制作模板的输入文件相对路径)、`modellnfo`(模型信息)、`searchStr`(要替换的模板内容)等。

我们还要把所有基本信息配置直接用Meta类封装，可以节约方法的参数个数，比如：

```Java
String name = "acm-template-generator";
Stirng description = "Acm 示例模板生成器";
```

改为

```Java
Meta meta = new Meta();
meta.setName("acm-template-generator");
meta.setDescription("Acm 示例模板生成器");
```

如果非首次制作，我们还要能使用最后传入的meta对象更新元信息的基本配置。可以通过`BeanUtil.copyProperties`复制新对象的属性到老对象（如果属性为空则不复制），从而实现新老meta对象的合并。

代码如下：

```Java
Meta oldMeta = JSONUtil.toBean(FileUtil.readUtf8String(metaOutputPath), Meta.class);
BeanUtil.copyProperties(meta,oldMeta, CopyOptions.create().ignoreNullValue());
```

抽象方法后的完整代码:

```Java
/**
 * 制作模板
 *
 * @param newMeta           元信息对象
 * @param projectPath       项目根目录
 * @param originProjectPath 原始项目路径
 * @param fileInputPath     项目输入文件
 * @param modelInfo         模型配置
 * @param searchStr         替换字符串
 * @param id                文件id
 * @return 返回文件id
 */
private static long makeTemplate(Meta newMeta,
                                 String projectPath,
                                 String originProjectPath,
                                 String fileInputPath,
                                 Meta.ModelConfig.ModelInfo modelInfo,
                                 String searchStr,
                                 Long id) {
    // 没有id 则生成
    if (id == null) {
        id = IdUtil.getSnowflakeNextId();
    }
    // 业务逻辑...
    // 指定原始项目路径

    // 复制目录
    String tempDirPath = projectPath + File.separator + ".temp";
    String templatePath = tempDirPath + File.separator + id;
    if (!FileUtil.exist(templatePath)) {
        FileUtil.mkdir(tempDirPath);
        FileUtil.copy(originProjectPath, templatePath, true);
    }
    // 一、输入信息
    // 1. 项目的基本信息

    // 2. 项目的输入文件
    // 要挖坑的项目根目录
    String sourceRootPath = templatePath + File.separator + FileUtil.
            getLastPathEle(Paths.get(originProjectPath)).toString();
    // window系统需要对路径进行转义
    sourceRootPath = sourceRootPath.replaceAll("\\\\", "/");
    // 需要挖坑的文件


    String fileOutputPath = fileInputPath + ".ftl";
    // 3. 项目的模型参数信息

    // 二、使用字符串替换,生成模板文件
    String fileInputAbsolutePath = sourceRootPath + File.separator + fileInputPath;
    String fileOutputAbsolutePath = sourceRootPath + File.separator + fileOutputPath;
    // 如果已有模板文件,表示不是第一次生成,则在原有模板的基础上再挖坑
    String fileContent;
    if (FileUtil.exist(fileOutputAbsolutePath)) {
        fileContent = FileUtil.readUtf8String(fileOutputAbsolutePath);
    } else {
        fileContent = FileUtil.readUtf8String(fileInputAbsolutePath);
    }
    String replacement = String.format("${%s}", modelInfo.getFieldName());
    String newFileContent = StrUtil.replace(fileContent, searchStr, replacement);

    // 输出模板文件
    FileUtil.writeUtf8String(newFileContent, fileOutputAbsolutePath);
    // 三、生成配置文件
    String metaOutputPath = sourceRootPath + File.separator + "meta.json";
    // 文件配置信息
    Meta.FileConfig fileConfig = new Meta.FileConfig();
    fileConfig.setSourceRootPath(sourceRootPath);
    Meta.FileConfig.FileInfo fileInfo = new Meta.FileConfig.FileInfo();
    fileInfo.setInputPath(fileInputPath);
    fileInfo.setOutputPath(fileOutputPath);
    fileInfo.setType(FileTypeEnum.FILE.getValue());
    fileInfo.setGenerateType(FileGenerateTypeEnum.DYNAMIC.getValue());
    // 如果已有配置文件,表示不是第一次生成,则在原有配置的基础上进行修改
    if (FileUtil.exist(metaOutputPath)) {
        Meta oldMeta = JSONUtil.toBean(FileUtil.readUtf8String(metaOutputPath), Meta.class);
        BeanUtil.copyProperties(newMeta, oldMeta, CopyOptions.create().ignoreNullValue());
        newMeta = oldMeta;
        // 1. 追加配置参数
        List<Meta.FileConfig.FileInfo> fileInfoList = newMeta.getFileConfig().getFiles();
        List<Meta.ModelConfig.ModelInfo> modelInfoList = newMeta.getModelConfig().getModels();
        fileInfoList.add(fileInfo);
        modelInfoList.add(modelInfo);
        // 去重
        newMeta.getFileConfig().setFiles(distinctFiles(fileInfoList));
        newMeta.getModelConfig().setModels(distinctModels(modelInfoList));
        // 2. 生成元信息文件
    } else {
        List<Meta.FileConfig.FileInfo> files = new ArrayList<>();
        files.add(fileInfo);
        fileConfig.setFiles(files);
        // 1. 构造配置参数对象
        newMeta.setFileConfig(fileConfig);
        Meta.ModelConfig modelConfig = new Meta.ModelConfig();
        List<Meta.ModelConfig.ModelInfo> modelInfoList = new ArrayList<>();
        modelInfoList.add(modelInfo);
        modelConfig.setModels(modelInfoList);

        newMeta.setModelConfig(modelConfig);

        // 2. 输出元信息文件
    }
    FileUtil.writeUtf8String(JSONUtil.toJsonPrettyStr(newMeta), metaOutputPath);

    // 4. 项目的输出规则
    return id;
}
```

##### 测试

最后，在main方法中指定2套不同的模型参数信息作为测试数据，并调用makeTemplate方法。

```Java
public static void main(String[] args) {
        Meta meta = new Meta();
        meta.setName("acm-template-generator");
        meta.setDescription("Acm 示例模板生成器");
        String projectPath = Utils.getRootProperty();
        String originProjectPath = FileUtil.getAbsolutePath(new File(projectPath).
                getParentFile()) + File.separator + PROJECT_PATH;
        String fileInputPath = "src/com/manneia/acm/MainTemplate.java";
        // 输入模型参数
//        Meta.ModelConfig.ModelInfo modelInfo = new Meta.ModelConfig.ModelInfo();
//        modelInfo.setFieldName("outputText");
//        modelInfo.setType("String");
//        modelInfo.setDescription("输出信息");
//        modelInfo.setDefaultValue("sum= ");
        // 输入模型参数信息 第二次
        Meta.ModelConfig.ModelInfo modelInfo = new Meta.ModelConfig.ModelInfo();
        modelInfo.setFieldName("className");
        modelInfo.setType("String");
        // 替换变量
//        String str = "sum= ";
        String str = "MainTemplate";
        long id = 1766419318455816192L;
        long l = makeTemplate(meta,
                projectPath,
                originProjectPath,
                fileInputPath,
                modelInfo,
                str,
                id
        );
        System.out.println(l);
    }
```

第一次执行成功制作模板并生成元信息,返回了一个新的id

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MWU3MzczNzcwYjU1OWQ2NTJhYTIxMGQzZjNkYjUzZDFfR2lnb01BeXVDVElDbTZoMDVqMXlIUFhxMmlaTjBPbTRfVG9rZW46UkVHZGJ1WDJRb0RPcDN4emM3bmNTMnRhbllkXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

将得到的id作为`makeTemplate`方法的参数,修改传入的模型信息和替换变量

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YjM2MTI1MDNiMzljMGU5YTNlN2RhMWMxMTM1ODczY2Jfb29MSWVSTjluanJaSDFMazRxNlNWZlJtakVkakFrMEdfVG9rZW46QkVHNmJuNkdwb202WWl4VkhJMWNPM1p6blVOXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

然后再次执行,可以发现模板文件又多"挖了一个坑",并且元信息配置多了一个模型参数:

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NTBlZGJhZGYwYWY1ZDk0MDA1MzBlOTM5MzYzZmY0ZDNfUHVMNzMyMmdTM1Q5TmZqaG51emtnWVFucmk5cG1CU1FfVG9rZW46TzRCdmJ1QTB2bzduNnB4QWN0d2NBNjR1bk5kXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

##### 完整代码

`TemplateMaker`的完整代码:

```Java
package com.manneia.maker.template;

import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.bean.copier.CopyOptions;
import cn.hutool.core.io.FileUtil;
import cn.hutool.core.util.IdUtil;
import cn.hutool.core.util.StrUtil;
import cn.hutool.json.JSONUtil;
import com.manneia.maker.meta.Meta;
import com.manneia.maker.meta.enums.FileGenerateTypeEnum;
import com.manneia.maker.meta.enums.FileTypeEnum;
import com.manneia.maker.utils.Utils;

import java.io.File;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * 模板制作工具
 *
 * @author lkx
 */
public class TemplateMaker {

    private static final String PROJECT_PATH = "manneia-generator-demo-projects/acm-template";

    /**
     * 制作模板
     *
     * @param newMeta           元信息对象
     * @param projectPath       项目根目录
     * @param originProjectPath 原始项目路径
     * @param fileInputPath     项目输入文件
     * @param modelInfo         模型配置
     * @param searchStr         替换字符串
     * @param id                文件id
     * @return 返回文件id
     */
    private static long makeTemplate(Meta newMeta,
                                     String projectPath,
                                     String originProjectPath,
                                     String fileInputPath,
                                     Meta.ModelConfig.ModelInfo modelInfo,
                                     String searchStr,
                                     Long id) {
        // 没有id 则生成
        if (id == null) {
            id = IdUtil.getSnowflakeNextId();
        }
        // 业务逻辑...
        // 指定原始项目路径

        // 复制目录
        String tempDirPath = projectPath + File.separator + ".temp";
        String templatePath = tempDirPath + File.separator + id;
        if (!FileUtil.exist(templatePath)) {
            FileUtil.mkdir(tempDirPath);
            FileUtil.copy(originProjectPath, templatePath, true);
        }
        // 一、输入信息
        // 1. 项目的基本信息

        // 2. 项目的输入文件
        // 要挖坑的项目根目录
        String sourceRootPath = templatePath + File.separator + FileUtil.
                getLastPathEle(Paths.get(originProjectPath)).toString();
        // window系统需要对路径进行转义
        sourceRootPath = sourceRootPath.replaceAll("\\\\", "/");
        // 需要挖坑的文件


        String fileOutputPath = fileInputPath + ".ftl";
        // 3. 项目的模型参数信息

        // 二、使用字符串替换,生成模板文件
        String fileInputAbsolutePath = sourceRootPath + File.separator + fileInputPath;
        String fileOutputAbsolutePath = sourceRootPath + File.separator + fileOutputPath;
        // 如果已有模板文件,表示不是第一次生成,则在原有模板的基础上再挖坑
        String fileContent;
        if (FileUtil.exist(fileOutputAbsolutePath)) {
            fileContent = FileUtil.readUtf8String(fileOutputAbsolutePath);
        } else {
            fileContent = FileUtil.readUtf8String(fileInputAbsolutePath);
        }
        String replacement = String.format("${%s}", modelInfo.getFieldName());
        String newFileContent = StrUtil.replace(fileContent, searchStr, replacement);

        // 输出模板文件
        FileUtil.writeUtf8String(newFileContent, fileOutputAbsolutePath);
        // 三、生成配置文件
        String metaOutputPath = sourceRootPath + File.separator + "meta.json";
        // 文件配置信息
        Meta.FileConfig fileConfig = new Meta.FileConfig();
        fileConfig.setSourceRootPath(sourceRootPath);
        Meta.FileConfig.FileInfo fileInfo = new Meta.FileConfig.FileInfo();
        fileInfo.setInputPath(fileInputPath);
        fileInfo.setOutputPath(fileOutputPath);
        fileInfo.setType(FileTypeEnum.FILE.getValue());
        fileInfo.setGenerateType(FileGenerateTypeEnum.DYNAMIC.getValue());
        // 如果已有配置文件,表示不是第一次生成,则在原有配置的基础上进行修改
        if (FileUtil.exist(metaOutputPath)) {
            Meta oldMeta = JSONUtil.toBean(FileUtil.readUtf8String(metaOutputPath), Meta.class);
            BeanUtil.copyProperties(newMeta, oldMeta, CopyOptions.create().ignoreNullValue());
            newMeta = oldMeta;
            // 1. 追加配置参数
            List<Meta.FileConfig.FileInfo> fileInfoList = newMeta.getFileConfig().getFiles();
            List<Meta.ModelConfig.ModelInfo> modelInfoList = newMeta.getModelConfig().getModels();
            fileInfoList.add(fileInfo);
            modelInfoList.add(modelInfo);
            // 去重
            newMeta.getFileConfig().setFiles(distinctFiles(fileInfoList));
            newMeta.getModelConfig().setModels(distinctModels(modelInfoList));
            // 2. 生成元信息文件
        } else {
            List<Meta.FileConfig.FileInfo> files = new ArrayList<>();
            files.add(fileInfo);
            fileConfig.setFiles(files);
            // 1. 构造配置参数对象
            newMeta.setFileConfig(fileConfig);
            Meta.ModelConfig modelConfig = new Meta.ModelConfig();
            List<Meta.ModelConfig.ModelInfo> modelInfoList = new ArrayList<>();
            modelInfoList.add(modelInfo);
            modelConfig.setModels(modelInfoList);

            newMeta.setModelConfig(modelConfig);

            // 2. 输出元信息文件
        }
        FileUtil.writeUtf8String(JSONUtil.toJsonPrettyStr(newMeta), metaOutputPath);

        // 4. 项目的输出规则
        return id;
    }

    /**
     * 文件配置去重
     *
     * @param fileInfoList 文件配置
     * @return 返回去重后的文件配置
     */
    private static List<Meta.FileConfig.FileInfo> distinctFiles(List<Meta.
            FileConfig.FileInfo> fileInfoList) {
        return new ArrayList<>(fileInfoList.stream().collect(Collectors.toMap(
                Meta.FileConfig.FileInfo::getInputPath,
                o -> o,
                (exist, replacement) -> replacement)).values());
    }

    /**
     * 模型配置去重
     *
     * @param modelInfoList 文件配置
     * @return 返回去重后的文件配置
     */
    private static List<Meta.ModelConfig.ModelInfo> distinctModels(List<Meta.
            ModelConfig.ModelInfo> modelInfoList) {
        return new ArrayList<>(modelInfoList.stream().collect(Collectors.toMap(
                Meta.ModelConfig.ModelInfo::getFieldName,
                o -> o,
                (exist, replacement) -> replacement)).values());
    }

    public static void main(String[] args) {
        Meta meta = new Meta();
        meta.setName("acm-template-generator");
        meta.setDescription("Acm 示例模板生成器");
        String projectPath = Utils.getRootProperty();
        String originProjectPath = FileUtil.getAbsolutePath(new File(projectPath).
                getParentFile()) + File.separator + PROJECT_PATH;
        String fileInputPath = "src/com/manneia/acm/MainTemplate.java";
        // 输入模型参数
//        Meta.ModelConfig.ModelInfo modelInfo = new Meta.ModelConfig.ModelInfo();
//        modelInfo.setFieldName("outputText");
//        modelInfo.setType("String");
//        modelInfo.setDescription("输出信息");
//        modelInfo.setDefaultValue("sum= ");
        // 输入模型参数信息 第二次
        Meta.ModelConfig.ModelInfo modelInfo = new Meta.ModelConfig.ModelInfo();
        modelInfo.setFieldName("className");
        modelInfo.setType("String");
        // 替换变量
//        String str = "sum= ";
        String str = "MainTemplate";
        long id = 1766419318455816192L;
        long l = makeTemplate(meta,
                projectPath,
                originProjectPath,
                fileInputPath,
                modelInfo,
                str,
                id
        );
        System.out.println(l);
    }

}
```

至此，分步制作能力开发完成。你还可以试着多次修改meta的基本信息，也是可以正确更新的。

实现了这个能力后，我们不仅可以依次使用多个模型参数对同一个文件“挖坑”，也可以使用同一个模型参数依次对多个不同的文件挖坑。已经能够满足像ACM示例模板这种简单的项目了。

接下来，我们要给模板制作工具增加更多的功能，进一步提高使用的效率、并尽力满足Spring Boot模板项目代码生成器所需的能力。

1.  #### 更多功能实现

##### 1、单次制作多个模板文件

虽然现在模板制作工具可以通过多次护行来制作多个模板文件，但还是比较麻烦。对于我们之前提到的“批量替换项目下所有文件包名”的需求，可能需要制作几十个模板文件，难道要执行几十次么？

所以我们需要实现多模板文件同时制作的能力。

有2种方法：

1.  支持输入文件目录，同时处理该目录下的所有文件
2.  支特输入多个文件路径，同时处理这些文件

下面依次实现这两种方法。

###### 支持输入文件目录

实现思路很简单，之前我们已经能针对单个文件制作模板了。那么对于文件目录下的多个文件，只要循环遍历“单个文件制作模板”的操作，不就能轻松实现了么？

1)所以我们首先需要抽象出制作单个文件模板的方法`makeFileTemplate`,接受单个文件、模型信息、替换文本、sourceRootPath等参数，返回`Filelnfo`文件信息。

由于之前的输入文件路径是相对路径，而之后我们要扇历文件目录下的所有文件时，传来的文件是绝对路径。所以最好将方法接受的参数，由String类型的输入文件路径，修改为Fle类型的输入文件对象。但还要注意一点，在方法内部，要将绝对路径再转换为相对路径，以适配元信息文件的规测。

```Java
/**
 * 制作模板文件
 *
 * @param modelInfo      模型配置
 * @param searchStr      替换字符串
 * @param sourceRootPath 源文件路径
 * @param inputFile      输入文件
 * @return 返回文件配置
 */
private static Meta.FileConfig.FileInfo makeFileTemplate(Meta.ModelConfig.ModelInfo modelInfo,
                                                         String searchStr,
                                                         String sourceRootPath,
                                                         File inputFile) {
    // 注意一定是相对路径
    String fileInputAbsolutePath = inputFile.getAbsolutePath().
            replace("\\\\","/");
    String fileOutputAbsolutePath = fileInputAbsolutePath + ".ftl";
    // 文件输入输出相对路径
    String fileInputPath = fileInputAbsolutePath.replace(sourceRootPath + "/", "");
    String fileOutputPath = fileInputPath + ".ftl";
    // 3. 项目的模型参数信息
    // 二、使用字符串替换,生成模板文件
        // 如果已有模板文件,表示不是第一次生成,则在原有模板的基础上再挖坑
    String fileContent;
    if (FileUtil.exist(fileOutputAbsolutePath)) {
        fileContent = FileUtil.readUtf8String(fileOutputAbsolutePath);
    } else {
        fileContent = FileUtil.readUtf8String(fileInputAbsolutePath);
    }
    String replacement = String.format("${%s}", modelInfo.getFieldName());
    String newFileContent = StrUtil.replace(fileContent, searchStr, replacement);
    FileUtil.writeUtf8String(newFileContent, fileOutputAbsolutePath);
    // 文件配置信息
    Meta.FileConfig.FileInfo fileInfo = new Meta.FileConfig.FileInfo();
    fileInfo.setInputPath(fileInputPath);
    fileInfo.setType(FileTypeEnum.FILE.getValue());
    fileInfo.setGenerateType(FileGenerateTypeEnum.DYNAMIC.getValue());
    return fileInfo;
}
```

2)如果输入的文件路径是目录，那么使用Hutool的`loopFiles`方法递归遍历并获取目录下的所有文件列表。

修改`makeTemplate`方法中生成文件的相关代码，如下：

```Java
String sourceRootPath = templatePath + File.separator + FileUtil.
        getLastPathEle(Paths.get(originProjectPath)).toString();
// window系统需要对路径进行转义
sourceRootPath = sourceRootPath.replaceAll("\\\\", "/");
// 遍历文件
List<Meta.FileConfig.FileInfo> newFileInfoList = new ArrayList<>();
for (String inputFilePath : inputFilePathList) {
    String inputFileAbsolutePath = sourceRootPath + File.separator + inputFilePath;
    if (FileUtil.isDirectory(inputFileAbsolutePath)) {
        List<File> files = FileUtil.loopFiles(inputFileAbsolutePath);
        for (File file : files) {
            Meta.FileConfig.FileInfo fileInfo = makeFileTemplate(modelInfo, searchStr, sourceRootPath,
                    file);
            newFileInfoList.add(fileInfo);
        }
    } else {
        Meta.FileConfig.FileInfo fileInfo = makeFileTemplate(modelInfo, searchStr, sourceRootPath,
                new File(inputFileAbsolutePath));
        newFileInfoList.add(fileInfo);
    }
}

// 三、生成配置文件
String metaOutputPath = sourceRootPath + File.separator + "meta.json";
```

其中，使用`newFileInfoList`来存储所有文件的信息列表。

在生成配置文件时，以前是使用`fileInfoList.add`添加一个文件信息对象，现在要改为`fileInfoList.add`添加`newFileInfoList`文件信息列表。

修改后的代码如下：

```Java
// 三、生成配置文件
String metaOutputPath = sourceRootPath + File.separator + "meta.json";
Meta.FileConfig fileConfig = new Meta.FileConfig();
fileConfig.setSourceRootPath(sourceRootPath);
// 如果已有配置文件,表示不是第一次生成,则在原有配置的基础上进行修改
if (FileUtil.exist(metaOutputPath)) {
    Meta oldMeta = JSONUtil.toBean(FileUtil.readUtf8String(metaOutputPath), Meta.class);
    BeanUtil.copyProperties(newMeta, oldMeta, CopyOptions.create().ignoreNullValue());
    newMeta = oldMeta;
    // 1. 追加配置参数
    List<Meta.FileConfig.FileInfo> fileInfoList = newMeta.getFileConfig().getFiles();
    List<Meta.ModelConfig.ModelInfo> modelInfoList = newMeta.getModelConfig().getModels();
    fileInfoList.addAll(newFileInfoList);
    modelInfoList.add(modelInfo);
    // 去重
    newMeta.getFileConfig().setFiles(distinctFiles(fileInfoList));
    newMeta.getModelConfig().setModels(distinctModels(modelInfoList));
    // 2. 生成元信息文件
} else {
    List<Meta.FileConfig.FileInfo> files = new ArrayList<>();
    fileConfig.setFiles(files);
    files.addAll(newFileInfoList);
    // 1. 构造配置参数对象
    newMeta.setFileConfig(fileConfig);
    Meta.ModelConfig modelConfig = new Meta.ModelConfig();
    List<Meta.ModelConfig.ModelInfo> modelInfoList = new ArrayList<>();
    modelInfoList.add(modelInfo);
    modelConfig.setModels(modelInfoList);
    newMeta.setModelConfig(modelConfig);
}
```

3)修改main方法中传入的原始项目路径为`springboot-init`项目，输入文件路径改为`springbootinit`目录：

```Java
String originProjectPath = FileUtil.getAbsolutePath(new File(projectPath).
        getParentFile()) + File.separator + PROJECT_PATH;
String fileInputPath = "src/main/java/com/yupi/springbootinit";
```

然后执行测试,目录下的所有文件都生成了模板

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTY3MjQ3NzU0MmExNTI3MjFmZjIzMDYzYWNlOTM4OTVfUHNETk54amVCaFY0bzdOZWNEVFZUQnFJZ2xySjFnVFpfVG9rZW46R3ZiS2JWaU9Rb1FSTlN4R0tZMWNwT2NMbmRmXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

但是貌似生成的模板有点太多了。。。明明这些文件内没有任何内容被模型参数替换了，但也生成了模板？

4)所以这里我们需要优化下逻辑，如果某个文件内容没有被参数替换，那么就不生成模板，而是以静态生成的方

式记录到元信息配置中。

修改`makeFileTemplate`方法，通过对比替换前后的内容是否一致来更改生成方式。

注意，如果是静态生成，文件输出路径(outputPath)要设置为和输入路径(inputPath)相同。

修改后的方法代码如下（主要修改了后半段）：

```Java
/**
 * 制作模板文件
 *
 * @param modelInfo      模型配置
 * @param searchStr      替换字符串
 * @param sourceRootPath 源文件路径
 * @param inputFile      输入文件
 * @return 返回文件配置
 */
private static Meta.FileConfig.FileInfo makeFileTemplate(Meta.ModelConfig.ModelInfo modelInfo,
                                                         String searchStr,
                                                         String sourceRootPath,
                                                         File inputFile) {
    // 注意一定是相对路径
    String fileInputAbsolutePath = inputFile.getAbsolutePath().
            replace(sourceRootPath + "/", "");
    fileInputAbsolutePath = fileInputAbsolutePath.replaceAll("\\\\", "/");
    String fileInputPath = fileInputAbsolutePath.replace(sourceRootPath + "/", "");
    String fileOutputPath = fileInputPath + ".ftl";
    // 3. 项目的模型参数信息
    // 二、使用字符串替换,生成模板文件
    String fileOutputAbsolutePath = fileInputAbsolutePath + ".ftl";
    // 如果已有模板文件,表示不是第一次生成,则在原有模板的基础上再挖坑
    String fileContent;
    if (FileUtil.exist(fileOutputAbsolutePath)) {
        fileContent = FileUtil.readUtf8String(fileOutputAbsolutePath);
    } else {
        fileContent = FileUtil.readUtf8String(fileInputAbsolutePath);
    }
    String replacement = String.format("${%s}", modelInfo.getFieldName());
    String newFileContent = StrUtil.replace(fileContent, searchStr, replacement);
    // 文件配置信息
    Meta.FileConfig.FileInfo fileInfo = new Meta.FileConfig.FileInfo();
    fileInfo.setInputPath(fileInputPath);
    fileInfo.setType(FileTypeEnum.FILE.getValue());
    // 和原文件内容一致,表示没有修改. 静态生成
    if (fileContent.equals(newFileContent)) {
        // 输入路径 = 输出路径
        fileInfo.setOutputPath(fileInputPath);
        fileInfo.setGenerateType(FileGenerateTypeEnum.STATIC.getValue());
    } else {
        fileInfo.setOutputPath(fileOutputPath);
        fileInfo.setGenerateType(FileGenerateTypeEnum.DYNAMIC.getValue());
        FileUtil.writeUtf8String(newFileContent, fileOutputAbsolutePath);
    }
    return fileInfo;
}
```

5)更改main方法中的searchStr为BaseResponse,，然后再次执行测试.

效果符合预期，springbootinit包中，包含该字符串的文件才生成了模板：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MjAxOGYzMGRjMGIwYmRkZGE5MTI0MzNhYzFkZDViNjNfU05oZTh2WGxWcGNCbDNCYmtpbDFWMUo4UW1LYkJqRVNfVG9rZW46TEJDOGJlT215b0FxOWx4TWNERGNITTlTbjVlXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

查看生成的元信息配置文件，生成了符合要求的静态和动态文件配置：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MTFjN2FhZmZhMDdlZTdlOGE1ZmNhNjg2ZDgzMTViM2ZfQkh5OTQwMFRTZ3NmNlZHUzRpMVRHdmVZYm9XU20zeWRfVG9rZW46QUNtZGJlRURhbzUxTXR4WUFGb2NEbHF2bmpkXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

###### 支持输入多个文件

如果想在单次制作时支持输入多个文件，其实只要把makeTemplate方法的输入参数`inputFilePath`(单

数)改为inputFilePathList(复数)，再多加一层循环处理即可。

修改makeTemplate方法中生成文件模板的代码如下：

```Java
// 遍历文件
List<Meta.FileConfig.FileInfo> newFileInfoList = new ArrayList<>();
for (String inputFilePath : inputFilePathList) {
    String inputFileAbsolutePath = sourceRootPath + File.separator + inputFilePath;
    if (FileUtil.isDirectory(inputFileAbsolutePath)) {
        List<File> files = FileUtil.loopFiles(inputFileAbsolutePath);
        for (File file : files) {
            Meta.FileConfig.FileInfo fileInfo = makeFileTemplate(modelInfo, searchStr, sourceRootPath,
                    file);
            newFileInfoList.add(fileInfo);
        }
    } else {
        Meta.FileConfig.FileInfo fileInfo = makeFileTemplate(modelInfo, searchStr, sourceRootPath,
                new File(inputFileAbsolutePath));
        newFileInfoList.add(fileInfo);
    }
}
```

然后修改main方法中的测试条件为文件列表，验证效果：

```Java
String fileInputPath1 = "src/main/java/com/yupi/springbootinit/common";
String fileInputPath2 = "src/main/java/com/yupi/springbootinit/controller";
List<String> inputFilePathList = Arrays.asList(fileInputPath1, fileInputPath2);
```

结果符合预期,同时将多个指定目录下的文件制作成了模板

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YjFlZDE3YjE2NTVmODI4NmQ5NzlkYTgwYTlkYWI0N2VfaHlFUjdSbVQ4OGJ0VDFTZTFONVBZSVo3ejJsQXhRTU5fVG9rZW46Uk1vT2JLeXJWb3p2blF4dm9sNWNZZ05DbkVDXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

##### 2、文件过滤

回忆下我们之前梳理的Spring Boot模板生成器需要的一个功能：

>   需求：控制是否生成帖子相关功能
>
>   实现思路：允许用户输入一个开关参数来控制帅帖子功能相关的文件是否生成，比如PostController、PostService、.PostMapper、.PostMapper.xml、Post实体类等。
>
>   通用能力：某个范围下的多个指定文件挖坑=>绑定同个参数

为了实现这个需求，我们要同时对多个名称包含Po5t的文件进行处理。由于这些文件分散在不同的目录中，我

们没有办法通过直接指定一个目录完成制作。单次制作时输入多个文件是可行的提效方式，但如果文件数量再多一

些，依次去写文件的路径也会成为一种麻烦。

有没有更优雅的方式呢？

答案是肯定的，想想我们平时查找文件时会怎么办？肯定是输入一些关键词来过滤文件对吧。

没错，我们可以给模板制作工具增加**文件过滤**功能，通过多种不同的过滤方式帮助用户选择文件，更灵活地完成

批量模板制作。

###### 文件过滤机制设计

文件过滤可以有很多种不同的配置方式，鱼皮梳理到归纳了2类配置：

-   过滤范围：根据文件名称、或者文件内容过滤。
-   过滤规则：包含contains、前缀匹配startsWith、后缀匹配endsWith、正则regex、相等equals。.

由于制作工具已经支特输入多个文件/目录，所以其实每个文件/目泉都可以指定自己的过滤规则，而且能同时

指定多条过滤规则（必须同时满足才保留），进一步提高灵活性。

由于制作工具已经支特输入多个文件/目录，所以其实每个文件/目录都可以指定自己的过滤规则，而且能同时指定多条过滤规则（必须同时满足才保留），进一步提高灵活性。

参考文件过滤机制的JSON结构如下:

```JSON
{
  "files": [
      "path": "文件目录路径",
      "filters": [
          "range": "filedName",
          "rule": "regex",
          "value": ".*lala.*"
      ]
  ]
}
```

上面的SON表示：该文件的名称必须符合正则并且内容必须包含haha。

通过这种设计，可以非常灵活地筛选文件。如果想使用or逻辑（有一个过滤条件符合要求就保留），可以定义多个重复的file,并且每个file指定一个过滤条件来实现。哪怕同时满足了多个过滤器，我们的去重逻辑也能搞定。

###### 开发实现

1)设计好了机制后，我们可以编写对应的配置类。

在`template.model`包下新建`FileFilterConfig`类，对应上面设计好的JSON结构。

```Java
package com.manneia.maker.template.model;

import lombok.Builder;
import lombok.Data;

/**
 * 文件过滤配置
 *
 * @author lkx
 */
@Data
@Builder
public class FileFilterConfig {
    /**
     * 过滤范围
     */
    private String range;

    /**
     * 过滤规则
     */
    private String rule;

    /**
     * 过滤值
     */
    private String value;
}
```

在`template.model`包下新建`TemplateMakerFileConfig`类，用来封装所有和文件相关的配置。

代码如下：

```Java
package com.manneia.maker.template.model;

import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * @author lkx
 */
@Data
public class TemplateMakerFileConfig {

    private List<FileInfoConfig> files;

    @NoArgsConstructor
    @Data
    public static class FileInfoConfig {
        private String path;

        private List<FileFilterConfig> filterConfigList;
    }
}
```

2)针对过滤配置中的枚举值，编写对应的枚举类

在`template.enums`包下新建`FileFilterRangeEnum`枚举类，表示文件过滤范围枚举。需要提供根据`value`获取枚举的方法，便于根据字符串获取对应的枚举。

```Java
package com.manneia.maker.template.model.enums;

import cn.hutool.core.util.ObjectUtil;
import lombok.Getter;

/**
 * 文件过滤范围枚举
 *
 * @author lkx
 */
@Getter
public enum FileFilterRangeEnum {
    FILE_NAME("文件名称", "fileName"),
    FILE_CONTENT("文件内容", "fileContent");

    private final String text;

    private final String value;

    FileFilterRangeEnum(String text, String value) {
        this.text = text;
        this.value = value;
    }

    /**
     * 根据value获取枚举
     *
     * @param value 值
     * @return 返回对应的枚举
     */
    public static FileFilterRangeEnum getEnumByValue(String value) {
        if (ObjectUtil.isEmpty(value)) {
            return null;
        }
        for (FileFilterRangeEnum item : FileFilterRangeEnum.values()) {
            if (item.getValue().equals(value)) {
                return item;
            }
        }
        return null;
    }
}
```

在`template.enums`包下再新建`FileFilterRuleEnum`枚举类，表示文件过滤规则枚举。

```Java
package com.manneia.maker.template.model.enums;

import cn.hutool.core.util.ObjectUtil;
import lombok.Getter;

/**
 * 文件过滤规则枚举
 *
 * @author lkx
 */
@Getter
public enum FileFilterRuleEnum {
    CONTAINS("包含", "contains"),
    STARTS_WITH("前缀匹配", "startWith"),
    ENDS_WITH("后缀匹配", "endsWith"),
    REGEX("正则", "regex"),
    EQUALS("相等", "equals");

    private final String text;

    private final String value;

    FileFilterRuleEnum(String text, String value) {
        this.text = text;
        this.value = value;
    }

    /**
     * 根据value获取枚举
     *
     * @param value 值
     * @return 返回对应的枚举
     */
    public static FileFilterRuleEnum getEnumByValue(String value) {
        if (ObjectUtil.isEmpty(value)) {
            return null;
        }
        for (FileFilterRuleEnum item : FileFilterRuleEnum.values()) {
            if (item.getValue().equals(value)) {
                return item;
            }
        }
        return null;
    }
}
```

3)有了配置类后，我们来开发文件过滤功能

在`template`包下新建`FileFilte`r类，首先开发针对单个文件过滤的方法`doSingleFileFilter`.实现思路是遍历传入的文件过滤配置列表，并按照规则进行校验，如果有一个过滤配置不满足，就返回`false`表示不保留该文件，反之为`true`表示通过所有校验。

```Java
/**
 * 单个文件过滤
 *
 * @param filterConfigList 过滤配置集合
 * @param file             过滤文件
 * @return 返回是否保留
 */
public static boolean doSingleFilter(List<FileFilterConfig> filterConfigList, File file) {
    String fileName = file.getName();
    String fileContent = FileUtil.readUtf8String(file);
    // 所有过滤器校验结束后的结果
    boolean result = true;
    if (CollUtil.isEmpty(filterConfigList)) {
        return true;
    }
    for (FileFilterConfig fileFilterConfig : filterConfigList) {
        if (fileFilterConfig == null) {
            return false;
        }
        String range = fileFilterConfig.getRange();
        String rule = fileFilterConfig.getRule();
        String value = fileFilterConfig.getValue();
        FileFilterRangeEnum fileFilterRangeEnum = FileFilterRangeEnum.getEnumByValue(range);
        if (fileFilterRangeEnum == null) {
            continue;
        }
        // 要过滤的内容
        String content = fileName;
        switch (fileFilterRangeEnum) {
            case FILE_NAME:
                content = fileName;
                break;
            case FILE_CONTENT:
                content = fileContent;
                break;
            default:
        }
        FileFilterRuleEnum fileFilterRuleEnum = FileFilterRuleEnum.getEnumByValue(rule);
        if (fileFilterRuleEnum == null) {
            continue;
        }
        switch (fileFilterRuleEnum) {
            case CONTAINS:
                result = content.contains(value);
                break;
            case STARTS_WITH:
                result = content.startsWith(value);
                break;
            case ENDS_WITH:
                result = content.endsWith(value);
                break;
            case REGEX:
                result = content.matches(value);
                break;
            case EQUALS:
                result = content.equals(value);
            default:
        }
    }
    return result;
}
```

然后编写过滤器的主方法doFilter，方法接受filePath文件路径参数，支特传入文件或泪录，能够同时对多个文件进行过滤。

实现思路很简单，通过Hutool的`FileUtil.loopFiles`获取到所有文件列表，再依次调用过滤单个文件的方法即可。

>   即使传入的是单个文件，也能通过该方法获取到例表，保持一致

```Java
/**
 * 过滤某个文件或目录,返回文件列表
 *
 * @param filterConfigList 过滤配置集合
 * @param filePath         过滤文件路径
 * @return 返回过滤后的文件
 */
public static List<File> doFilter(List<FileFilterConfig> filterConfigList, String filePath) {
    // 根据路径获取所有文件
    List<File> fileList = FileUtil.loopFiles(filePath);
    return fileList.stream().filter(file ->
                    doSingleFilter(filterConfigList, file))
            .collect(Collectors.toList());
}
```

`FileFiter`的完整代码如下:

```Java
package com.manneia.maker.template;

import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.io.FileUtil;
import com.manneia.maker.template.model.FileFilterConfig;
import com.manneia.maker.template.model.enums.FileFilterRangeEnum;
import com.manneia.maker.template.model.enums.FileFilterRuleEnum;

import java.io.File;
import java.util.List;
import java.util.stream.Collectors;

/**
 * @author lkx
 */
public class FileFilter {

    /**
     * 单个文件过滤
     *
     * @param filterConfigList 过滤配置集合
     * @param file             过滤文件
     * @return 返回是否保留
     */
    public static boolean doSingleFilter(List<FileFilterConfig> filterConfigList, File file) {
        String fileName = file.getName();
        String fileContent = FileUtil.readUtf8String(file);
        // 所有过滤器校验结束后的结果
        boolean result = true;
        if (CollUtil.isEmpty(filterConfigList)) {
            return true;
        }
        for (FileFilterConfig fileFilterConfig : filterConfigList) {
            if (fileFilterConfig == null) {
                return false;
            }
            String range = fileFilterConfig.getRange();
            String rule = fileFilterConfig.getRule();
            String value = fileFilterConfig.getValue();
            FileFilterRangeEnum fileFilterRangeEnum = FileFilterRangeEnum.getEnumByValue(range);
            if (fileFilterRangeEnum == null) {
                continue;
            }
            // 要过滤的内容
            String content = fileName;
            switch (fileFilterRangeEnum) {
                case FILE_NAME:
                    content = fileName;
                    break;
                case FILE_CONTENT:
                    content = fileContent;
                    break;
                default:
            }
            FileFilterRuleEnum fileFilterRuleEnum = FileFilterRuleEnum.getEnumByValue(rule);
            if (fileFilterRuleEnum == null) {
                continue;
            }
            switch (fileFilterRuleEnum) {
                case CONTAINS:
                    result = content.contains(value);
                    break;
                case STARTS_WITH:
                    result = content.startsWith(value);
                    break;
                case ENDS_WITH:
                    result = content.endsWith(value);
                    break;
                case REGEX:
                    result = content.matches(value);
                    break;
                case EQUALS:
                    result = content.equals(value);
                default:
            }
        }
        return result;
    }

    /**
     * 过滤某个文件或目录,返回文件列表
     *
     * @param filterConfigList 过滤配置集合
     * @param filePath         过滤文件路径
     * @return 返回过滤后的文件
     */
    public static List<File> doFilter(List<FileFilterConfig> filterConfigList, String filePath) {
        // 根据路径获取所有文件
        List<File> fileList = FileUtil.loopFiles(filePath);
        return fileList.stream().filter(file ->
                        doSingleFilter(filterConfigList, file))
                .collect(Collectors.toList());
    }
}
```

4)   模板制作工具类使用过滤器

将`makeTemplate`方法接受的`inputFilePathList`参数改为我们新封装的`TemplateMakerFileConfig`类，相当于同时传入了文件列表和过滤规则。

```Java
private static long makeTemplate(Meta newMeta,
                                 String projectPath,
                                 String originProjectPath,
                                 TemplateMakerFileConfig templateMakerFileConfig,
                                 Meta.ModelConfig.ModelInfo modelInfo,
                                 String searchStr,
                                 Long id) {}
```

然后修改遍历输入文件的代码，改为遍历`fileConfigInfoList`获取文件信息：

```Java
String sourceRootPath = templatePath + File.separator + FileUtil.
        getLastPathEle(Paths.get(originProjectPath)).toString();
// window系统需要对路径进行转义
sourceRootPath = sourceRootPath.replaceAll("\\\\", "/");
List<TemplateMakerFileConfig.FileInfoConfig> fileInfoConfigList =
        templateMakerFileConfig.getFiles();
// 遍历文件
List<Meta.FileConfig.FileInfo> newFileInfoList = new ArrayList<>();
for (TemplateMakerFileConfig.FileInfoConfig fileInfoConfig : fileInfoConfigList) {
    String inputFilePath = fileInfoConfig.getPath();
    String inputFileAbsolutePath = sourceRootPath + File.separator + inputFilePath;
    // 传入绝对路径
    // 得到过滤后的文件列表
    List<File> fileList = FileFilter.doFilter(fileInfoConfig.
            getFilterConfigList(), inputFileAbsolutePath);

    for (File file : fileList) {
        Meta.FileConfig.FileInfo fileInfo = makeFileTemplate(modelInfo, searchStr, sourceRootPath,
                file);
        newFileInfoList.add(fileInfo);
    }
}
```

应用过滤器。将文件信息配置中的**相对路径转化为绝对路径**作为调用过滤器的参数，并通过过滤器获取到所有文

件列表（注意，这里不可能是目录），再遍历文件列表来制作模板。

修改生成文件模板的部分代码，如下：

```Java
List<Meta.FileConfig.FileInfo> newFileInfoList = new ArrayList<>();
for (TemplateMakerFileConfig.FileInfoConfig fileInfoConfig : fileInfoConfigList) {
    String inputFilePath = fileInfoConfig.getPath();
    String inputFileAbsolutePath = sourceRootPath + File.separator + inputFilePath;
    // 传入绝对路径
    // 得到过滤后的文件列表
    List<File> fileList = FileFilter.doFilter(fileInfoConfig.
            getFilterConfigList(), inputFileAbsolutePath);

    for (File file : fileList) {
        Meta.FileConfig.FileInfo fileInfo = makeFileTemplate(modelInfo, searchStr, sourceRootPath,
                file);
        newFileInfoList.add(fileInfo);
    }
}
```

5)在main方法中编写文件过滤测试代码，只处理common包下文件名称包含Base的文件和controller包

下的文件。

在main方法的最后追加代码，如下：

```Java
// 文件过滤配置
TemplateMakerFileConfig.FileInfoConfig fileInfoConfig = new TemplateMakerFileConfig.
        FileInfoConfig();
fileInfoConfig.setPath(fileInputPath1);
List<FileFilterConfig> filterConfigList = new ArrayList<>();
FileFilterConfig fileFilterConfig = FileFilterConfig.builder()
        .range(FileFilterRangeEnum.FILE_NAME.getValue())
        .rule(FileFilterRuleEnum.CONTAINS.getValue())
        .value("Base")
        .build();
filterConfigList.add(fileFilterConfig);
fileInfoConfig.setFilterConfigList(filterConfigList);
TemplateMakerFileConfig.FileInfoConfig fileInfoConfig1 = new TemplateMakerFileConfig.
        FileInfoConfig();
fileInfoConfig1.setPath(fileInputPath2);
List<TemplateMakerFileConfig.FileInfoConfig> fileInfoConfigList = Arrays.asList(fileInfoConfig,
        fileInfoConfig1);
TemplateMakerFileConfig templateMakerFileConfig = new TemplateMakerFileConfig();
templateMakerFileConfig.setFiles(fileInfoConfigList);
long projectId = makeTemplate(meta,
        projectPath,
        originProjectPath,
        templateMakerFileConfig,
        modelInfo,
        str,
        null);
System.out.println(projectId);
```

执行测试,只有`BaseResponse.java`生成了模板文件

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDNmMmMyMTQ4MmQxMTA3OTM1ZGI3NzJkN2YyYmVmZTRfVmIzQzk1UDRVUnJkSzJhUmtFTVRCaExkZXF4U2c0cWlfVG9rZW46Q1A2bGJXanZ0b2ZINDR4djJ4VGNCQXIwbnljXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

生成的元信息配置也没有多余的文件

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NTEwZmRkNmFlMDVlODAzMDY1M2U0NDhmMTc1YTI2MjlfS3FSMW4wbXRhY241cDlMZEJtUnNnelBKSFA1eTRVcEVfVG9rZW46R2daaGJoQTdKbzQ3ZkN4alBiOWNKeHRpbnRjXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

##### 3、文件分组

###### 实现思路

怎么实现呢？

我们现在已经能够单次制作多个文件了，而且根据用户习惯，同一次制作的多个文件更有可能属于同一组。那么其实我们不用让用户再手动配置如何分组了，可以自动分组。

有2种分组策略：

1.  一个文件信息配置(`FilelnfoConfig`)对应一次分组。如果传入的path是目录，则目录下的所有文件为同组。
2.  一个完整的文件配置(`TemplateMakerFileConfig`)对应一次分组。即配置files列表中的所有文件都属于同组。

这里鱼皮选择第2种方案。原因是从需求出发，对于“要用一个参数控制帖子相关的文件是否生成”的需求，有可能要把跨目录下的文件设置为一个组。第2种方案会更灵活。

###### 开发实现

1)首先给`TemplateMakerFileConfig`增加分组配置，和之前Meta元信息实体类的分组字段一对应。

代码如下：

```Java
package com.manneia.maker.template.model;

import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * @author lkx
 */
@Data
public class TemplateMakerFileConfig {

    private List<FileInfoConfig> files;

    private FileGroupConfig fileGroupConfig;
    @NoArgsConstructor
    @Data
    public static class FileInfoConfig {
        private String path;

        private List<FileFilterConfig> filterConfigList;
    }

    @Data
    public static class FileGroupConfig {
        private String condition;

        private String groupKey;

        private String groupName;
    }
}
```

2)在`TemplateMaker`的`makeTemplate`方法中增加文件组相关代码，思路是将本次得到的所有文件信息都放到同一个分组下。

在"生成配置文件”前增加如下代码：

```Java
// 如果是文件组
TemplateMakerFileConfig.FileGroupConfig fileGroupConfig = templateMakerFileConfig.
        getFileGroupConfig();
if (fileGroupConfig != null) {
    String condition = fileGroupConfig.getCondition();
    String groupKey = fileGroupConfig.getGroupKey();
    String groupName = fileGroupConfig.getGroupName();
    // 新增分组配置
    Meta.FileConfig.FileInfo groupFileInfo = new Meta.FileConfig.FileInfo();
    groupFileInfo.setType(FileTypeEnum.GROUP.getValue());
    groupFileInfo.setCondition(condition);
    groupFileInfo.setGroupKey(groupKey);
    groupFileInfo.setGroupName(groupName);
    // 文件全放到一个分组内
    groupFileInfo.setFiles(newFileInfoList);
    newFileInfoList = new ArrayList<>();
    newFileInfoList.add(groupFileInfo);
}
```

3)   在main方法中增加分组测试数据,代码如下:

```Java
// 分组配置
TemplateMakerFileConfig.FileGroupConfig fileGroupConfig = new TemplateMakerFileConfig.
        FileGroupConfig();
fileGroupConfig.setCondition("outputText");
fileGroupConfig.setGroupKey("test");
fileGroupConfig.setGroupName("测试分组");
templateMakerFileConfig.setFileGroupConfig(fileGroupConfig);
```

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=OTAyMTkwZDc3MzIyNzFlZGYxMGNjMDk2OTExYWUzMWZfUjh3S1JNbTVqZ1BHd0hYblRNNm93Wjd4QWljcWlidXpfVG9rZW46QUhNOWJicDBpb1o1RE14UFFtU2N3aXZzbjFmXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

###### 追加配置能力

虽然已经实现了文件分组配置的生成，但是实际制作模板的过程中，我们可能没办法一步到位，而是希望能多次制

作模板，并将文件追加到之前已有的分组下。

也就是说，文件分组要能支持多次制作时追加配置的能力，可以增加新的分组、也可以在同分组下新增文件。

1)让我们先来明确下需求。

举个例子，假设第1次制作得到的分组配置如下：

```JSON
"files": [
    {
        "type": "group",
        "condition": "outputText",
        "groupKey": "test",
        "groupName": "测试分组",
        "files": [
            {
                "inputPath": "src/main/java/com/yupi/springbootinit/common/BaseResponse.java",
                "outputPath": "src/main/java/com/yupi/springbootinit/common/BaseResponse.java.ftl",
                "type": "file",
                "generateType": "dynamic"
            },
            {
                "inputPath": "src/main/java/com/yupi/springbootinit/controller/PostController.java",
                "outputPath": "src/main/java/com/yupi/springbootinit/controller/PostController.java.ftl",
                "type": "file",
                "generateType": "dynamic"
            },
            {
                "inputPath": "src/main/java/com/yupi/springbootinit/controller/UserController.java",
                "outputPath": "src/main/java/com/yupi/springbootinit/controller/UserController.java.ftl",
                "type": "file",
                "generateType": "dynamic"
            }
        ]
    }
]
```

第二次制作得到的分组配置如下:

```JSON
"files": [
    {
        "type": "group",
        "condition": "outputText",
        "groupKey": "test",
        "groupName": "测试分组",
        "files": [
            {
                "inputPath": "src/main/java/com/yupi/springbootinit/common/BaseResponse.java",
                "outputPath": "src/main/java/com/yupi/springbootinit/common/BaseResponse.java.ftl",
                "type": "file",
                "generateType": "dynamic"
            },
            {
                "inputPath": "src/main/java/com/yupi/springbootinit/common/ResultUitls.java",
                "outputPath": "src/main/java/com/yupi/springbootinit/common/ResultUitls.java.ftl",
                "type": "file",
                "generateType": "dynamic"
            }
        ]
    }
]
```

由于两个分组的`groupKey`相同，视为同一个组，需要将第2次得到的分组内的所有文件和之前分组内的文件进行合并去重。得到如下配置：

```JSON
"files": [
    {
        "type": "group",
        "condition": "outputText",
        "groupKey": "test",
        "groupName": "测试分组",
        "files": [
            {
                "inputPath": "src/main/java/com/yupi/springbootinit/common/BaseResponse.java",
                "outputPath": "src/main/java/com/yupi/springbootinit/common/BaseResponse.java.ftl",
                "type": "file",
                "generateType": "dynamic"
            },
            {
                "inputPath": "src/main/java/com/yupi/springbootinit/common/ResultUitls.java",
                "outputPath": "src/main/java/com/yupi/springbootinit/Uitls/ResultUitls.java.ftl",
                "type": "file",
                "generateType": "dynamic"
            },
                        {
                "inputPath": "src/main/java/com/yupi/springbootinit/Controller/UserConttoller.java",
                "outputPath": "src/main/java/com/yupi/springbootinit/Controller/UserConttoller.java.ftl",
                "type": "file",
                "generateType": "dynamic"
            },
            {
                "inputPath": "src/main/java/com/yupi/springbootinit/Controller/PostConttoller.java",
                "outputPath": "src/main/java/com/yupi/springbootinit/Controller/PostConttoller.java.ftl",
                "type": "file",
                "generateType": "dynamic"
            }
        ]
    }
]
```

2)明确需求后，让我们来梳理下文件分组去重的实现流程，分为以下步骤：

1.  将所有文件配置(filelnfo)分为有分组的和无分组的
2.  对于有分组的文件配置，如果有相同的分组，同分组内的文件进行合并(merge),不同分组可同时保留
3.  创建新的文件配置列表（结果列表），先将合并后的分组添加到结果列表
4.  再将无分组的文件配置列表添加到结果列表

3)根据上述步骤，编写代码实现。

```Java
/**
 * 文件配置去重
 *
 * @param fileInfoList 文件配置
 * @return 返回去重后的文件配置
 */
private static List<Meta.FileConfig.FileInfo> distinctFiles(List<Meta.
        FileConfig.FileInfo> fileInfoList) {
    // 同分组内文件 merge 不同分组文件 保留

    // 1. 有分组的,以组为单位划分
    Map<String, List<Meta.FileConfig.FileInfo>> groupKeyFileInfoListMap = fileInfoList.stream()
            .filter(fileInfo -> StrUtil.isNotBlank(fileInfo.getGroupKey()))
            .collect(Collectors.groupingBy(Meta.FileConfig.FileInfo::getGroupKey));
    // 2. 同组内的文件配置合并
    Map<String, Meta.FileConfig.FileInfo> groupKeyMergeFileInfoMap = new HashMap<>();
    for (Map.Entry<String, List<Meta.FileConfig.FileInfo>> entry :
            groupKeyFileInfoListMap.entrySet()) {
        List<Meta.FileConfig.FileInfo> tempFileInfoList = entry.getValue();
        List<Meta.FileConfig.FileInfo> newFileInfoList = new ArrayList<>(tempFileInfoList
                .stream()
                .flatMap(fileInfo -> fileInfo.getFiles().stream())
                .collect(Collectors.toMap(Meta.FileConfig.FileInfo::getInputPath,
                        o -> o, (e, r) -> r)).values());
        // 使用新的group 配置
        Meta.FileConfig.FileInfo newFileInfo = CollUtil.getLast(tempFileInfoList);
        newFileInfo.setFiles(newFileInfoList);
        String groupKey = entry.getKey();
        groupKeyMergeFileInfoMap.put(groupKey, newFileInfo);
    }
    // 3. 将文件分组添加到结果列表
    List<Meta.FileConfig.FileInfo> resultList = new ArrayList<>(
            groupKeyMergeFileInfoMap.values()
    );
    // 4. 将未分组的文件添加到结果列表
    List<Meta.FileConfig.FileInfo> noGroupFileInfoList = fileInfoList.stream()
            .filter(fileInfo -> StrUtil.isBlank(fileInfo.getGroupKey()))
            .collect(Collectors.toList());
    resultList.addAll(new ArrayList<>(noGroupFileInfoList.stream()
            .collect(Collectors.toMap(Meta.FileConfig.FileInfo::getInputPath,
                    o->o,
                    (e,r)->r)).values()));
    return resultList;
}
```

4)   测试验证

修改main方法中的`fileInputPath2`,指定一个新目录:

```Java
String fileInputPath2 = "src/main/java/com/yupi/springbootinit/constant";
```

基于之前制作好的模板再次执行,发现第二次新增的文件合并到了之前的分组配置中,符合预期

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NjVlMTlmNDQxZmY2ZjJlYzFhYjBiMjYzMGVjMWU0OWNfalYwSWFPQzFyNllsOXRhYnJJZ0hVczM3UDIwVGg0cWVfVG9rZW46QXNoRGIzWVdwb1Z0SFJ4ZEpMb2NwTldIblJiXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

##### 4、模型分组

###### 实现思路

模型分组的实现思路和文件分组逻辑几乎一致，此处不再赘述。

但有一点需要注意，之前我们在测试模板制作工具时，传入的都是单个模型参数和要替换的字符串参数(searchStr)。但现在如果要一次性输入多个模型参数，也要传入多个要替换的字符串。准确地说，每个模型和要替换的字符串参数应该一对应。所以我们需要用额外的类来封装这些参数。

###### 开发实现

1)首先像封装文件配置类(`TemplateMakerFileConfig`)一样，封装所有模型参数、分组参数为模型配置类`TemplateMakerModelConfig`,放到`template.model`目录下。

```Java
package com.manneia.maker.template.model;

import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * @author lkx
 */
@Data
public class TemplateMakerModelConfig {

    private List<ModelInfoConfig> models;

    private ModelGroupConfig modelGroupConfig;

    @NoArgsConstructor
    @Data
    public static class ModelInfoConfig {
        private String filedName;

        private String type;

        private String description;

        private Object defaultValue;

        private String abbr;

        private String replaceText;
    }

    public static class ModelGroupConfig {
        private String condition;

        private String groupKey;

        private String groupName;
    }
}
```

2)修改模型去重方法，和文件去重逻辑一致，实现同组模型信息的去重合并。

```Java
/**
 * 模型配置去重
 *
 * @param modelInfoList 文件配置
 * @return 返回去重后的文件配置
 */
private static List<Meta.ModelConfig.ModelInfo> distinctModels(List<Meta.
        ModelConfig.ModelInfo> modelInfoList) {
    // 策略: 同分组内模型 merge 不同分组保留
    // 1. 有分组的,以组为单位划分
    Map<String, List<Meta.ModelConfig.ModelInfo>> groupKeyModelInfoListMap = modelInfoList
            .stream()
            .filter(modelInfo -> StrUtil.isNotBlank(modelInfo.getGroupKey()))
            .collect(Collectors.groupingBy(Meta.ModelConfig.ModelInfo::getGroupKey));
    // 2. 同组内的文件配置合并
    // 保存每个组对应的合并后的对象 map
    Map<String, Meta.ModelConfig.ModelInfo> groupKeyMergeModelInfoMap = new HashMap<>();
    for (Map.Entry<String, List<Meta.ModelConfig.ModelInfo>> entry :
            groupKeyModelInfoListMap.entrySet()) {
        List<Meta.ModelConfig.ModelInfo> tempModelInfoList = entry.getValue();
        List<Meta.ModelConfig.ModelInfo> newModelInfoList = new ArrayList<>(tempModelInfoList.stream()
                .flatMap(modelInfo -> modelInfo.getModels().stream())
                .collect(Collectors.toMap(Meta.ModelConfig.ModelInfo::getFieldName,
                        o -> o, (e, r) -> r)).values());
        // 使用新的group配置
        Meta.ModelConfig.ModelInfo newModelInfo = CollUtil.getLast(tempModelInfoList);
        newModelInfo.setModels(newModelInfoList);
        String groupKey = entry.getKey();
        groupKeyMergeModelInfoMap.put(groupKey, newModelInfo);
    }
    // 3. 将模型分组添加到结果列表
    List<Meta.ModelConfig.ModelInfo> resultList = new ArrayList<>(
            groupKeyMergeModelInfoMap.values()
    );
    // 4. 将未分组的文件添加到结果列表
    List<Meta.ModelConfig.ModelInfo> noGroupModelInfoList = modelInfoList.stream()
            .filter(modelInfo -> StrUtil.isBlank(modelInfo.getGroupKey()))
            .collect(Collectors.toList());
    resultList.addAll(new ArrayList<>(noGroupModelInfoList.stream()
            .collect(Collectors.toMap(Meta.ModelConfig.ModelInfo::getFieldName,
                    o -> o, (e, r) -> r)).values()));
    return resultList;
}
```

3)修改`makeTemplate`的输入参数，使用封装好的模型配置类`TemplateMakerModelConfig`代替

modellnfo和`searchStr`。

```Java
// 如果是模型组
TemplateMakerModelConfig.ModelGroupConfig modelGroupConfig = templateMakerModelConfig
        .getModelGroupConfig();
if (modelGroupConfig != null) {
    String condition = modelGroupConfig.getCondition();
    String groupKey = modelGroupConfig.getGroupKey();
    String groupName = modelGroupConfig.getGroupName();
    Meta.ModelConfig.ModelInfo groupModelInfo = new Meta.ModelConfig.ModelInfo();
    groupModelInfo.setGroupKey(groupKey);
    groupModelInfo.setGroupName(groupName);
    groupModelInfo.setCondition(condition);
    groupModelInfo.setModels(inputModelInfoList);
    newModelInfoList.add(groupModelInfo);
} else {
    // 不分组,添加所有的模型信息到列表
    newModelInfoList.addAll(inputModelInfoList);
}
```

4)修改`makeFileTemplate`方法，要能够支持使用多个模型参数对文件"挖坑”。

实现思路是依次扁历模型参数，对文件内容进行替换，将上一轮替换后的结果作为新一轮要替换的内容，从而实现多轮替换。

先调整方法的输入参数,以及调用该方法时传入的参数

```Java
private static Meta.FileConfig.FileInfo makeFileTemplate(TemplateMakerModelConfig
                                                                 templateMakerModelConfig,
                                                         String sourceRootPath,
                                                         File inputFile){}
```

然后实现多轮替换逻辑,修改的关键代码如下:

```Java
TemplateMakerModelConfig.ModelGroupConfig modelGroupConfig = templateMakerModelConfig
        .getModelGroupConfig();
String fileContent;
if (FileUtil.exist(fileOutputAbsolutePath)) {
    fileContent = FileUtil.readUtf8String(fileOutputAbsolutePath);
} else {
    fileContent = FileUtil.readUtf8String(fileInputAbsolutePath);
}
String newFileContent = fileContent;
String replacement;
for (TemplateMakerModelConfig.ModelInfoConfig modelInfoConfig :
        templateMakerModelConfig.getModels()) {
    String filedName = modelInfoConfig.getFiledName();
    // 不是分组
    if (modelGroupConfig == null) {
        replacement = String.format("${%s}", filedName);
    } else {
        // 是分组
        String groupKey = modelGroupConfig.getGroupKey();
        // 注意多挖一层
        replacement = String.format("${%s.%s}", groupKey, filedName);
    }
    // 多次替换
    newFileContent = StrUtil.replace(newFileContent,
            modelInfoConfig.getReplaceText(),
            replacement);
}
```

5)   测试验证,定义一组能够替换MySQL配置的模型组参数,用来替换`application.yml`

```Java
String fileInputPath2 = "src/main/resources/application.yml";
// 模型组配置
TemplateMakerModelConfig templateMakerModelConfig = new TemplateMakerModelConfig();
TemplateMakerModelConfig.ModelGroupConfig modelGroupConfig = new TemplateMakerModelConfig
        .ModelGroupConfig();
modelGroupConfig.setGroupKey("mysql");
modelGroupConfig.setGroupName("数据库配置");
templateMakerModelConfig.setModelGroupConfig(modelGroupConfig);
// 模型配置
TemplateMakerModelConfig.ModelInfoConfig modelInfoConfig1 = new TemplateMakerModelConfig
        .ModelInfoConfig();
modelInfoConfig1.setFiledName("url");
modelInfoConfig1.setType("String");
modelInfoConfig1.setDefaultValue("jdbc:mysql://localhost:3306/my_db");
modelInfoConfig1.setReplaceText("jdbc:mysql://localhost:3306/my_db");

TemplateMakerModelConfig.ModelInfoConfig modelInfoConfig2 = new TemplateMakerModelConfig
        .ModelInfoConfig();
modelInfoConfig2.setFiledName("username");
modelInfoConfig2.setType("String");
modelInfoConfig2.setDefaultValue("root");
modelInfoConfig2.setReplaceText("root");

List<TemplateMakerModelConfig.ModelInfoConfig> modelInfoConfigList = Arrays
        .asList(modelInfoConfig1, modelInfoConfig2);
templateMakerModelConfig.setModels(modelInfoConfigList);
```

执行,成功制作出了有多个参数的模板文件

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjk3Njc0NTNkNjhlMTg3YmY1NDQ2MDU1YjNmODExZTJfY3R0bDBZY2IxeUkyVTlsTXlmdUFhT2Y1YlhMT01YaWlfVG9rZW46QU5oN2JYYVpib0ZRVlJ4eHZLc2N2NXdibkhTXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

也成功生成了元信息文件

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YzQzOWYwMmUwN2QyZDI5MjM4YmUzMDU2ZWE4MjNjOGFfM25DbXZoN3ltZFcyN1AwNFNMSnFBazNSQWdReW9LeDdfVG9rZW46T2xCcmJ6M0ZVb3lTaWp4eTM5aWMyUG9EbktnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

## 七、模板项目生成

### 1、bug修复

1.  #### 同配置多次生成,强制变为静态生成

##### Bug 介绍

如果两次制作模板时，配置文件中使用了同一个文件（比如application.yml)、以及相同的模型，那么第二次制作时会判断替换后的模板内容和第一次相同（因为第一次已经替换过了），导致该文件被识别为了静态生成，得到了错误的配置文件。

##### Bug复现

比如,第一次生成时,指定如下配置

```Java
String fileInputPath2 = "src/main/resources/application.yml";
TemplateMakerModelConfig.ModelInfoConfig modelInfoConfig1 = new TemplateMakerModelConfig
        .ModelInfoConfig();
modelInfoConfig1.setFieldName("url");
modelInfoConfig1.setType("String");
modelInfoConfig1.setDefaultValue("jdbc:mysql://localhost:3306/my_db");
modelInfoConfig1.setReplaceText("jdbc:mysql://localhost:3306/my_db");```
```

生成`meta.json`文件,如下:

```JSON
{
    "inputPath": "src/main/resources/application.yml",
    "outputPath": "src/main/resources/application.yml.ftl",
    "type": "file",
    "generateType": "dynamic"
}
```

第二次生成时,不修改任何的输入配置,直接执行制作工具

```JSON
{
    "inputPath": "src/main/resources/application.yml",
    "outputPath": "src/main/resources/application.yml",
    "type": "file",
    "generateType": "static"
}
```

`generateType`被修改为了static类型，显然这是有问题的，因为`application.yml`已经被制作为了模板。

##### 解决方案

该Bug的解决方案很简单：如果后续制作时发现已有模板文件，则该文件不会被设置为静态生成。

1)修复`makeFileTemplate`方法，抽象出`hasTemplateFile`布尔变量，用于判断是否已有模板文件。

修改的代码如下：

```Java
boolean hasTemplateFile = FileUtil.exist(fileOutputAbsolutePath);
if (hasTemplateFile) {
    fileContent = FileUtil.readUtf8String(fileOutputAbsolutePath);
} else {
    fileContent = FileUtil.readUtf8String(fileInputAbsolutePath);
}
```

2)调整设置文件信息对象的逻辑，默认设置生成类型为动态。如果之前不存在模板文件，并且经过字符串替换后没有更改文件内容，才改为静态生成。如果已经存在模板文件，且字符串替换后模板需要更新，则需要更新已有的模板文件。

```Java
Meta.FileConfig.FileInfo fileInfo = new Meta.FileConfig.FileInfo();
fileInfo.setInputPath(fileInputPath);
fileInfo.setType(FileTypeEnum.FILE.getValue());
fileInfo.setGenerateType(FileGenerateTypeEnum.DYNAMIC.getValue());
// 是否更改了文件内容
boolean contentEquals = newFileContent.equals(fileContent);
// 之前不存在模板文件,并且这次替换没有修改文件的内容
if (!hasTemplateFile) {
    // 和原文件内容一致,表示没有修改. 静态生成
    if (contentEquals) {
        // 输入路径 = 输出路径
        fileInfo.setOutputPath(fileInputPath);
        fileInfo.setGenerateType(FileGenerateTypeEnum.STATIC.getValue());
    } else {
        FileUtil.writeUtf8String(newFileContent, fileOutputAbsolutePath);
    }
} else if (!contentEquals) {
    // 有模板文件,并且增加了新的配置, 更新模板文件
    FileUtil.writeUtf8String(newFileContent, fileOutputAbsolutePath);
}
```

##### 测试验证

在test包下创建单元测试类

```Java
package com.manneia.maker.template;

import cn.hutool.core.io.FileUtil;
import com.manneia.maker.meta.Meta;
import com.manneia.maker.template.model.FileFilterConfig;
import com.manneia.maker.template.model.TemplateMakerFileConfig;
import com.manneia.maker.template.model.TemplateMakerModelConfig;
import com.manneia.maker.template.model.enums.FileFilterRangeEnum;
import com.manneia.maker.template.model.enums.FileFilterRuleEnum;
import com.manneia.maker.utils.Utils;
import org.junit.Test;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class TemplateMakerTest {

    private static final String PROJECT_PATH = "manneia-generator-demo-projects/springboot-init";

    @Test
    public void testMakeTemplateBug() {
        Meta meta = new Meta();
        meta.setName("acm-template-generator");
        meta.setDescription("Acm 示例模板生成器");
        String projectPath = Utils.getRootProperty();
        String originProjectPath = FileUtil.getAbsolutePath(new File(projectPath).
                getParentFile()) + File.separator + PROJECT_PATH;
        String fileInputPath = "src/main/java/com/yupi/springbootinit";
        String fileInputPath1 = "src/main/java/com/yupi/springbootinit/common";
        String fileInputPath2 = "src/main/resources/application.yml";
        List<String> inputFilePathList = Arrays.asList(fileInputPath1, fileInputPath2);
        // 输入模型参数
//        Meta.ModelConfig.ModelInfo modelInfo = new Meta.ModelConfig.ModelInfo();
//        modelInfo.setFieldName("outputText");
//        modelInfo.setType("String");
//        modelInfo.setDescription("输出信息");
//        modelInfo.setDefaultValue("sum= ");
        // 输入模型参数信息 第二次
        Meta.ModelConfig.ModelInfo modelInfo = new Meta.ModelConfig.ModelInfo();
        modelInfo.setFieldName("className");
        modelInfo.setType("String");
        // 替换变量
//        String str = "sum= ";
        String str = "BaseResponse";
        // 文件过滤配置
        TemplateMakerFileConfig.FileInfoConfig fileInfoConfig = new TemplateMakerFileConfig.
                FileInfoConfig();
        fileInfoConfig.setPath(fileInputPath1);
        List<FileFilterConfig> filterConfigList = new ArrayList<>();
        FileFilterConfig fileFilterConfig = FileFilterConfig.builder()
                .range(FileFilterRangeEnum.FILE_NAME.getValue())
                .rule(FileFilterRuleEnum.CONTAINS.getValue())
                .value("Base")
                .build();
        filterConfigList.add(fileFilterConfig);
        fileInfoConfig.setFilterConfigList(filterConfigList);
        TemplateMakerFileConfig templateMakerFileConfig = getTemplateMakerFileConfig(fileInputPath2, fileInfoConfig);
        // 模型组配置
        TemplateMakerModelConfig templateMakerModelConfig = getTemplateMakerModelConfig();
        long projectId = TemplateMaker.makeTemplate(meta,
                projectPath,
                originProjectPath,
                templateMakerFileConfig,
                templateMakerModelConfig,
                1767379836796596224L);
        System.out.println(projectId);
    }

    private static TemplateMakerFileConfig getTemplateMakerFileConfig(String fileInputPath2, TemplateMakerFileConfig.FileInfoConfig fileInfoConfig) {
        TemplateMakerFileConfig.FileInfoConfig fileInfoConfig1 = new TemplateMakerFileConfig.
                FileInfoConfig();
        fileInfoConfig1.setPath(fileInputPath2);
        List<TemplateMakerFileConfig.FileInfoConfig> fileInfoConfigList =
                Arrays.asList(fileInfoConfig,
                        fileInfoConfig1);
        return getTemplateMakerFileConfig(fileInfoConfigList);
    }

    private static TemplateMakerFileConfig getTemplateMakerFileConfig(List<TemplateMakerFileConfig.FileInfoConfig> fileInfoConfigList) {
        TemplateMakerFileConfig templateMakerFileConfig = new TemplateMakerFileConfig();
        templateMakerFileConfig.setFiles(fileInfoConfigList);

        // 分组配置
        TemplateMakerFileConfig.FileGroupConfig fileGroupConfig = new TemplateMakerFileConfig.
                FileGroupConfig();
        fileGroupConfig.setCondition("outputText");
        fileGroupConfig.setGroupKey("test");
        fileGroupConfig.setGroupName("测试分组");
        templateMakerFileConfig.setFileGroupConfig(fileGroupConfig);
        return templateMakerFileConfig;
    }

    private static TemplateMakerModelConfig getTemplateMakerModelConfig() {
        TemplateMakerModelConfig templateMakerModelConfig = new TemplateMakerModelConfig();
        TemplateMakerModelConfig.ModelGroupConfig modelGroupConfig = new TemplateMakerModelConfig
                .ModelGroupConfig();
        modelGroupConfig.setGroupKey("mysql");
        modelGroupConfig.setGroupName("数据库配置");
        templateMakerModelConfig.setModelGroupConfig(modelGroupConfig);
        // 模型配置
        TemplateMakerModelConfig.ModelInfoConfig modelInfoConfig1 = new TemplateMakerModelConfig
                .ModelInfoConfig();
        modelInfoConfig1.setFieldName("url");
        modelInfoConfig1.setType("String");
        modelInfoConfig1.setDefaultValue("jdbc:mysql://localhost:3306/my_db");
        modelInfoConfig1.setReplaceText("jdbc:mysql://localhost:3306/my_db");

        TemplateMakerModelConfig.ModelInfoConfig modelInfoConfig2 = new TemplateMakerModelConfig
                .ModelInfoConfig();
        modelInfoConfig2.setFieldName("username");
        modelInfoConfig2.setType("String");
        modelInfoConfig2.setDefaultValue("root");
        modelInfoConfig2.setReplaceText("root");

        List<TemplateMakerModelConfig.ModelInfoConfig> modelInfoConfigList = Arrays
                .asList(modelInfoConfig1, modelInfoConfig2);
        templateMakerModelConfig.setModels(modelInfoConfigList);
        return templateMakerModelConfig;
    }
}
```

连续执行两次方法,发现文件的生成类型符合预期,成功修复了bug

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MjI5Mzg4NzE0MGEwOGJjYjMxNzY0Njg5ZTdmZGE1OTJfRXd3bkpGTk94d0NsTXRLQnc5bzdDalIwTjIzUTk2QWlfVG9rZW46SDhkTGJ4c2Fnb2lBdnR4VzFaM2NuRnVPbkIxXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

1.  #### 错误处理了新生成的模板文件

##### Bug 介绍

如果多次制作时指定了相同的目录（如common包），那么后续制作时会扫描到之前生成的FTL模板文件，并尝试基于FTL文件再次制作模板，导致生成了错误的配置。

##### Bug 复现

比如 第一次生成时, 输入如下配置:

```Java
String fileInputPath2 = "src/main/java/com/yupi/springbootinit/common;

TemplateMakerModelConfig.ModelInfoConfig modelInfoConfig = new TemplateMakerModelConfig.ModelInfoConfig();
modelInfoConfig.setFieldName("className");
modelInfoConfig.setType("String");
modelInfoConfig.setReplaceText("BaseResponse");
```

生成`meta.json`文件部分信息如下:

```JSON
{
    "inputPath": "src/main/java/com/yupi/springbootinit/common/BaseResponse.java",
    "outputPath": "src/main/java/com/yupi/springbootinit/common/BaseResponse.java",
    "type": "file",
    "generateType": "static"
},
{
    "inputPath": "src/main/resources/application.yml",
    "type": "file",
    "generateType": "dynamic"
}
```

第二次生成时,不修改任何配置,直接执行

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NzdhMmU0OTBkYmEwOGQ4OWVhYmRiYWFhMTdiN2NkNTJfQ29OVmRNYktiaFIzR0lZQUxRNXVuZzZ6TWVYdkxHYnZfVG9rZW46VzRUaWJpaWFwb0RkbGp4NnA5S2NPY0ZibnlnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

显然，`BaseResponse.java.ftl`模板文件，也以静态生成的方式出现在了配置文件中，实际上不应该再对该文件进行处理。

##### 解决方案

每次制作时，判断输入文件的后缀是否为.t1,如果是，则不处理该文件。

修改makeTemplate方法中的代码，在文件过滤后补充移除FTL模板文件。代码如下：

```Java
List<File> fileList = FileFilter.doFilter(fileInfoConfig.
        getFilterConfigList(), inputFileAbsolutePath);
// 不处理已生成的FTL 模板文件
fileList = fileList.stream()
        .filter(file -> !file.getAbsolutePath().endsWith(".ftl"))
        .collect(Collectors.toList());
```

##### 测试验证

再一次执行单元测试方法,这次生成的配置符合预期,成功修复了

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=OTg4MDE2MWE2YmU0YzJjNzliM2U3MGRjMjc1NjI4Y2FfaUF1bEhrZ2lNZlZDa3N1ZFRpQlU0Yklja09oSTRPTFdfVG9rZW46V0lYa2JrNXN1b1ExbWN4Y0xTNmN2MmxEbkdlXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

#### 3、文件输入和输出路径相反

##### Bug 介绍

现在我们的`meta.json`文件会生成在工作空间内、项目的根目录下，如果我们指定的输入文件路径是项目的根目录，那么meta.json文件也会被当成项目文件被扫描处理。

##### Bug 复现

设置文件输入路径为根目录:

```Java
String fileInputPath = "./";
```

然后连续执行制作两次,发现第二次制作模板时,把第一次得到的`meta.json`文件也当作了模板文件处理

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YWI3NDkwMDM1OGMwYmU5MTViMjhiMmJlMmRjYzZhYzFfZmpBeEI1VEZhcmVwRjlvY2VyZTZ2c1VMU0trUkdzZ2dfVG9rZW46Q2lxcmJnNVZQb2Zrejl4cFVoZGNKRk1QblVnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

##### 解决方案

非常简单，修改`meta.json`文件的生成路径即可，调整为工作空间根日录下，和项日目录平级。

修改后的代码如下：

```Java
// 三、生成配置文件
String metaOutputPath = templatePath + File.separator + "meta.json";
```

##### 测试验证

执行单元测试,生成的配置文件路径被正确修改了,后续制作时,不会错误处理该文件

### 2、参数封装 - 易用性优化

之前每次使用制作工具时，我们都要自主编写和封装各种配置对象，非常麻烦。

有没有更简单的方式呢？

我们可以把所有模板制作工具需要的参数统一封装为一个对象，这样就可以通过传递一个JSON配置文件（或者后续的HTTP Post请求)来快速填充参数。

1)在`template.model`包下新建`TemplateMakerConfig`类，用于封装所有模板制作工具需要的参数。

代码如下：

>   注意要给对象指定默认值,防止 `NPE`

```Java
package com.manneia.maker.template.model;

import com.manneia.maker.meta.Meta;
import lombok.Data;

/**
 * 模板制作配置
 *
 * @author lkx
 */
@Data
public class TemplateMakerConfig {

    private Long id;

    private Meta meta = new Meta();

    private String originProjectPath;

    TemplateMakerFileConfig fileConfig = new TemplateMakerFileConfig();

    TemplateMakerModelConfig modelConfig = new TemplateMakerModelConfig();
}
```

2)   然后在`TemplateMaker`制作工具中新增接受该封装类的重载方法,不修改原方法,新增代码如下:

```Java
/**
 * 制作模板
 * @param templateMakerConfig 模板制作配置
 * @return 返回文件id
 */
public static long makeTemplate(TemplateMakerConfig templateMakerConfig) {
    Meta meta = templateMakerConfig.getMeta();
    Long id = templateMakerConfig.getId();
    String projectPath = templateMakerConfig.getProjectPath();
    String originProjectPath = templateMakerConfig.getOriginProjectPath();
    TemplateMakerFileConfig fileConfig = templateMakerConfig.getFileConfig();
    TemplateMakerModelConfig modelConfig = templateMakerConfig.getModelConfig();

    return makeTemplate(meta, projectPath, originProjectPath, fileConfig, modelConfig, id);
}
```

3)   在`resources`资源目录下新建临时`templateMaker.json`,用于给封装对象设置参数:

```Java
{
  "meta": {
    "name": "acm-template-pro-generator",
    "description" : "Acm 示例模板生成器"
  },
  "originProjectPath": "../../../manneia-generator-demo-projects/springboot-init",
  "fileConfig": {
    "files": [
      {
        "path": "src/main/java/com/yupi/springbootinit/common"
      }
    ]
  },
  "modelConfig" : {
    "models" : [
      {
        "fieldName": "className",
        "type": "String",
        "defaultValue": true,
        "replaceText": "BaseResponse"
      }
    ]
  }
}
```

4)   编写单元测试方法,读取json文件并转换为模板配置,然后制作模板

```Java
@Test
public void testMakeTemplateWithJson() {
    String configStr = ResourceUtil.readUtf8Str("templateMaker.json");
    TemplateMakerConfig templateMakerConfig = JSONUtil.toBean(configStr, TemplateMakerConfig.class);
    long id = TemplateMaker.makeTemplate(templateMakerConfig);
    System.out.println(id);
}
```

5)   测试执行,生成了符合预期的代码

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YWQ3OGQ3OTMxNTk5ZDk4MmI2MTk2ODY4MTJkMDRkZTlfYUg5eFZHbGV5Qm5SSkhySjV4aE1SSkhjUksyMnhKYWNfVG9rZW46UDZuOGI5ZkpzbzNuV1l4SndvWWNBT2hxbnFpXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

### 3、制作 SpringBoot 项目模板生成器

#### 1、项目基本信息

##### 编写配置

首先我们要编写代码生成器的基本信息，在`resources/examples/springboot-init`目录下新建`templateMaker.json`模板配置文件。

```JSON
{
  "meta": {
    "name": "acm-template-pro-generator",
    "description" : "Acm 示例模板生成器"
  },
  "originProjectPath": "../../../manneia-generator-demo-projects/springboot-init",
}
```

##### 测试执行

```Java
@Test
public void testMakeSpringBootTemplate() {
    String rootPath = "examples/springboot-init/";
    String configStr = ResourceUtil.readUtf8Str(rootPath + "templateMaker.json");
    TemplateMakerConfig templateMakerConfig = JSONUtil.toBean(configStr, TemplateMakerConfig.class);
    long id = TemplateMaker.makeTemplate(templateMakerConfig);
    System.out.println(id);
}
```

运行报错啦

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=OWI0NDA2MDYwZjQ1YjQzMzVjYWYwMzMzZWMxN2NjNGJfcVRHYm5KQWtNemlWY2RNN3VDT2dLWGpJd2I5RXNzZ1hfVG9rZW46RzJqR2JBMldqb01vYVF4cHZhc2NJVUJpbnlnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

提示对象为空？哦，原来是因为我们现在的模板配置中，除了项目基本信息外，文件和模型配置都没有。

所以我们需要优化下代码，增加对象的非空校验。

##### 增加对象非空校验

主要增加文件和模型配置对象的非空校验

1)   补充文件非空校验

只要判断文件配置为空，不做任何处理，直接抄行后续逻辑即可。

最好是将制作文件模板的逻辑柚象为一个方法，便于使用return语句提前返回，减少代码嵌套。

抽象出来的`getFileInfoList`方法代码如下,返回新增的文件信息列表

```Java
/**
 * 生成多个文件
 *
 * @param templateMakerFileConfig  模板文件配置
 * @param templateMakerModelConfig 模板模型配置
 * @param sourceRootPath           源文件路径
 * @return 返回文件列表
 */
private static List<Meta.FileConfig.FileInfo> getFileInfoList(
        TemplateMakerFileConfig templateMakerFileConfig,
        TemplateMakerModelConfig templateMakerModelConfig,
        String sourceRootPath) {
    List<Meta.FileConfig.FileInfo> newFileInfoList = new ArrayList<>();

    List<TemplateMakerFileConfig.FileInfoConfig> fileInfoConfigList = templateMakerFileConfig.
            getFiles();
    // 二、生成文件模板
    // 遍历输入文件
    for (TemplateMakerFileConfig.FileInfoConfig fileInfoConfig : fileInfoConfigList) {
        String inputFilePath = fileInfoConfig.getPath();
        String inputFileAbsolutePath = sourceRootPath + File.separator + inputFilePath;
        // 传入绝对路径
        // 得到过滤后的文件列表
        List<File> fileList = FileFilter.doFilter(fileInfoConfig.
                getFilterConfigList(), inputFileAbsolutePath);
        // 不处理已生成的FTL 模板文件
        fileList = fileList.stream()
                .filter(file -> !file.getAbsolutePath().endsWith(".ftl"))
                .collect(Collectors.toList());
        for (File file : fileList) {
            Meta.FileConfig.FileInfo fileInfo = makeFileTemplate(templateMakerModelConfig,
                    sourceRootPath,
                    file);
            newFileInfoList.add(fileInfo);
        }
    }

    // 如果是文件组
    TemplateMakerFileConfig.FileGroupConfig fileGroupConfig = templateMakerFileConfig.
            getFileGroupConfig();
    if (fileGroupConfig != null) {
        Meta.FileConfig.FileInfo groupFileInfo = getFileInfo(fileGroupConfig, newFileInfoList);
        newFileInfoList = new ArrayList<>();
        newFileInfoList.add(groupFileInfo);
    }
    return newFileInfoList;
}
```

然后在方法开头补充非空校验

```Java
List<Meta.FileConfig.FileInfo> newFileInfoList = new ArrayList<>();
// 非空校验
if (templateMakerFileConfig == null) {
    return newFileInfoList;
}
List<TemplateMakerFileConfig.FileInfoConfig> fileInfoConfigList = templateMakerFileConfig.
        getFiles();
if (CollUtil.isEmpty(fileInfoConfigList)) {
    return newFileInfoList;
}
```

2)   补充模型非空校验

和文件非空校验一样，为了更好地组织代码，将获取模型配置列表的逻辑抽象为独立的方法`getModelInfoList`,返回值为模型配置列表。

```Java
/**
 * 获取模型配置
 *
 * @param templateMakerModelConfig 模板模型配置
 * @return 返回模型配置列表
 */
private static List<Meta.ModelConfig.ModelInfo> getModelInfoList(
        TemplateMakerModelConfig templateMakerModelConfig) {
    List<Meta.ModelConfig.ModelInfo> newModelInfoList = new ArrayList<>();
    List<TemplateMakerModelConfig.ModelInfoConfig> models = templateMakerModelConfig.getModels();
    // 处理模型信息
    // 转换为配置文件接受的modelInfo对象
    List<Meta.ModelConfig.ModelInfo> inputModelInfoList = models.stream()
            .map(modelInfoConfig -> {
                Meta.ModelConfig.ModelInfo modelInfo = new Meta.ModelConfig.ModelInfo();
                BeanUtil.copyProperties(modelInfoConfig, modelInfo);
                return modelInfo;
            }).collect(Collectors.toList());

    // 如果是模型组
    TemplateMakerModelConfig.ModelGroupConfig modelGroupConfig = templateMakerModelConfig
            .getModelGroupConfig();
    if (modelGroupConfig != null) {
        String condition = modelGroupConfig.getCondition();
        String groupKey = modelGroupConfig.getGroupKey();
        String groupName = modelGroupConfig.getGroupName();
        Meta.ModelConfig.ModelInfo groupModelInfo = new Meta.ModelConfig.ModelInfo();
        groupModelInfo.setGroupKey(groupKey);
        groupModelInfo.setGroupName(groupName);
        groupModelInfo.setCondition(condition);
        groupModelInfo.setModels(inputModelInfoList);
        newModelInfoList = new ArrayList<>();
        newModelInfoList.add(groupModelInfo);
    } else {
        // 不分组,添加所有的模型信息到列表
        newModelInfoList = new ArrayList<>(inputModelInfoList);
    }
    return newModelInfoList;
}
```

然后在方法开头补充非空校验

```Java
List<Meta.ModelConfig.ModelInfo> newModelInfoList = new ArrayList<>();
// 非空校验
if (templateMakerModelConfig == null) {
    return newModelInfoList;
}
List<TemplateMakerModelConfig.ModelInfoConfig> models = templateMakerModelConfig.getModels();
if (CollUtil.isEmpty(models)) {
    return newModelInfoList;
}
```

3)   同步修改`makeTemplate`方法,调用抽象出的方法

```Java
// 制作文件模板
List<Meta.FileConfig.FileInfo> newFileInfoList = getFileInfoList(
        templateMakerFileConfig,
        templateMakerModelConfig,
        sourceRootPath);
// 处理模板模型信息
List<Meta.ModelConfig.ModelInfo> newModelInfoList = getModelInfoList(templateMakerModelConfig);
```

然后再次制作模板,生成内容符合预期

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YWM1MjdlNGZhMmM1OTMyNjA5MTc3ZTk2MGRlMjZlNDBfODlWUmFDNUVtR1N6OExDMlVqY2NZb2hITkhEcG5CT0JfVG9rZW46WGo4cGJUTXBxb1htYjR4SElGNGNPZEdzbmlvXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

#### 2、需求 : 替换生成的代码包名

##### 明确需求

允许用户传入`basePackage`模型参数，对Spring Boot模板项目代码中所有出现包名的地方进行替换.

由于用到包名的代码非常多，如果都要自己"挖坑”并制作FTL动态模板，不仅成本高、而且也容易出现遗漏(比如@MapperScan注解里也有包名)。

所以我们需要利用模板制作工具来自动“挖坑”并生成模板文件。

##### 持久化项目路径

在编写新的模板制作配置文件前，我们要先完善一下配置追加的能力。如果非首次制作，其实配置文件中肯定已经存在了`originProjectPath`参数，那么后续制作时，不需要再在配置文件中指定该参数。

修改方法很简单，制作工具代码中只有获取`sourceRootPath`时用到了`originProjectPath`,修改该变量的获取方式，自动读取工作空间下的第一个目录（项目根目录）即可。

修改后的代码如下:

```Java
String sourceRootPath = FileUtil.loopFiles(new File(templatePath), 1, null)
        .stream()
        .filter(File::isDirectory)
        .findFirst()
        .orElseThrow(RuntimeException::new)
        .getAbsolutePath();
```

注意，获取第一个目录时，需要设置层级为1、且必须读取目录而不是文件。否则可能会因为`.DS_Store`等系统临时生成的文件干扰结果。

##### 编写配置

编写替换生成代码包名的配置文件，全局替换`springboot-init`目目录下的所有文件的`com.yupi`字符串为`basePackage`模型参数。

在`resources/examples/springboot-init`目录下新建`templateMaker1.json`模板配置文件，代a码如

下：

```JSON
{
  "id": 1,
  "fileConfig": {
    "files": [
      {
        "path": ""
      }
    ]
  },
  "modelConfig": {
    "models": [
      {
        "fieldName": "basePackage",
        "type": "String",
        "description": "基础包名",
        "defaultValue": "com.yupi",
        "replaceText": "com.yupi"
      }
    ]
  }
}
```

##### 测试执行

在TemplateMakerTest单测文件的makeSpringBootTemplate方法中新增代码，读取上述配置并执行模板

制作。

```Java
    @Test
    public void testMakeSpringBootTemplate() {
        String rootPath = "examples/springboot-init/";
        String configStr = ResourceUtil.readUtf8Str(rootPath + "templateMaker.json");
        TemplateMakerConfig templateMakerConfig = JSONUtil.toBean(configStr, TemplateMakerConfig.class);
//        long id = TemplateMaker.makeTemplate(templateMakerConfig);

        configStr = ResourceUtil.readUtf8Str(rootPath + "templateMaker1.json");
        templateMakerConfig = JSONUtil.toBean(configStr, TemplateMakerConfig.class);
        long id = TemplateMaker.makeTemplate(templateMakerConfig);

        System.out.println(id);
    }
```

执行成功,生成内容符合预期

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YWM0MjEwYTM2MTc3OGQ1OWJiMjEyMzVjYmE1OGY4ODFfcUlUYzFXYkQwVkFJMW1wMU1EZU9aWmdrbVZpQmxPc3JfVG9rZW46VERZdGJYSndyb1ZnSHd4cjJvRmNUYXRqblJjXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

#### 3、需求: 控制是否生成帖子相关功能

##### 明确需求

允许用户传入`needPost`模型参数，控制帖子功能相关的文件是否生成，比如PostController、PostService、PostMapper、PostMapper.Xml、Post实体类等。

##### 编写配置

由于帖子相关的文件分散到不同的目录下，为了简化配置，我们可以使用文件过滤器，只保留文件名包含`Post`的文件。并且将这些文件设置为同一个文件组，`needPost`模型参数为true时才会生成。

在`resources/examples/springboot-init`目录下新建`templateMaker2.json`模板配置文件，代码如下：

```Java
{
  "id": 1,
  "fileConfig": {
    "fileGroupConfig": {
      "groupKey": "post",
      "groupName": "帖子文件组",
      "condition": "needPost"
    },
    "files": [
      {
        "path": "src/main",
        "filterConfigList": [
          {
            "range": "fileName",
            "rule": "contains",
            "value": "Post"
          }
        ]
      }
    ]
  },
  "modelConfig": {
    "models": [
      {
        "fieldName": "needPost",
        "type": "boolean",
        "description": "是否开启帖子功能",
        "defaultValue": true
      }
    ]
  }
}
```

##### 测试执行

和之前的测试方法一样，在单元测试方法内补充读取新配置并制作模板的代码，如下：

```Java
configStr = ResourceUtil.readUtf8Str(rootPath + "templateMaker2.json");
templateMakerConfig = JSONUtil.toBean(configStr, TemplateMakerConfig.class);
long id = TemplateMaker.makeTemplate(templateMakerConfig);
```

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NDYwODE4MDExMWRkYzcyZGU2ZDdiYTU1NjQ5YWVhYTRfUHpCNFUxNGNtYWxsU1FDVnAzU05wQ1Q3VzdXelE4b3pfVG9rZW46VW5UeWJVTDhSbzRxQ054Qm5QTGNUQXpTbkFjXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

但有个问题，我们在前面制作时已经生成过帖子相关的模板文件了，而现在分组内新增了相同文件，导致同一个文

件在外层和分组内多次重复出现，如下图：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NDgzYjhkM2I2OGY3NGFhNDlkNTE1NjM3ZjE2YzEyNWRfMzVVRHV2YVVLTVdsbmNFODdJYjRHNU9GQktPVVhqOWhfVG9rZW46R2Z1YWJVSWI5b2l1eEt4WnV1MGNXR0Q0bmJkXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

##### 自定义去重

比较简单粗暴的方式是直接从未分组文件配置中移除和已分组文件同名的配置。

但如果用户就是想同时保留组内外相同的配置呢？

所以，比较友好的方式是，支持让用户自己选择是否去重。

这个时候，我们最初设计模板制作工具时提到的第4个输入项就有用了，也就是输出配置。

1)在template.model包下新建TemplateMakerOutputConfig输出配置类，并定义一个控制分组去重的

属性。

```Java
package com.manneia.maker.template.model;

import lombok.Data;

/**
 * 输出配置类
 *
 * @author lkx
 */
@Data
public class TemplateMakerOutputConfig {
    /**
     * 从未分组文件中移除组内的同名文件
     */
    private boolean removeGroupFilesFromRoot = true;
}
```

2)然后在封装配置类`TemplateMakerConfig`中补充输出配置属性，代码如下：

```Java
package com.manneia.maker.template.model;

import com.manneia.maker.meta.Meta;
import com.manneia.maker.utils.Utils;
import lombok.Data;

/**
 * 模板制作配置
 *
 * @author lkx
 */
@Data
public class TemplateMakerConfig {

    private Long id;

    private Meta meta = new Meta();

    private String projectPath = Utils.getRootProperty();

    private String originProjectPath;

    TemplateMakerFileConfig fileConfig = new TemplateMakerFileConfig();

    TemplateMakerModelConfig modelConfig = new TemplateMakerModelConfig();

    TemplateMakerOutputConfig outputConfig = new TemplateMakerOutputConfig();
}
```

3)编写分组去重的实现代码。

由于去重逻辑引比较复杂，而且算是一个额外的能力，所以建议单独编写一个工具类实现。

大致的去重流程是：

1.  获取到所有的分组
2.  获取到所有分组内的文件列表
3.  获取所有分组内的文件输入路径集合
4.  利用上述集合，移除所有输入路径在集合中的外层文件

在`Utils`包下新建TemplateMakerUtils方法，实现上述流程，完整代码如下：

```Java
/**
 * 从未分组文件中移除组内的同名文件
 *
 * @param fileInfoList 文件信息列表
 * @return 返回过滤后的文件信息列表
 */
public static List<Meta.FileConfig.FileInfo> removeGroupFilesFromRoot(
        List<Meta.FileConfig.FileInfo> fileInfoList) {
    // 获取所有分组
    List<Meta.FileConfig.FileInfo> groupFileInfoList = fileInfoList.stream()
            .filter(fileInfo -> StrUtil.isNotBlank(fileInfo.getGroupKey()))
            .collect(Collectors.toList());
    // 获取所有分组内的文件列表
    List<Meta.FileConfig.FileInfo> groupInnerFileInfoList = groupFileInfoList.stream()
            .flatMap(fileInfo -> fileInfo.getFiles().stream())
            .collect(Collectors.toList());
    // 获取所有分组内文件输入路径集合
    Set<String> fileInputPathSet = groupInnerFileInfoList.stream()
            .map(Meta.FileConfig.FileInfo::getInputPath)
            .collect(Collectors.toSet());
    // 移除所有名称在集合中的外层文件
    return fileInfoList.stream()
            .filter(fileInfo -> !fileInputPathSet.contains(fileInfo.getInputPath()))
            .collect(Collectors.toList());
}
```

4)在模板制作方法中，增加输出配置参数，并根据配置执行文件分组合并。

修改后的`makeTemplate`方法如下:

```Java
public static long makeTemplate(Meta newMeta,
                                String projectPath,
                                String originProjectPath,
                                TemplateMakerFileConfig templateMakerFileConfig,
                                TemplateMakerModelConfig templateMakerModelConfig,
                                TemplateMakerOutputConfig templateMakerOutputConfig,
                                Long id){}
```

追加调用工具类的分组去重方法:

```Java
// 额外的输出配置
if (templateMakerOutputConfig != null) {
    // 文件外层和分组去重
    if (templateMakerOutputConfig.isRemoveGroupFilesFromRoot()) {
        List<Meta.FileConfig.FileInfo> fileInfoList =
                newMeta.getFileConfig().getFiles();
        newMeta.getFileConfig().setFiles(Utils.removeGroupFilesFromRoot(fileInfoList));
    }
}
```

再次执行测试,生成的文件符合预期

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ODIyODI3OGYzNzgxMjJkNmNmZmE4NmFlYTBjOTBkYjlfVWRuUFNHdngzdXhnSmlySVkzdDk0N0Nqb091cnFQZGdfVG9rZW46TWgxN2JXVlp5b1NncEZ4ckQ5QmNmNjlpbkloXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

#### 4、需求: 控制是否需要开启跨域

##### 明确需求

允许用户传入`needCors`模型参数，控制跨域相关的文件`CorsConfig.java`是否生成。

##### 编写配置

设置文件路径为`CorsConfig.java`、新增模型参数`needCors`,注意还要给文件配置指定一个生成条件。

在`resources/examples/springboot-init`目录下新建`templateMaker3.json`模板配置文件，代码如下：

```JSON
{
  "id": 1,
  "fileConfig": {
    "files": [
      {
        "path": "src/main/java/com/yupi/springbootinit/config/CorsConfig.java",
        "condition": "needCors"
      }
    ]
  },
  "modelConfig": {
    "models": [
      {
        "fieldName": "needCors",
        "type": "boolean",
        "description": "是否开启跨域功能",
        "defaultValue": true
      }
    ]
  }
}
```

##### 支持给单文件指定条件

由于之前我们只支持给文件分组设置生成条件，无法满足现在的需求，所以还需要支持给单个文件设置生成涤件。

1)修改文件配置类`TemplateMakerFileConfig.FileInfoConfig`,补充`condition`条件参数：

```Java
@NoArgsConstructor
@Data
public static class FileInfoConfig {
    private String path;

    private String condition;

    private List<FileFilterConfig> filterConfigList;
}
```

2)`makeFileTemplate`方法新增`fileConfig`对象的传递，支持从配置中取出`condition`并填充`fileInfo`对象。

修改的部分代码如下：

```Java
private static Meta.FileConfig.FileInfo makeFileTemplate(
        TemplateMakerModelConfig templateMakerModelConfig,
        String sourceRootPath,
        File inputFile,
        TemplateMakerFileConfig.FileInfoConfig fileInfoConfig){
        ...
        // 文件配置信息
        Meta.FileConfig.FileInfo fileInfo = new Meta.FileConfig.FileInfo();
        // 注意文件输入路径和输出路径要反转
        fileInfo.setInputPath(fileOutputPath);
        fileInfo.setOutputPath(fileInputPath);
        fileInfo.setCondition(fileInfoConfig.getCondition());
        fileInfo.setType(FileTypeEnum.FILE.getValue());
        fileInfo.setGenerateType(FileGenerateTypeEnum.DYNAMIC.getValue());    
        ...    
}
```

##### 测试执行

和之前的测试方法一样，在单元测试方法内补充读取新配置并制作模板的代码，如下：

```Java
configStr = ResourceUtil.readUtf8Str(rootPath + "templateMaker3.json");
templateMakerConfig = JSONUtil.toBean(configStr, TemplateMakerConfig.class);
long id = TemplateMaker.makeTemplate(templateMakerConfig);
```

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YzMxNmU4ZTJlYTU5YjVhMDhhMDE3NGY0OWI2NTM3MWNfNHNXdGtqOGxiQzlKclAwVGhrZFN6QmVSYmV3c2VHcHZfVG9rZW46WFhlTmJTTkl4bzRLdTR4VnVZRWNhSXlPbmFoXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDIyZmU0N2IwYzk5NzJlNDFhYTZhMDg4ZDg0ZTRmODBfb2pIdncxam9pRzJaWDJYN2txS2N2T0lBT0R3bXYzTFRfVG9rZW46RDFiYWIwSmljb3pIZmp4TDJRN2NxZTc2bkxyXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

#### 5、需求: 自定义Knife4jConfig 接口文档配置

##### 明确需求

先让用户输入`needDocs`参数，决定是否需要开启接口文档配置；如果要开启，再让用户输入一组参数，能够修改`Knife4jConfig`文件中的配置，比如

由于要支持用户输入的参数较多，可以用一个参数控制是否要开启接口文档配置。如果开启，再让用户输入一组配置参数。

实现思路：修改`Knife4jConfig`文件中的配置，比如接口文档的标题、描述、版本号等。

##### 完善模型分组配置

要实现这个需求，我们还要给模型分组配置增加一些字段，比如分组的类型、描述：

1)修改`TemplateMakerModelConfig.ModelGroupConfig`,代码如下：

```Java
@Data
public static class ModelGroupConfig {
    private String condition;

    private String groupKey;

    private String groupName;

    private String type;

    private String description;
}
```

2)在模板制作类中，获取模型信息列表时，需要将配置中指定的分组信息传递给`groupModelInfo`对象。

修改`getModelInfoList`方法，通过`BeanUtil.copyProperties`拷贝对象的属性值，修改的代码如下：

```Java
TemplateMakerModelConfig.ModelGroupConfig modelGroupConfig = templateMakerModelConfig
        .getModelGroupConfig();
if (modelGroupConfig != null) {
    // 复制变量
    Meta.ModelConfig.ModelInfo groupModelInfo = new Meta.ModelConfig.ModelInfo();
    BeanUtil.copyProperties(modelGroupConfig, groupModelInfo);
    // 模型全部放到一个分组里
    groupModelInfo.setModels(inputModelInfoList);
    newModelInfoList.add(groupModelInfo);
} else {
    // 不分组,添加所有的模型信息到列表
    newModelInfoList.addAll(inputModelInfoList);
}
```

##### 编写配置

由于需求是先控制接口文档文件是否生成、再指定修改接口文档内容的参数。所以我们需要分为2步去制作模板，不要让每次制作的模型参数混在同一组，会更清晰一些。

1)先控制文件是否生成。在`resources./examples,/springboot-init`目录下新建`templateMaker4.json`模板配置文件，代码如下：

```JSON
{
  "id": 1,
  "fileConfig": {
    "files": [
      {
        "path": "src/main/java/com/yupi/springbootinit/config/Knife4jConfig.java",
        "condition": "needDocs"
      }
    ]
  },
  "modelConfig": {
    "models": [
      {
        "fieldName": "needDocs",
        "type": "boolean",
        "description": "是否开启接口文档功能",
        "defaultValue": true
      }
    ]
  }
}
```

2)再定义一组配置，控制接口文档文件的内容。`resources/examples/springboot-init`目录下新建`templateMaker5.json`模板配置文件，代码如下：

```JSON
{
  "id": 1,
  "fileConfig": {
    "files": [
      {
        "path": "src/main/java/com/yupi/springbootinit/config/Knife4jConfig.java",
        "condition": "needDocs"
      }
    ]
  },
  "modelConfig": {
    "modelGroupConfig": {
      "groupKey": "docsConfig",
      "groupName": "接口文档配置",
      "type": "DocsConfig",
      "description": "用于生成接口文档配置",
      "condition": "needDocs"
    },
    "models": [
      {
        "fieldName": "title",
        "type": "String",
        "description": "接口文档标题",
        "defaultValue": "接口文档",
        "replaceText": "接口文档"
      },
      {
        "fieldName": "description",
        "type": "String",
        "description": "接口文档描述",
        "defaultValue": "springboot-init",
        "replaceText": "springboot-init"
      },
      {
        "fieldName": "version",
        "type": "String",
        "description": "接口文档版本",
        "defaultValue": "1.0",
        "replaceText": "1.0"
      }
    ]
  }
}
```

##### 测试验证

和之前的测试方法一样，在单元测试方法内补充读取新配置并制作模板的代码，如下:

```Java
configStr = ResourceUtil.readUtf8Str(rootPath + "templateMaker4.json");
templateMakerConfig = JSONUtil.toBean(configStr, TemplateMakerConfig.class);
TemplateMaker.makeTemplate(templateMakerConfig);

configStr = ResourceUtil.readUtf8Str(rootPath + "templateMaker5.json");
templateMakerConfig = JSONUtil.toBean(configStr, TemplateMakerConfig.class);
TemplateMaker.makeTemplate(templateMakerConfig);
```

执行成功,查看生成的元信息配置,发现生成符合预期

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YTkxODA1YWJkMDMzM2UyYjhhYzkxNDEwMzcxODFhMmFfMFJJdXZaRkwzb2c3RWk1S21KdnFoUGZYZDl0em9xTHZfVG9rZW46UHhZRmJJWFJ1b2E0MU94VjVweWN3d2g5blRiXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

#### 6、需求: 自定义MySQL配置信息

##### 明确需求

允许用户传入一组小ySQL数据库模型参数，修改application.yml配置文件中MySQL的url、username、password的值。

##### 配置文件

有了上一个需求的支特，这一步就很简单了。在`resources/examples/springboot-init`目录下新建`templateMaker6.json`模板配置文件，代码如下：

```JSON
{
  "id": 1,
  "fileConfig": {
    "files": [
      {
        "path": "src/main/resources/application.yml",
        "condition": "needDocs"
      }
    ]
  },
  "modelConfig": {
    "modelGroupConfig": {
      "groupKey": "mysqlConfig",
      "groupName": "mysql数据库配置",
      "type": "mysqlConfig",
      "description": "用于生成mysql数据库配置",
    },
    "models": [
      {
        "fieldName": "url",
        "type": "String",
        "description": "地址",
        "defaultValue": "jdbc:mysql://localhost:3306/my_db",
        "replaceText": "jdbc:mysql://localhost:3306/my_db"
      },
      {
        "fieldName": "username",
        "type": "String",
        "description": "用户名",
        "defaultValue": "root",
        "replaceText": "root"
      },
      {
        "fieldName": "password",
        "type": "String",
        "description": "密码",
        "defaultValue": "123456",
        "replaceText": "123456"
      }
    ]
  }
}
```

##### 执行测试

和之前的测试方法一样，在单元测试方法内补充读取新配置并制作模板的代码，如下

```Java
configStr = ResourceUtil.readUtf8Str(rootPath + "templateMaker6.json");
templateMakerConfig = JSONUtil.toBean(configStr, TemplateMakerConfig.class);
TemplateMaker.makeTemplate(templateMakerConfig);
```

执行成功，查看生成的元信息配置，发现模型分组正确生成：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NDc0ZTI1OWUwNWRmYzkyOGRiMjI1MWQ1ZWZjMzI3MjlfYVNZTWZNZDh5cGU4ck1pRUhSbkNYaXN1TFJxYnB1c0JfVG9rZW46Q1EyN2JmT1RWbzJESUp4WFk0aWNQNTQwbkdiXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

#### 7、需求: 控制是否开启redis

##### 明确需求

允许用户传入`needRedis`模型参数，控制是否开启和Redis相关的代码。需要修改application.yml、pom.Xml、MainApplication,java等多个用到Redis的文件的部分代码。

##### 实现

这个需求比较定制化，因为每个文件和Rdis有关的代码都不一样，所以建议人工修改模板文件并"挖坑”。

如果一定要用模板制作工具实现，那么可以考虑使用同一个参数控制多个文件中不同的指定内容。但是每个文件要

替换的内容都不同，编写配置的成本大高了，反而化简为繁。

让我们依次在工作空间中找到以下模板文件并修改：

```Java
<#if needRedis>
redis:
    database: 1
    host: localhost
    port: 6379
    timeout: 5000
    password: ${mysqlConfig.password}
</#if>
@SpringBootApplication<#if !needRedis>(exclude = {RedisAutoConfiguration.class})</#if>
    <#if needRedis>
    <!-- redis -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.session</groupId>
        <artifactId>spring-session-data-redis</artifactId>
    </dependency>
</#if>
```

##### 编写配置

###### 测编写好模板后，我们依然可以使用模板制作工具来生成元信息配置。

在`resources/examples/springboot-init`目录下新建`templateMaker7.json`模板配置文件，代码如下：

##### 测试执行

执行成功,查看生成的元信息配置,符合预期

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=OGUxZTRiNTM1YmY1ZmM4MDVjNjI3Y2EyNzM4Nzk0ZTBfNzlmTjFOajNXVEZVSlcxQ1djSFg2VkI1WGE1c29rNkZfVG9rZW46RnpkV2J0S2Jtb3JMZ1V4Yk1qQWNtRDJ1bmhiXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

#### 8、需求: 控制是否开启ElasticSearch

##### 明确需求

允许用户传入`needEs`模型参数，控制是否开启和Elasticsearch相关的代码。需要修改和Elasticsearch相关的代码，比如PostController、.PostService、PostServicelmpl、application.yml等多个文件的部分代码。还要用`needEs`模型参数控制PostEsDTO整个文件是否生成。

##### 实现

这个需求比控制R©dis是否生成更复杂，也需要自己修改模板文件。

让我们依次在工作空间中找到以下模板文件并修改：

1)PostController.java.ftl文件：

```Java
<#if needEs>
/**
 * 分页搜索（从 ES 查询）
 *
 * @param postQueryRequest
 * @return
 */
@PostMapping("/search/page")
public BaseResponse<Page<Post>> searchPostByPage(@RequestBody PostQueryRequest postQueryRequest) {
    long size = postQueryRequest.getPageSize();
    // 限制爬虫
    ThrowUtils.throwIf(size > 20, ErrorCode.PARAMS_ERROR);
    Page<Post> postPage = postService.searchFromEs(postQueryRequest);
    return ResultUtils.success(postPage);
}
</#if>
```

2)PostServicelmpl.java.ftl文件：

```Java
<#if needEs>
@Override
public Page<Post> searchFromEs(PostQueryRequest postQueryRequest) {
    Long id = postQueryRequest.getId();
    Long notId = postQueryRequest.getNotId();
    String searchText = postQueryRequest.getSearchText();
    String title = postQueryRequest.getTitle();
    String content = postQueryRequest.getContent();
    List<String> tagList = postQueryRequest.getTags();
    List<String> orTagList = postQueryRequest.getOrTags();
    Long userId = postQueryRequest.getUserId();
    // es 起始页为 0
    long current = postQueryRequest.getCurrent() - 1;
    long pageSize = postQueryRequest.getPageSize();
    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
    // 过滤
    boolQueryBuilder.filter(QueryBuilders.termQuery("isDelete", 0));
    if (id != null) {
        boolQueryBuilder.filter(QueryBuilders.termQuery("id", id));
    }
    if (notId != null) {
        boolQueryBuilder.mustNot(QueryBuilders.termQuery("id", notId));
    }
    if (userId != null) {
        boolQueryBuilder.filter(QueryBuilders.termQuery("userId", userId));
    }
    // 必须包含所有标签
    if (CollectionUtil.isNotEmpty(tagList)) {
        for (String tag : tagList) {
            boolQueryBuilder.filter(QueryBuilders.termQuery("tags", tag));
        }
    }
    // 包含任何一个标签即可
    if (CollectionUtil.isNotEmpty(orTagList)) {
        BoolQueryBuilder orTagBoolQueryBuilder = QueryBuilders.boolQuery();
        for (String tag : orTagList) {
            orTagBoolQueryBuilder.should(QueryBuilders.termQuery("tags", tag));
        }
        orTagBoolQueryBuilder.minimumShouldMatch(1);
        boolQueryBuilder.filter(orTagBoolQueryBuilder);
    }
    // 按关键词检索
    if (StringUtils.isNotBlank(searchText)) {
        boolQueryBuilder.should(QueryBuilders.matchQuery("title", searchText));
        boolQueryBuilder.should(QueryBuilders.matchQuery("description", searchText));
        boolQueryBuilder.should(QueryBuilders.matchQuery("content", searchText));
        boolQueryBuilder.minimumShouldMatch(1);
    }
    // 按标题检索
    if (StringUtils.isNotBlank(title)) {
        boolQueryBuilder.should(QueryBuilders.matchQuery("title", title));
        boolQueryBuilder.minimumShouldMatch(1);
    }
    // 按内容检索
    if (StringUtils.isNotBlank(content)) {
        boolQueryBuilder.should(QueryBuilders.matchQuery("content", content));
        boolQueryBuilder.minimumShouldMatch(1);
    }
    // 分页
    PageRequest pageRequest = PageRequest.of((int) current, (int) pageSize);
    // 构造查询
    NativeSearchQuery searchQuery = new NativeSearchQueryBuilder().withQuery(boolQueryBuilder)
            .withPageable(pageRequest).build();
    SearchHits<PostEsDTO> searchHits = elasticsearchRestTemplate.search(searchQuery, PostEsDTO.class);
    Page<Post> page = new Page<>();
    page.setTotal(searchHits.getTotalHits());
    List<Post> resourceList = new ArrayList<>();
    // 查出结果后，从 db 获取最新动态数据（比如点赞数）
    if (searchHits.hasSearchHits()) {
        List<SearchHit<PostEsDTO>> searchHitList = searchHits.getSearchHits();
        List<Long> postIdList = searchHitList.stream().map(searchHit -> searchHit.getContent().getId())
                .collect(Collectors.toList());
        List<Post> postList = baseMapper.selectBatchIds(postIdList);
        if (postList != null) {
            Map<Long, List<Post>> idPostMap = postList.stream().collect(Collectors.groupingBy(Post::getId));
            postIdList.forEach(postId -> {
                if (idPostMap.containsKey(postId)) {
                    resourceList.add(idPostMap.get(postId).get(0));
                } else {
                    // 从 es 清空 db 已物理删除的数据
                    String delete = elasticsearchRestTemplate.delete(String.valueOf(postId), PostEsDTO.class);
                    log.info("delete post {}", delete);
                }
            });
        }
    }
    page.setRecords(resourceList);
    return page;
}
</#if>
```

3)PostService.java.ftl文件：

```Java
<#if needEs>
/**
 * 从 ES 查询
 *
 * @param postQueryRequest
 * @return
 */
Page<Post> searchFromEs(PostQueryRequest postQueryRequest);
</#if>
```

4)application.yml.ftl文件：

```YAML
<#if needEs>
# Elasticsearch 配置
# todo 需替换配置，然后取消注释
elasticsearch:
  uris: http://localhost:9200
  username: ${mysqlConfig.username}
  password: ${mysqlConfig.password}
</#if>
```

##### 编写配置

编写好模板后，我们依然可以使用模板制作工具来生成元信息配置。

在`resources/examples./springboot-init`目录下新建`templateMaker8.json`模板配置文件，代码如下：

```JSON
{
  "id": 1,
  "fileConfig": {
    "files": [
      {
        "path": "src/main/java/com/yupi/springbootinit/model/dto/post/PostEsDTO.java",
        "condition": "needPost && needEs"
      }
    ]
  },
  "modelConfig": {
    "models": [
      {
        "fieldName": "needEs",
        "type": "boolean",
        "description": "是否开启ES功能",
        "defaultValue": false
      }
    ]
  }
}
```

##### 测试执行

和之前的测试方法一样，在单元测试方法内补充读取新配置并制作模板的代码，如下

```Java
configStr = ResourceUtil.readUtf8Str(rootPath + "templateMaker8.json");
templateMakerConfig = JSONUtil.toBean(configStr, TemplateMakerConfig.class);
TemplateMaker.makeTemplate(templateMakerConfig);
```

执行成功，查看生成的元信息配置，发现控制Elasticsearch的模型参数正确生成：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YTdhNzM0OWU1MmY0ZGEyM2UwYmQ2ZmM0MmIzZGNmY2ZfWlFMNnQ2d0VCZG5jQWdENFBKdjN0OXdxaEhvUzFhNEtfVG9rZW46SU1NWmJhR3Bqb29PcGZ4R1oyaGNrd0p5blVlXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

但是，`PostEsDTO`文件配置却没有`condition`条件：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=OGNkOTVlYjZmZjBjNTZiZTJhOTkwNzY0ZWE0NzU5OTZfSkM3TG93Q2xHQjFuQmthOFRxMldmdzE1bkxTdHMySzNfVG9rZW46S2VSV2JPNGsxb0tPMFJ4T0EwaWNiM29xblJnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

这是因为PostEsDTO文件已经属于Post组，会被组内已有的配置覆盖。

所以我们要手动调整下PostEsDTO的生成策略，将它移动到组外，并指定condition条件，同时开启Post和

Es时才生成。

修改生成的meta.json文件，将组内的文件移到组外：

```Java
{
    "inputPath": "src/main/java/com/yupi/springbootinit/model/dto/post/PostEsDTO.java.ftl",
    "outputPath": "src/main/java/com/yupi/springbootinit/model/dto/post/PostEsDTO.java",
    "type": "file",
    "generateType": "dynamic",
    "condition": "needPost && needEs"
},
```

### 四、测试成果

#### 制作生成器

首先复制已生成的`meta.json`文件，复制为`resource`目录下的`springboot-init-meta.json`。

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmFiZDEyZTU4N2Q5MGE4ZGI2NzdiNzA1NDAyMGQ2NjBfQW1TcVhzcVU3UW45WmVHZW5pODdEc3NHeWE4dFY3c3ZfVG9rZW46WGVCWmJUYzQ5b1pHN2V4WWdNOGNVNHJnbldnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

然后修改`MetaManager`类，加载该文件，代码如下：

```Java
    private static Meta initMeta() {
//        String meatJson = ResourceUtil.readUtf8Str("meta.json");
        String meatJson = ResourceUtil.readUtf8Str("springboot-init-meta.json");
        Meta meta = JSONUtil.toBean(meatJson, Meta.class);
        // todo 校验配置参数是否合法, 处理默认值
        MetaValidator.doValidateAndFillDefaultValue(meta);
        return meta;
    }
```

最后执行制作工具的main方法，制作代码生成器！

#### 测试使用

命令执行无错误, 但是有中文乱码问题需要解决

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MWQ1YzA4YTc0MzdlYTg1MmNlYjc1NmZmOTA3ZmJjYjdfamM4c0FjbVY5TFlHc0c0Sm1zQVo2d3M1cHNPWm4xYVRfVG9rZW46RmF2TmJNc3Awb1JNNVV4c2hzSGNUdzFVbnNnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

## 八、云平台开发

### 一、需求分析

经过了前两个阶段本地项目的开发，其实绝大多数复杂的业务逻辑已经完成，接下来我们要实现项目的线上化就很

简单了。

首先思考，我们要对哪些内容进行线上化？要让用户线上使用哪些能力呢？

主要分为2个方面：

1)数据线上化

包括：

-   元信息线上化，即把元信息配置保存到数据库中。
-   项目模板线上化，即把静态文件和模板文件保存到存储服务上
-   代码生成器线上化，即把代码生成器产物包保存到存储服务上

2)功能线上化

包括：

-   在线查看生成器的信息
-   在线使用生成器
-   在线使用生成器制作工具

总结一下，我们本阶段要开发的在线代码生成平台，支持用户在线搜索、使用、制作和分享各类代码生成器，帮助

开发者提高定制化开发效率。

需要我们开发的功能如下：

-   用户注册、登绿
-   管理员功能：用户管理、代码生成器管理（增删改查）
-   代码生成器搜索
-   代码生成器详情查看
-   代码生成器创建
-   代码生成器下载
-   代码生成器在线使用
-   代码生成器在线制作

### 二、线上化实现流程

为了更快更好地完成本阶段项目，我们需要先整理下实现思路和流程。

大致的流程如下：

1)先完成库表设计，让数据库能支持存储代码生成器信息

2)实现基本的用户注册登绿、增删改查等功能，让用户能够浏览代码生成器信息

3)实现文件上传下载功能，让用户能够上传和下载代码生成器产物包

4)实现在线使用代码生成器功能，让用户直接在线生成代码

5)实现在线制作代码生成器功能，提高用户制作生成器效率

6)项目优化，包括性能优化、存储优化等

### 三、库表设计

设计库表的2个关键：

1.  一定要结合业务，以自己的业务需求为主
2.  多去参考同类业务的库表设计，可以多在GitHub搜下

直接复用后端万用模板的用户表，本项目我们选用最经典的账号密码登录，所以可以移除多余的公众号登录相关的

字段unionld和mpOpenld。

#### 用户表

用户表的建表SQL语句

```SQL
-- 用户表
create table if not exists user
(
    id           bigint auto_increment comment 'id' primary key,
    userAccount  varchar(256)                           not null comment '账号',
    userPassword varchar(512)                           not null comment '密码',
    userName     varchar(256)                           null comment '用户昵称',
    userAvatar   varchar(1024)                          null comment '用户头像',
    userProfile  varchar(512)                           null comment '用户简介',
    userRole     varchar(256) default 'user'            not null comment '用户角色：user/admin/ban',
    createTime   datetime     default CURRENT_TIMESTAMP not null comment '创建时间',
    updateTime   datetime     default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete     tinyint      default 0                 not null comment '是否删除',
    index idx_unionId (userAccount)
) comment '用户' collate = utf8mb4_unicode_ci;
```

#### 代码生成器表

代码生成器表是整个系统的核心，主要存储都以下几部分内容：

1.  代码生成器的元信息，包括基本信息、文件配置(fileConfig)、数据模型配置(modelConfig)等。
2.  便于吸引用户搜索和使用的信息，包括图片(picture)、标签列表(tagS)。
3.  代码生成器文件信息，主要是生成器产物文件的存储根路径(distPath)，从而支持用户下载生成器。
4.  代码生成器的状态(stātus)，用于表示代码生成器的制乍状态、是否可用等。默认是0，后面会持续补充更多状态。

这些只是目前需要的核心字段，后续可能会补充更多需要的字段。

代码生成器表的建表SQL语句

```SQL
-- 代码生成器表
create table if not exists generator
(
    id          bigint auto_increment comment 'id' primary key,
    name        varchar(128)                       null comment '名称',
    description text                               null comment '描述',
    basePackage varchar(128)                       null comment '基础包',
    version     varchar(128)                       null comment '版本',
    author      varchar(128)                       null comment '作者',
    tags        varchar(1024)                      null comment '标签列表(json 数组)',
    picture     varchar(256)                       null comment '图片',
    fileConfig  text                               null comment '文件配置(json 字符串)',
    modelConfig text                               null comment '模型配置(json 字符串)',
    distPath    text                               null comment '代码生成器产物路径',
    status      int      default 0                 not null comment '状态',
    userId      bigint                             not null comment '创建用户 id',
    createTime  datetime default CURRENT_TIMESTAMP not null comment '创建时间',
    updateTime  datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete    tinyint  default 0                 not null comment '是否删除',
    index idx_userId (userId)
) comment '代码生成器' collate = utf8mb4_unicode_ci;
```

#### 模拟数据

设计好库表后，我们可以自己造一些基本数据，为后面开发测试时做准备。

用户表模拟数据

```SQL
INSERT INTO manneia_generator_db.user(id,userAccount,userPassword,userName,userAvatar,userProfile,userRole) VALUES (1,'claw','df3f595406c59c46af221924d171f30f','管理员豹警官','https://i0.hdslb.com/bfs/archive/502c3df0d2d64d7f60819e8dda97e3c1e59efdf2.jpg','豹警官：勇敢维护动物城和平，夏奇羊粉丝，甜甜圈的忠实爱好者。','admin');
INSERT INTO manneia_generator_db.user(id,userAccount,userPassword,userName,userAvatar,userProfile,userRole) VALUES (2,'claw2','df3f595406c59c46af221924d171f30f','档案室豹警官','https://gw.alipayobjects.com/zos/rmsportal/BiazfanxmamNRoxxVxka.png','豹警官：勇敢维护动物城和平，夏奇羊粉丝，甜甜圈的忠实爱好者。','user');    
```

代码生成器表模拟数据

```SQL
INSERT INTO manneia_generator_db.generator(id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId) VALUES (1,'ACM 模板项目','ACM 模板项目生成器','com.dexcode','1.0','管理员豹警官','["Java"]','https://pic.yupi.icu/1/_r0_c1851-bf115939332e.jpg','{}','{}',null,0,1);
INSERT INTO manneia_generator_db.generator(id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId) VALUES (2,'Spring Boot 初始化模板','Spring Boot 初始化模板项目生成器','com.dexcode','1.0','管理员豹警官','["Java"]','https://pic.yupi.icu/1/_r0_c0726-7e30f8db802a.jpg','{}','{}',null,0,1);
INSERT INTO manneia_generator_db.generator(id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId) VALUES (3,'鱼皮外卖','鱼皮外卖项目生成器','com.dexcode','1.0','管理员豹警官','["Java", "前端"]','https://pic.yupi.icu/1/_r1_c0cf7-f8e4bd865b4b.jpg','{}','{}',null,0,1);
INSERT INTO manneia_generator_db.generator(id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId) VALUES (4,'鱼皮用户中心','鱼皮用户中心项目生成器','com.dexcode','1.0','管理员豹警官','["Java", "前端"]','https://pic.yupi.icu/1/_r1_c1c15-79cdecf24aed.jpg','{}','{}',null,0,1);
INSERT INTO manneia_generator_db.generator(id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId) VALUES (5,'鱼皮API开放平台','鱼皮API开放平台项目生成器','com.dexcode','1.0','管理员豹警官','["Java", "前端"]','https://pic.yupi.icu/1/_r1_c0709-8e80689ac1da.jpg','{}','{}',null,0,1);
```

### 四、后端开发

#### **后端项目初始化**

1.  **项目信息替换**

步骤1：

快捷键 Ctrl + Shift + R 将`springboot-init`替换为:`manneia-generator-web-backend`，并将子项目目录改为`manneia-generator-web-backend`

步骤2：

快捷键 Shift +F6 将`yupi.springbootinit`替换为：`manneia.web`（自己的包名.web，也可只换web)

快捷键 Ctrl + Shift + R 将`yupi.springbootinit`替换为：`manneia.web`，**避免**重构时有遗漏

步骤3：

修改`application.yml`，启动端口号为 8120 

1.  **项目瘦身**

从项目模板中移除与本项目无关的功能和代码，包括：

-   微信公众号、公众号登录相关代码
-   Elasticsearch 搜索
-   Easy Excel 表格读写
-   所有的单元测试代码
-   帖子点赞和收藏功能

目录从上往下一次删除

`sql`中：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MjY0ZjBmZjk4Y2Y5NzEzNDMwN2E5NDkzMGRlMzQzZGZfOENUSENhcVdzeXRaTFZVMFdLa21mb01qNndjREF2ZlhfVG9rZW46S1NuMWJ3cVJ3b1hmT254bkhUNWNzcUFibnRkXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

`config`中：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=OTRlMDIzODJiYjgwZTBmZDdiNjBjZTM5Zjc2OGEzZmFfV0l5YlJkUTJFSWRhZzNtUXB1Z01hVGpXakNZWVplYklfVG9rZW46T3hIQWJmV0N5bzlDcER4NTRUQWNMQjR6bnBmXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

`controller`中：

`esdao、job`直接删除

`mapper`中：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NzUyNzQxODBjMWUwNDA0ZTFlMjIyNDIzZjhmMTc0YmFfZkVkZ2plcGttVU5UQTRPdXlEdml0V0J5Q0xwRWo0emJfVG9rZW46WFR4NWI4TWQyb285Ylh4c0FMMWNRWWVabnlkXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

`model`中：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NzM4ZTI0NDg2ZTQ3YjlkMDNmM2I0ZjVjNzExNTI2NzdfZ1YxSjM0ZFRaSm1EVGVaOE1rRjlOalY5clA5bk95bG9fVG9rZW46SW5veGI2MTQ3bzNBQWx4TGRtbmNCMll4bk9nXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

`service`中：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGEyMTQxNzQ2MjRmOWMzOGIzNzFmYjRjYmUxYmY1OWRfeGZHT3ZXR2dsVEhOTmMyR0VvR1RTT1NmSkJxb2RPOG5fVG9rZW46S01kb2JxVmk2b2tQblR4MExGNGNSbW1UbnNkXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

`wxmp`直接删除

```
res
```

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=N2ZhOTJjOGJmYzRmMDlkNWYzOTI5NGQzM2I4MWYwMThfa0Nvd1FwNlRjQ0ZWRXZqMnF1empMVnMyUjltc0xiTUxfVG9rZW46RkppVWIzZEJQb2lrREl4VTNFcGNaOEZVbmxnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

`test`测试代码全部删除

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MmI2N2EwNzkwZDk2ZmNlOTNhNWIxOGMyOTcwYWNlNjRfTnlOOG9DZG94TWJTZ0VmTnRKSnJaTEVPTUZSc1kzaFFfVG9rZW46UklLNGJNeEJ6b1BuTlV4UXo0dmNyU01DblJjXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

**先删文件，再删代码（默认此处已经删完了上述文件了）**

`pom.xml`可以移除的依赖：

```XML
<!-- elasticsearch-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-elasticsearch</artifactId>
</dependency>
<!-- https://mvnrepository.com/artifact/com.github.binarywang/wx-java-mp-spring-boot-starter -->
<dependency>
    <groupId>com.github.binarywang</groupId>
    <artifactId>wx-java-mp-spring-boot-starter</artifactId>
    <version>4.4.0</version>
</dependency>
application.yml`删除`#微信相关
```

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjJiODMxMTY5NGYxYzlkNWVlZmI3NzhjMTE5ZmYzNjZfdHB4YzFPc0V6c2Y5SHp6b2llckt6SXcxVTJjZ0RpSGFfVG9rZW46TTJSamJia2xsb0NIRm14eHFVNGN6aGp4bmZzXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

全局搜索`unionId`，顺带删除`mpOpenId`：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NzVlYjIzZWY4NTQzY2RmMDIwOTIzZTQzYmIzNGNlZDJfTDVidURjbmV4NUhLaDdKcDdsMWJQS0xxVE1mTEg4TjRfVG9rZW46QjF5V2Jtekhkb25UMXV4YXpzamNpV2J6bldkXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

跟着**爆红**的地方一步步删：

-   UserService、UserServiceImpl、UserController
-   PostService、PostServiceImpl （删除`private ElasticsearchRestTemplate elasticsearchRestTemplate;` `// 2. 已登录，获取用户点赞、收藏状态`）、PostController

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YWU2NDlhZjM3ODM1NWEyZjNiMjQ3Yjg0Y2E2MWRhMzRfTGZoR3lBM1RyMmJwc2xMdk1wTFpJWldUSXREclUxQ3lfVG9rZW46R3o5dGJVamJnb3c4OW94U2RJcmNJT09TbnJmXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ODQ4NWMwMTdiYjRjYTljM2VmMmY0NWY5N2JkZTQxYzNfZWNoRzNRN1h2VGpkTjRVZTFuWk94Yk1MU2x5WnRRa29fVG9rZW46SXlERmJyWkgzbzFmcVF4dFlObWM3TVQyblVoXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MzVkMjE3ZmFkZmE4NjFmYmMyZDczOGM3MDg4ZGMzMGNfWWVoVWdoSWl4aFl3MGUxejNNUlJrQmdESEI0VWRnQUJfVG9rZW46UWQwR2JLa1R1b1czSzB4cDVndGNaYWt2bnJnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

删除代码之后，优化一下 import，格式化代码：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=OWVlMzVmYjUwN2UwOWIzM2E1ZjhkYTYzMjczOWJhM2VfdDlaSXoxY0dGYnVINHRGSTRXbWdNbWZXQm1PMjJOT0ZfVG9rZW46Q2ZkWWJOUzRFb1BDenR4aHNrOWNkSnREbmJlXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

可以在这里美美的**提交一次代码**，接下来就要开始业务相关的开发了……

#### **用户功能**

由于项目模板已经提供了现成的用户注册、用户登录、权限管理校验等功能，无需额外开发

可以启动项目，访问接口文档地址：http://localhost:8120/api/doc.html，测试用户登录、获取用户列表等功能

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=OTQ0ODhkZTE4MGVjNDBjNDJiZDk3OGI0ZGM1ODUyZjlfUWJDeW9YRHRHTWxXeGthcVZoTXhjSEg0cFlzYnJVVlNfVG9rZW46WjYwVmJaMHd1b3dRTFZ4TldDR2Npakl1bnRnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

#### **代码生成器功能**

1.  ##### MyBatisX 代码生成

按图示操作

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=OGMwYTEwZjRkZGM2ZDQzYzZmMmRjMmE1ZmVmYTQ1OTlfOEN3dXNxNzBBbXNBbHVSeVJZQXpWRGd2QkZvNktOQTJfVG9rZW46SmhqdWJoZlhTb1JSQXF4ZjJiZGNhVjBMbnpQXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ODQzMTQzYjg5NTllYzI3ZmE3NDY1MDhhOWJkZGNiNjBfb294ZE14QlI4TG40ZlFPVXY2R0U3bG1KcG5uNG9QbXVfVG9rZW46QkZKcWJjZU50b2c0S094cmozemNYdHRhbmJlXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YzNiZjQ1Nzc0NGM3MmJkNTYzMDIyMzc4OTVlOWU3OTRfUWNzdGdSRDU1VVl3TkN5VDV0SXNGaGY0RVBtQ0J3bzRfVG9rZW46U0lPRGIxcWVBbzZLaTR4azRKUmNBRjJUblBoXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

将generator目录中生成的文件**拖拽**到`com.XXX.web`目录下对应包中**（service可以不用拖，过会直接在PostXXX中修改）**

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NmFlOTY1MTk2OThmNmRhYzFiMjQ3YjQzYjZmMmQyNjBfNmIwSEtKSzRud05vaHJqNUV4Mko1SnY3eHZldmxYbHpfVG9rZW46SlN4UWJ4dlZSb0FqS094TDdnM2NKZWNrbmY4XzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

**注意，****`resources/mapper/GeneratorMapper.xml`****文件**中的mapper包和实体类的**路径！**

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NTJlOWFhMDRmMTIyMjQ1MzVkMDk5N2VjNGIyZGIwNDdfdnZFVU5yT2tOZjNQQlY1d2V1b1lRUWFxNnJ1UThQdkxfVG9rZW46WnBlZmJCM2JWb2FsQTV4ZnZ6eWNkM050bklnXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

删除generator包 👌

1.  ##### 数据模型开发

修改 Generator 实体类代码：

-   为`isDelete`字段加上逻辑删除注解

```Java
/**
 * id
 */
@TableId(type = IdType.ASSIGN_ID)
private Long id;

...

/**
 * 是否删除
 */
@TableLogic
private Integer isDelete;
```

1.  将`model`包下 PostXXX 文件，依次 Shift + F6 重构为 GeneratorXXX 文件

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTQ3YzFiNmJjOTRkODhlY2I2MTQ0OWIyOWNhYTE0MGFfTXJZY2VHNEFaNEc3TG9SUTlxUDBTbUE0a3FPSE9JSTRfVG9rZW46SkhpdGJUaVZKb3VTYmd4c01paGNmVzJXbnVmXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDBmM2Q4YjNmMzFhNTIzYzhhNWI2MDA2MjExMGZmZGZfTWFnekZpVkVMQURvSkd0OWlEM3dtVE56eFo4cjJ4NUVfVG9rZW46Ulpaa2JTVm9Rb3pqN294aEtydGNNc2VvbkxiXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

重构时，要**选中**其他类中用到的此类，如图所示

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTg5NWE4OWViZDczYTBmM2ExYWY2OWZmN2Q1Y2Q4MDFfbVlOaTJvNjFXS1o0N3piNW1wbGRIMHU1VzZaU2dxWlRfVG9rZW46RFA2eGI2V0RIb3lFS2h4cEZaUWNFUVo0bmpoXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

从Generator 实体类中复制字段，根据业务需求进行筛选

(需复制粘贴之前在 maker 项目中的 **Meta实体类**，用于前端接收的 fileConfig和modelConfig 字段类型)

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MTIyZGIwYjE2NzExM2Q0MGEzODdlNGI2ZDQ3MDg5ZjNfWnBhMlBpTXdLWTJuNHduYlp6ejBGRUZ1dXNPczQ3S3VfVG9rZW46WTFKZmJKTW1Jb0I1Wk54ckZyZWNzYjBsbmRjXzE3MTEwNzgxNzk6MTcxMTA4MTc3OV9WNA)

**注意：**edit是用户可编辑（权限较低），update是管理员可更新（权限较高）

```Java
/**
 * 创建请求
 */
@Data
public class GeneratorAddRequest implements Serializable {

    /**
     * 名称
     */
    private String name;

    /**
     * 描述
     */
    private String description;

    /**
     * 基础包
     */
    private String basePackage;

    /**
     * 版本
     */
    private String version;

    /**
     * 作者
     */
    private String author;

    /**
     * 标签列表（json 数组）
     */
    private List<String> tags;

    /**
     * 图片
     */
    private String picture;

    /**
     * 文件配置（json 字符串）
     */
    private Meta.FileConfig fileConfig;

    /**
     * 模型配置（json 字符串）
     */
    private Meta.ModelConfig modelConfig;

    /**
     * 代码生成器产物路径
     */
    private String distPath;

    /**
     * 状态
     */
    private Integer status;

    private static final long serialVersionUID = 1L;
}
/**
 * 编辑请求
 */
@Data
public class GeneratorEditRequest implements Serializable {

    /**
     * id
     */
    private Long id;

    /**
     * 名称
     */
    private String name;

    /**
     * 描述
     */
    private String description;

    /**
     * 基础包
     */
    private String basePackage;

    /**
     * 版本
     */
    private String version;

    /**
     * 作者
     */
    private String author;

    /**
     * 标签列表（json 数组）
     */
    private List<String> tags;

    /**
     * 图片
     */
    private String picture;

    /**
     * 文件配置（json 字符串）
     */
    private Meta.FileConfig fileConfig;

    /**
     * 模型配置（json 字符串）
     */
    private Meta.ModelConfig modelConfig;

    /**
     * 代码生成器产物路径
     */
    private String distPath;

    private static final long serialVersionUID = 1L;
}
/**
 * 查询请求
 */
@EqualsAndHashCode(callSuper = true)
@Data
public class GeneratorQueryRequest extends PageRequest implements Serializable {

    /**
     * id
     */
    private Long id;

    /**
     * id
     */
    private Long notId;

    /**
     * 搜索词
     */
    private String searchText;

    /**
     * 标签列表
     */
    private List<String> tags;

    /**
     * 至少有一个标签
     */
    private List<String> orTags;

    /**
     * 创建用户 id
     */
    private Long userId;

    /**
     * 名称
     */
    private String name;

    /**
     * 描述
     */
    private String description;

    /**
     * 基础包
     */
    private String basePackage;

    /**
     * 版本
     */
    private String version;

    /**
     * 作者
     */
    private String author;

    /**
     * 代码生成器产物路径
     */
    private String distPath;

    /**
     * 状态
     */
    private Integer status;

    private static final long serialVersionUID = 1L;
}
/**
 * 更新请求
 */
@Data
public class GeneratorUpdateRequest implements Serializable {

    /**
     * id
     */
    private Long id;

    /**
     * 名称
     */
    private String name;

    /**
     * 描述
     */
    private String description;

    /**
     * 基础包
     */
    private String basePackage;

    /**
     * 版本
     */
    private String version;

    /**
     * 作者
     */
    private String author;

    /**
     * 标签列表（json 数组）
     */
    private List<String> tags;

    /**
     * 图片
     */
    private String picture;

    /**
     * 文件配置（json 字符串）
     */
    private Meta.FileConfig fileConfig;

    /**
     * 模型配置（json 字符串）
     */
    private Meta.ModelConfig modelConfig;

    /**
     * 代码生成器产物路径
     */
    private String distPath;

    /**
     * 状态
     */
    private Integer status;

    private static final long serialVersionUID = 1L;
}
```

**前端**接收和处理 Java对象类型，**后端**数据表记录的是 JSON 字符串，字段tags、fileConfig、modelConfig 需要做一些转换，在包装类`GeneratorVO`中提供了相互转换的代码

```Java
/**
 * 代码生成器视图
 */
@Data
public class GeneratorVO implements Serializable {

    /**
     * 创建人信息
     */
    private UserVO user;

    /**
     * id
     */
    private Long id;

    /**
     * 名称
     */
    private String name;

    /**
     * 描述
     */
    private String description;

    /**
     * 基础包
     */
    private String basePackage;

    /**
     * 版本
     */
    private String version;

    /**
     * 作者
     */
    private String author;

    /**
     * 标签列表（json 数组）
     */
    private List<String> tags;

    /**
     * 图片
     */
    private String picture;

    /**
     * 文件配置（json 字符串）
     */
    private Meta.FileConfig fileConfig;

    /**
     * 模型配置（json 字符串）
     */
    private Meta.ModelConfig modelConfig;

    /**
     * 代码生成器产物路径
     */
    private String distPath;

    /**
     * 状态
     */
    private Integer status;

    /**
     * 创建用户 id
     */
    private Long userId;

    /**
     * 创建时间
     */
    private Date createTime;

    /**
     * 更新时间
     */
    private Date updateTime;

    private static final long serialVersionUID = 1L;

    /**
     * 包装类转对象
     *
     * @param generatorVO
     * @return
     */
    public static Generator voToObj(GeneratorVO generatorVO) {
        if (generatorVO == null) {
            return null;
        }
        Generator generator = new Generator();
        BeanUtils.copyProperties(generatorVO, generator);
        // 把对象转换成JSON字符串
        List<String> tagList = generatorVO.getTags();
        generator.setTags(JSONUtil.toJsonStr(tagList));
        Meta.FileConfig fileConfig = generatorVO.getFileConfig();
        generator.setFileConfig(JSONUtil.toJsonStr(fileConfig));
        Meta.ModelConfig modelConfig = generatorVO.getModelConfig();
        generator.setModelConfig(JSONUtil.toJsonStr(modelConfig));
        return generator;
    }

    /**
     * 对象转包装类
     *
     * @param generator
     * @return
     */
    public static GeneratorVO objToVo(Generator generator) {
        if (generator == null) {
            return null;
        }
        GeneratorVO generatorVO = new GeneratorVO();
        BeanUtils.copyProperties(generator, generatorVO);
        generatorVO.setTags(JSONUtil.toList(generator.getTags(), String.class));
        generatorVO.setFileConfig(JSONUtil.toBean(generator.getFileConfig(), Meta.FileConfig.class));
        generatorVO.setModelConfig(JSONUtil.toBean(generator.getModelConfig(), Meta.ModelConfig.class));
        return generatorVO;
    }
}
```

>   想要更高效的实现对象转换、属性复制，还可以考虑用`MapStruct`映射框架

1.  ##### 业务逻辑开发

开发好数据模型后，就可以根据业务需求编写 Service 和 Controller 代码

全局替换 **（注意限定大小写）**post --> generator，Post --> Generator，**GeneratorMapping --> PostMapping**

`GeneratorServiceImpl.java`中，修改 validGenerator 和 getQueryWrapper 方法，代码如下：

（Post相关的 title --> name，content --> description）

```Java
@Override
public void validGenerator(Generator generator, boolean add) {
    if (generator == null) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    // todo 暂时只校验 name 和 description
    String name = generator.getName();
    String description = generator.getDescription();

    // 创建时，参数不能为空
    if (add) {
        ThrowUtils.throwIf(StringUtils.isAnyBlank(name, description), ErrorCode.PARAMS_ERROR);
    }
    // 有参数则校验
    if (StringUtils.isNotBlank(name) && name.length() > 80) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "名称过长");
    }
    if (StringUtils.isNotBlank(description) && description.length() > 256) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "描述过长");
    }
}

/**
 * 获取查询包装类
 *
 * @param generatorQueryRequest
 * @return
 */
@Override
public QueryWrapper<Generator> getQueryWrapper(GeneratorQueryRequest generatorQueryRequest) {
    QueryWrapper<Generator> queryWrapper = new QueryWrapper<>();
    if (generatorQueryRequest == null) {
        return queryWrapper;
    }
    Long id = generatorQueryRequest.getId();
    Long notId = generatorQueryRequest.getNotId();
    String searchText = generatorQueryRequest.getSearchText();

    List<String> tags = generatorQueryRequest.getTags();
    Long userId = generatorQueryRequest.getUserId();
    String name = generatorQueryRequest.getName();
    String description = generatorQueryRequest.getDescription();
    String basePackage = generatorQueryRequest.getBasePackage();
    String version = generatorQueryRequest.getVersion();
    String author = generatorQueryRequest.getAuthor();
    String distPath = generatorQueryRequest.getDistPath();
    Integer status = generatorQueryRequest.getStatus();

    String sortField = generatorQueryRequest.getSortField();
    String sortOrder = generatorQueryRequest.getSortOrder();

    // 拼接查询条件
    if (StringUtils.isNotBlank(searchText)) {
        queryWrapper.and(qw -> qw.like("name", searchText).or().like("description", searchText));
    }
    queryWrapper.like(StringUtils.isNotBlank(name), "name", name);
    queryWrapper.like(StringUtils.isNotBlank(description), "description", description);
    if (CollUtil.isNotEmpty(tags)) {
        for (String tag : tags) {
            queryWrapper.like("tags", "\"" + tag + "\"");
        }
    }
    queryWrapper.ne(ObjectUtils.isNotEmpty(notId), "id", notId);
    queryWrapper.eq(ObjectUtils.isNotEmpty(id), "id", id);
    queryWrapper.eq(ObjectUtils.isNotEmpty(userId), "userId", userId);
    queryWrapper.eq(StringUtils.isNotBlank(basePackage), "basePackage", basePackage);
    queryWrapper.eq(StringUtils.isNotBlank(version), "version", version);
    queryWrapper.eq(StringUtils.isNotBlank(author), "author", author);
    queryWrapper.eq(StringUtils.isNotBlank(distPath), "distPath", distPath);
    queryWrapper.eq(ObjectUtils.isNotEmpty(status), "status", status);
    queryWrapper.orderBy(SqlUtils.validSortField(sortField), sortOrder.equals(CommonConstant.SORT_ORDER_ASC),
            sortField);
    return queryWrapper;
}
```

将`GeneratorController`中 `addGeneratorupdateGeneratoreditGenerator`方法以下修改，将前端dto 的请求对象转成 JSON 字符串，写进数据库

```Java
List<String> tags = postAddRequest.getTags();
if (tags != null) {
    post.setTags(JSONUtil.toJsonStr(tags));
}
// 替换为
generator.setTags(JSONUtil.toJsonStr(generatorAddRequest.getTags()));
generator.setFileConfig(JSONUtil.toJsonStr(generatorAddRequest.getFileConfig()));
generator.setModelConfig(JSONUtil.toJsonStr(generatorAddRequest.getModelConfig()));
```

`addGenerator`方法中还要设置 status，默认为0

```Java
/**
 * 创建
 *
 * @param generatorAddRequest
 * @param request
 * @return
 */
@PostMapping("/add")
public BaseResponse<Long> addGenerator(@RequestBody GeneratorAddRequest generatorAddRequest, HttpServletRequest request) {
    if (generatorAddRequest == null) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    Generator generator = new Generator();
    BeanUtils.copyProperties(generatorAddRequest, generator);
    generator.setTags(JSONUtil.toJsonStr(generatorAddRequest.getTags()));
    generator.setFileConfig(JSONUtil.toJsonStr(generatorAddRequest.getFileConfig()));
    generator.setModelConfig(JSONUtil.toJsonStr(generatorAddRequest.getModelConfig()));
    // 参数校验
    generatorService.validGenerator(generator, true);
    User loginUser = userService.getLoginUser(request);
    generator.setUserId(loginUser.getId());
        // 设置 status，默认为0
    generator.setStatus(0);
    boolean result = generatorService.save(generator);
    ThrowUtils.throwIf(!result, ErrorCode.OPERATION_ERROR);
    long newGeneratorId = generator.getId();
    return ResultUtils.success(newGeneratorId);
}
```

最后，删除模板中多余的帖子（Post）相关代码

1.  ##### 测试

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MzllODNlZDg4NDgwNjIwMTVmMjM4ZDZmOWVmN2M1NWNfN2xBQlQyZ0lFaHZ4anpkY25mbW5mSmcwYVRFSGxvZENfVG9rZW46VlZXb2J1UlJLb09oZmF4eGlUdWNJeDdRbnBiXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

### 五、前端开发

为了提高开发效率，我们直接使用编程导航的万用前端模板(React+Ant Design实现)，在此基础上进行开

发。

#### 前端项目初始化

##### 1、项目信息修改

1)   在项目文件打开终端, 使用命令 `npm install`下载依赖

1.  使用全局替换,对标题和描述进行修改

标题改为: 代码生成

描述改为: 代码生成器在线制作共享,大幅提升开发效率

1.  替换网站logo

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=N2EwMTYxOTAzODU1M2JlMjE1ZDdhZTg2ZmRjNmNiZDdfSXRrNVF3VXFNdlZaQUMxUzdGZzc1a2RIb00zZG1uRnBfVG9rZW46WGJ4UWJrSEZGb3RSdWx4SVRPS2NzNjVCbldiXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

然后在`app.tsx`的layout配置中引入Logo文件

##### 2、请求处理

1)   修改`constant/index.ts`中的后端请求地址,本地和后端改为一致:

```TypeScript
/**
 * 本地后端地址
 */
export const BACKEND_HOST_LOCAL = "http://localhost:8120/";
```

2)   根据后端接口文档生成前端请求和TypeScript类型代码

修改`config.ts`的`OpenAPi`配置,将schemaPath改为后端接口文档数据地址

```TypeScript
openAPI: [
  {
    requestLibPath: "import { request } from '@umijs/max'",
    schemaPath: 'http://localhost:8120/api/v2/api-docs',
    projectName: 'backend',
  },
],
```

#### 用户注册页面

1.  ##### 先增加注册页面的路由

```TypeScript
{
  path: '/user',
  layout: false,
  routes: [
    {
      path: '/user/login',
      component: './User/Login',
    },
    {
      path: '/user/register',
      component: './User/Register'
    }
  ],
},
```

1.  ##### 直接复制登录页面, 对表单进行一些修改即可

完整代码如下:

```TypeScript
import Footer from '@/components/Footer';
import {userLoginUsingPost, userRegisterUsingPost} from '@/services/backend/userController';
import { LockOutlined, UserOutlined } from '@ant-design/icons';
import { LoginForm, ProFormText } from '@ant-design/pro-components';
import { useEmotionCss } from '@ant-design/use-emotion-css';
import { Helmet, history, useModel } from '@umijs/max';
import { message, Tabs } from 'antd';
import React, { useState } from 'react';
import Settings from '../../../../config/defaultSettings';
import {Link} from "umi";

/**
 * 用户注册页面
 * @constructor
 */
const UserRegisterPage: React.FC = () => {
  const [type, setType] = useState<string>('account');
  const { initialState, setInitialState } = useModel('@@initialState');
  const containerClassName = useEmotionCss(() => {
    return {
      display: 'flex',
      flexDirection: 'column',
      height: '100vh',
      overflow: 'auto',
      backgroundImage:
        "url('https://mdn.alipayobjects.com/yuyan_qk0oxh/afts/img/V-_oS6r-i7wAAAAAAAAAAAAAFl94AQBr')",
      backgroundSize: '100% 100%',
    };
  });

  const handleSubmit = async (values: API.UserRegisterRequest) => {
    try {
      // 注册
     await userRegisterUsingPost({
        ...values,
      });

      const defaultLoginSuccessMessage = '注册成功！';
      message.success(defaultLoginSuccessMessage);
      history.push("/user/login");
      return;
    } catch (error: any) {
      const defaultLoginFailureMessage = `注册失败，${error.message}`;
      message.error(defaultLoginFailureMessage);
    }
  };

  return (
    <div className={containerClassName}>
      <Helmet>
        <title>
          {'注册'}- {Settings.title}
        </title>
      </Helmet>
      <div
        style={{
          flex: '1',
          padding: '32px 0',
        }}
      >
        <LoginForm
          contentStyle={{
            minWidth: 280,
            maxWidth: '75vw',
          }}
          logo={<img alt="logo" style={{ height: '100%' }} src="/logo.png" />}
          title="代码生成"
          subTitle={'代码生成器在线制作共享,大幅提升开发效率'}
          initialValues={{
            autoLogin: true,
          }}
          submitter={{
              searchConfig:{
                  submitText: '注册'
              }
          }}
          onFinish={async (values) => {
            await handleSubmit(values as API.UserLoginRequest);
          }}
        >
          <Tabs
            activeKey={type}
            onChange={setType}
            centered
            items={[
              {
                key: 'account',
                label: '新用户注册',
              },
            ]}
          />
          {type === 'account' && (
            <>
              <ProFormText
                name="userAccount"
                fieldProps={{
                  size: 'large',
                  prefix: (
                    <UserOutlined
                      onPointerEnterCapture={undefined}
                      onPointerLeaveCapture={undefined}
                    />
                  ),
                }}
                placeholder={'请输入账号'}
                rules={[
                  {
                    required: true,
                    message: '账号是必填项！',
                  },
                ]}
              />
              <ProFormText.Password
                name="userPassword"
                fieldProps={{
                  size: 'large',
                  prefix: (
                    <LockOutlined
                      onPointerEnterCapture={undefined}
                      onPointerLeaveCapture={undefined}
                    />
                  ),
                }}
                placeholder={'请输入密码'}
                rules={[
                  {
                    required: true,
                    message: '密码是必填项！',
                  },
                ]}
              />
                <ProFormText.Password
                    name="checkPassword"
                    fieldProps={{
                        size: 'large',
                        prefix: (
                            <LockOutlined
                                onPointerEnterCapture={undefined}
                                onPointerLeaveCapture={undefined}
                            />
                        ),
                    }}
                    placeholder={'请再次输入密码'}
                    rules={[
                        {
                            required: true,
                            message: '确认密码是必填项！',
                        },
                    ]}
                />
            </>
          )}

          <div
            style={{
              marginBottom: 24,
              textAlign: 'right',
            }}
          >
            <Link to="/user/Login">老用户登录</Link>
          </div>
        </LoginForm>
      </div>
      <Footer />
    </div>
  );
};
export default UserRegisterPage;
```

界面效果

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2E2N2M5ZDk0NDNjNDNiZDY2M2FhNjllZjI4Nzg5Y2RfRDdkbm9vMjRIMGZwWE1FQjFSckw1WHo1aTdDVGNPeFZfVG9rZW46RWp2OGJjc1Zwb0g2bFR4eHo4MGNpWnJGbldoXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

#### 管理页面

1.  ##### 先增加页面路由

```TypeScript
{
  path: '/admin',
  icon: 'crown',
  name: '管理页',
  access: 'canAdmin',
  routes: [
    { path: '/admin', redirect: '/admin/user' },
    { icon: 'table', path: '/admin/user', component: './Admin/User', name: '用户管理' },
    { icon: 'tools', path: '/admin/generator', component: './Admin/Generator', name: '生成器管理' }
  ],
},
```

1.  ##### 直接复制用户管理页面,然后替换`User`和`user`为`Generator`和`generator`

1.  ##### 根据生成器表的字段修改表格列columns配置,需要注意尤其注意标签的渲染

标签列的配置如下:

```TypeScript
  {
    title: '标签',
    dataIndex: 'tags',
    valueType: 'text',
    // 关于标签的特殊处理 "tags": "[\"Java\"]"
    renderFormItem: (schema) => {
      // 将编辑器原本的属性，添加到我们自定义的属性中
      const { fieldProps } = schema;
      // @ts-ignore
      // eslint-disable-next-line react/jsx-no-undef
      return <Select mode="tags" {...fieldProps} />;
    },
    // 第二个参数，当前记录的信息
    render(_, record) {
      if (!record.tags) {
        return <></>;
      }
      // 存在，字符串解析成数组，再用map遍历数组的每一项，将其渲染成tag标签
      return JSON.parse(record.tags).map((tag: string) => {
        // key是数组下元素的唯一标识
        return <Tag key={tag}>{tag}</Tag>;
      });
    },
  },
```

1.  ##### 分别测试查询搜索,删除,新建,修改操作,针对有异常的代码进行修复

2.  比如创建函数中,需要将JSON字符串转换为JS对象

```TypeScript
/**
 * 添加节点
 * @param fields
 */
const handleAdd = async (fields: API.GeneratorAddRequest) => {
  // 关于文件/模型配置的特殊处理
  fields.fileConfig = JSON.parse((fields.fileConfig || '{}') as string);
  fields.modelConfig = JSON.parse((fields.modelConfig || '{}') as string);
  const hide = message.loading('正在添加');
  try {
    await addGeneratorUsingPost(fields);
    hide();
    message.success('创建成功');
    return true;
  } catch (error: any) {
    hide();
    message.error('创建失败，' + error.message);
    return false;
  }
};
```

2)   修改操作中,注意给tags增加默认值

```TypeScript
         initialValues: {
            ...oldData,
            tags: JSON.parse(oldData.tags || '[]'),
          },
```

生成器管理页面的完整代码如下:

```TypeScript
import CreateModal from '@/pages/Admin/Generator/components/CreateModal';
import UpdateModal from '@/pages/Admin/Generator/components/UpdateModal';
import {
  deleteGeneratorUsingPost,
  listGeneratorByPageUsingPost,
} from '@/services/backend/generatorController';
import { PlusOutlined } from '@ant-design/icons';
import type { ActionType, ProColumns } from '@ant-design/pro-components';
import { ProTable } from '@ant-design/pro-components';
import '@umijs/max';
import { Button, message, Select, Space, Tag, Typography } from 'antd';
import React, { useRef, useState } from 'react';

/**
 * 代码生成器管理页面
 *
 * @constructor
 */
const GeneratorAdminPage: React.FC = () => {
  // 是否显示新建窗口
  const [createModalVisible, setCreateModalVisible] = useState<boolean>(false);
  // 是否显示更新窗口
  const [updateModalVisible, setUpdateModalVisible] = useState<boolean>(false);
  const actionRef = useRef<ActionType>();
  // 当前代码生成器点击的数据
  const [currentRow, setCurrentRow] = useState<API.Generator>();

  /**
   * 删除节点
   *
   * @param row
   */
  const handleDelete = async (row: API.Generator) => {
    const hide = message.loading('正在删除');
    if (!row) return true;
    try {
      await deleteGeneratorUsingPost({
        id: row.id as any,
      });
      hide();
      message.success('删除成功');
      actionRef?.current?.reload();
      return true;
    } catch (error: any) {
      hide();
      message.error('删除失败，' + error.message);
      return false;
    }
  };

  /**
   * 表格列配置
   */
  const columns: ProColumns<API.Generator>[] = [
    {
      title: 'id',
      dataIndex: 'id',
      valueType: 'text',
      hideInForm: true,
    },
    {
      title: '名称',
      dataIndex: 'name',
      valueType: 'text',
    },
    {
      title: '描述',
      dataIndex: 'description',
      valueType: 'textarea',
    },
    {
      title: '基础包名',
      dataIndex: 'basePackage',
      valueType: 'text',
    },
    {
      title: '版本',
      dataIndex: 'version',
      valueType: 'text',
    },
    {
      title: '作者',
      dataIndex: 'author',
      valueType: 'text',
    },
    {
      title: '标签',
      dataIndex: 'tags',
      valueType: 'text',
      renderFormItem(schema) {
        const { fieldProps } = schema;
        // @ts-ignore
        return <Select mode="tags" {...fieldProps} />;
      },
      render(_, record) {
        if (!record.tags) {
          return <></>;
        }
        return JSON.parse(record.tags).map((tag: string) => {
          return <Tag key={tag}>{tag}</Tag>;
        });
      },
    },
    {
      title: '图片',
      dataIndex: 'picture',
      valueType: 'image',
      fieldProps: {
        width: 64,
      },
      hideInSearch: true,
    },
    {
      title: '文件配置',
      dataIndex: 'fileConfig',
      valueType: 'jsonCode',
    },
    {
      title: '模型配置',
      dataIndex: 'modelConfig',
      valueType: 'jsonCode',
    },
    {
      title: '产物包路径',
      dataIndex: 'distPath',
      valueType: 'text',
    },
    {
      title: '状态',
      dataIndex: 'status',
      valueEnum: {
        0: {
          text: '默认',
        },
      },
    },
    {
      title: '创建用户',
      dataIndex: 'userId',
      valueType: 'text',
    },
    {
      title: '创建时间',
      sorter: true,
      dataIndex: 'createTime',
      valueType: 'dateTime',
      hideInSearch: true,
      hideInForm: true,
    },
    {
      title: '更新时间',
      sorter: true,
      dataIndex: 'updateTime',
      valueType: 'dateTime',
      hideInSearch: true,
      hideInForm: true,
    },
    {
      title: '操作',
      dataIndex: 'option',
      valueType: 'option',
      render: (_, record) => (
        <Space size="middle">
          <Typography.Link
            onClick={() => {
              setCurrentRow(record);
              setUpdateModalVisible(true);
            }}
          >
            修改
          </Typography.Link>
          <Typography.Link type="danger" onClick={() => handleDelete(record)}>
            删除
          </Typography.Link>
        </Space>
      ),
    },
  ];
  return (
    <div className="generator-admin-page">
      <Typography.Title level={4} style={{ marginBottom: 16 }}>
        生成器管理
      </Typography.Title>
      <ProTable<API.Generator>
        headerTitle={'查询表格'}
        actionRef={actionRef}
        rowKey="key"
        search={{
          labelWidth: 120,
        }}
        toolBarRender={() => [
          <Button
            type="primary"
            key="primary"
            onClick={() => {
              setCreateModalVisible(true);
            }}
          >
            <PlusOutlined onPointerEnterCapture={undefined} onPointerLeaveCapture={undefined} />{' '}
            新建
          </Button>,
        ]}
        request={async (params, sort, filter) => {
          const sortField = Object.keys(sort)?.[0];
          const sortOrder = sort?.[sortField] ?? undefined;

          const { data, code } = await listGeneratorByPageUsingPost({
            ...params,
            sortField,
            sortOrder,
            ...filter,
          } as API.GeneratorQueryRequest);

          return {
            success: code === 0,
            data: data?.records || [],
            total: Number(data?.total) || 0,
          };
        }}
        columns={columns}
      />
      <CreateModal
        visible={createModalVisible}
        columns={columns}
        onSubmit={() => {
          setCreateModalVisible(false);
          actionRef.current?.reload();
        }}
        onCancel={() => {
          setCreateModalVisible(false);
        }}
      />
      <UpdateModal
        visible={updateModalVisible}
        columns={columns}
        oldData={currentRow}
        onSubmit={() => {
          setUpdateModalVisible(false);
          setCurrentRow(undefined);
          actionRef.current?.reload();
        }}
        onCancel={() => {
          setUpdateModalVisible(false);
        }}
      />
    </div>
  );
};
export default GeneratorAdminPage;
```

#### 主页(搜索列表页)

步骤1：

-   先在src/pages目录下，新建Index目录，将src/pages/Welcome.tsx拖拽到该目录下，并改名index.tsx
-   再在config/routes.ts中修改主页的路由

```TypeScript
export default [
  {
    path: '/user',
    layout: false,
    routes: [
      { path: '/user/login', component: './User/Login' },
      { path: '/user/register', component: './User/Register' },
    ],
  },
  { path: '/', icon: 'home', component: './Index', name: '主页' },
  {
    path: '/admin',
    icon: 'crown',
    name: '管理页',
    access: 'canAdmin',
    routes: [
      { path: '/admin', redirect: '/admin/user' },
      { icon: 'table', path: '/admin/user', component: './Admin/User', name: '用户管理' },
      {
        icon: 'tools',
        path: '/admin/generator',
        component: './Admin/Generator',
        name: '代码生成器管理',
      },
    ],
  },
  { path: '*', layout: false, component: './404' },
];
```

步骤2：将页面清理干净

```TypeScript
import { PageContainer } from '@ant-design/pro-components';
import React from 'react';

/**
 * 主页
 * @constructor
 */
const IndexPage: React.FC = () => {

  return (
    <PageContainer>

    </PageContainer>
  );
};

export default IndexPage;
```

步骤3：请求后端数据获取`代码生成器`列表数据

>   先获取数据便于后续页面调试

```TypeScript
/**
 * 默认分页参数
 */
const DEFAULT_PAGE_PARAMS: PageRequest = {
  current: 1,
  pageSize: 4,
  sortField: 'createTime',
  sortOrder: 'descend',
};

/**
 * 主页
 * @constructor
 */
const IndexPage: React.FC = () => {
  const [loading, setLoading] = useState<boolean>(true);
  const [dataList, setDataList] = useState<API.GeneratorVO[]>([]);
  const [total, setTotal] = useState<number>(0);
  // 搜索条件
  const [searchParams, setSearchParams] = useState<API.GeneratorQueryRequest>({
    ...DEFAULT_PAGE_PARAMS,
  });

  /**
   * 搜索
   */
  const doSearch = async () => {
    setLoading(true);
    try {
      const res = await listGeneratorVoByPageUsingPost(searchParams);
      setDataList(res.data?.records ?? []);
      setTotal(Number(res.data?.total) ?? 0);
    } catch (error: any) {
      message.error('获取数据失败，' + error.message);
    }
    setLoading(false);
  };

  useEffect(() => {
    doSearch();
  }, [searchParams]);

  ...
```

上述代码中，通过`useEffect`钩子监听`searchParams`搜索条件变量，**只要发现**搜索条件发生改变（或者首次执行），就会立即执行**重新搜索** 步骤4：开发基本页面 技巧1：

>   https://procomponents.ant.design/components/query-filter#queryfilterlightfilter-demo-search-filter 使用 Ant Design procomponents 的 QueryFilter 组件，就能快速开发搜索表单

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=OWYyMmJlZmFkNDRhZWM1NjNjNTg2YTgwZDY2NTZlM2RfQ2ZKT2UyODltdmQwdlJsdWJRYm9HY1NNUW96MVhObzlfVG9rZW46WWlNRGJtd205b3p5S3N4THl0dWNiQ0RFbnlmXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

技巧2：

>   https://preview.pro.ant.design/list/search/projects 在官方预览页找到**优秀的👍 示例页面**

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YzY3MDdmNDc5MjcwODIzNWI3NDFlYjVjNTBhY2VkOWFfbTdlMllHWklSZVZ6QnFNM3ZHb2JPOFZ3cUpKUDY5ZHFfVG9rZW46TkFIOGJWcHdKb2dWclZ4SXZHd2NpVmJNbjBlXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

还可以直接通过 Ant Design Pro 脚手架**（选择umi@3 complete）**生成预览页的现成代码，作为参考 （图源：鱼皮）

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTk0NDUzMDg0OTdjN2YxNGQ5YzBmZDFjZDE1YWVhMzlfWmdTQWl2UWpVU0xWY21iV291UFJzdFcxUjl0azM1WjdfVG9rZW46T2NHcmJSREZub2I1a1p4Y01SbGM4amx2bkVlXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

步骤5：完善分页和搜索功能 使用 Ant Design Pro 的 List 组件自带的分页功能，当用户切换分页时，会触发 onChange 事件，然后修改 searchParams，就能重新触发搜索 **（****useEffect****钩子监听）**

```TypeScript
<List<API.GeneratorVO>
  ...
  pagination={{
    current: searchParams.current,
    pageSize: searchParams.pageSize,
    total,
    onChange(current: number, pageSize: number) {
      setSearchParams({
        ...searchParams,
        current,
        pageSize,
      });
    },
  }}
```

步骤6：最后再调整一下页面细节，比如元素间距、宽高等 界面效果如下（笔记本的一屏展示不下，比例缩小，卡片还是很大，全局看的效果不好）：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=OTZiNmFiN2MxMDM3ODQ2NTk2NWQ0NTY2Nzk0ZTkzMjBfZEdEVTNLZ2hJWmxoeVF1T1gxQlpqMVdnV3hNR3Joa3ZfVG9rZW46TXQ0aGJ4UHFTbzBzM2J4WVlpT2NuWU9GbkxoXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YTY5ZTQ3YjllMzI4NTBjODljZjY4ZWY2YTJlYjRhY2RfT040b2Qwanp1T1hvMDFJOVZhak5VMEhNWFcyS1JDYVpfVG9rZW46VWlHR2JtUVR6b3hTbDd4MkFNMWN1eklQbmpiXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

主页的完整代码如下：

```TypeScript
import { listGeneratorVoByPageUsingPost } from '@/services/backend/generatorController';
import { UserOutlined } from '@ant-design/icons';
import { PageContainer, ProFormSelect, ProFormText, QueryFilter } from '@ant-design/pro-components';
import { Avatar, Card, Flex, Image, Input, List, message, Tabs, Tag, Typography } from 'antd';
import moment from 'moment';
import React, { useEffect, useState } from 'react';

/**
 * 默认分页参数
 */
const DEFAULT_PAGE_PARAMS: PageRequest = {
  current: 1,
  pageSize: 4,
  sortField: 'createTime',
  sortOrder: 'descend',
};

const IndexPage: React.FC = () => {
  const [loading, setLoading] = useState<boolean>(true);
  const [dataList, setDataList] = useState<API.GeneratorVo[]>([]);
  const [total, setTotal] = useState<number>(0);
  // 搜索条件
  const [searchParams, setSearchParams] = useState<API.GeneratorQueryRequest>({
    ...DEFAULT_PAGE_PARAMS,
  });

  /**
   * 搜索数据
   */
  const doSearch = async () => {
    setLoading(true);
    try {
      const res = await listGeneratorVoByPageUsingPost(searchParams);
      setDataList(res.data?.records ?? []);
      setTotal(res.data?.total ?? 0);
    } catch (e: any) {
      message.error('获取数据失败', e.message);
    }
    setLoading(false);
  };
  useEffect(() => {
    doSearch().then((r) => console.log(r));
  }, [searchParams]);

  /**
   * 标签列表
   * @param tags 标签数组
   */
  const tagListView = (tags?: string[]) => {
    if (!tags) {
      return <></>;
    }
    return (
      <div style={{ marginBottom: 8 }}>
        {tags.map((tag) => (
          <Tag key={tag}>{tag}</Tag>
        ))}
      </div>
    );
  };
  return (
    <PageContainer title={<></>}>
      <Flex justify="center">
        <Input.Search
          placeholder="请输入搜索词"
          allowClear
          enterButton="搜索"
          size="large"
          style={{ width: '40vw', minWidth: 320 }}
          onChange={(e) => {
            searchParams.searchText = e.target.value;
          }}
          onSearch={(value: string) => {
            setSearchParams({
              ...DEFAULT_PAGE_PARAMS,
              searchText: value,
            });
          }}
        />
      </Flex>
      <div style={{ marginBottom: 16 }}></div>
      <Tabs
        size="large"
        defaultActiveKey="newest"
        items={[
          {
            key: 'newest',
            label: '最新',
          },
          {
            key: 'recommend',
            label: '推荐',
          },
        ]}
        onChange={() => {}}
      />
      <QueryFilter
        span={12}
        labelWidth="auto"
        labelAlign="left"
        style={{ padding: '16px, 0' }}
        onFinish={async (values: API.GeneratorQueryRequest) => {
          setSearchParams({
            ...DEFAULT_PAGE_PARAMS,
            ...values,
            searchText: searchParams.searchText,
          });
        }}
      >
        <ProFormSelect label="标签" name="tags" mode="tags" />
        <ProFormText label="名称" name="name" />
        <ProFormText label="描述" name="description" />
      </QueryFilter>
      <div style={{ marginBottom: 24 }} />
      <List<API.GeneratorVo>
        rowKey="id"
        loading={loading}
        grid={{
          gutter: 16,
          xs: 1,
          sm: 2,
          md: 3,
          lg: 3,
          xl: 4,
          xxl: 4,
        }}
        dataSource={dataList}
        pagination={{
          current: searchParams.current,
          pageSize: searchParams.pageSize,
          total,
          onChange(current: number, pageSize: number) {
            setSearchParams({
              ...searchParams,
              current,
              pageSize,
            });
          },
        }}
        renderItem={(data) => (
          <List.Item>
            <Card hoverable cover={<Image alt={data.name} src={data.picture} />}>
              <Card.Meta
                title={<a>{data.name}</a>}
                description={
                  <Typography.Paragraph
                    ellipsis={{
                      rows: 2,
                    }}
                    style={{ height: 44 }}
                  >
                    {data.description}
                  </Typography.Paragraph>
                }
              />
              {tagListView(data.tags ?? [])}
              <Flex justify="space-between" align="center">
                <Typography.Paragraph type="secondary" style={{ fontSize: 12 }}>
                  {moment(data.createTime).fromNow()}
                </Typography.Paragraph>
                <div>
                  {/*@ts-ignore*/}
                  <Avatar src={data.user?.userAvatar ?? UserOutlined}></Avatar>
                </div>
              </Flex>
            </Card>
          </List.Item>
        )}
      />
    </PageContainer>
  );
};
export default IndexPage;
```

## 九、云平台开发 ---- 生成器共享

### 一、需求分析

根据之前规划好的实现流程，本节教程我们要实现的核心需求是：实现文件上传下载功能，让用户能够上传和下载

代码生成器产物包。

为了实现这个功能，我们需要完成：

1)代码生成器创建（修改）页面，用户可以上传生成器

2)代码生成器详情页面，用户可以查看和下载代码生成器

页面之间的关系如图:

暂时无法在飞书文档外展示此内容

想要实现这些功能，需要的核心能力是文件的上传和下载，以实现代码生成器图片文件、代码生成器产物包文件的存储。

这也是很多项目中都需要的能力，所以接下来我们优先实现通用的文件上传和下载功能，然后再去开发页面。

### 二、通用文件上传下载能力

首先我们要思考：将文件上传到哪里？从哪里下载？

最简单的方式就是上传到后端项目所在的服务器，直接使用Jva自带的文件读写AP川就能实现。但是，这种方式

存在不少缺点，比如：

1.  不利于扩展：单个服务器的存储是有限的，如果存满了，只能再新增存储空间或者清理文件。
2.  不利于迁移：如果后端项目要更换服务器部署，之前所有的文件都要迁移到新服务器，非常麻烦。
3.  不够安全：如果忘记控制权限，用户很有可能通过恶意代码访问服务器上的文件，而目想控制权限也，比较麻烦，需要自己实现。
4.  不利于管理：只能通过一些文件管理器进简单的管理操作，但是缺乏数据处理、流量控制等多种高级能力。

因此，除了存储一些需要清理的临时文件之外，我们通常不会将用户上传并保存的文件（比如用户头像）直接上传

到服务器，而是更推荐大家使用专业的第三方存储服务，专业的工具做专业的事。其中，最常用的便是对象存储

#### 什么是对象存储?

对象存储是一种存储海量文件的分布式存储翻服务，具有高扩展性、低成本、可靠安全等优点。

比如开源的对象存储服务MilO,还有商业版的云服务，像亚马逊S3(Amazon S3)、阿里云对象存储(OSS)、腾讯云对象存储(COS)等等。

我个人更推荐大家使用第三方云服务，不要自己再去搭建MilO之类的，咱学习主打一个快速！鱼皮使用最多的对象存储服务当属腾讯云的COS了，除了基本的对象存储的优点外，还可以通过控制台、AP1、SDK和工具等多样化方式，简单快速地接入COS,进行多格式文件的上传、下载和管理，实现海量数据存储和管理。

本教程中，将用腾讯云的COS带大家实现文件的上传和下载。鱼皮之前搭建的图床就是使用了COS对象存储实

现，很简单。

##### 创建并使用

首先进入对象存储的控制台,创建存储桶

>   https://console.cloud.tencent.com/cos/bucket

可以把存储桶理解为一个存储空间，和文件系统类似，都是根据路径找到文件或目录（比如`/test/aaa.jpg`)。可以多个项目共用一个存储桶，也可以每个项目一个。

点击创建存储桶，注意地域选择国内（离用户较近的位置）。此处访问权限先选择“公有读私有写”，因为我们的存储桶要存储允用户公开访问的代码生成器图片。而如果整个存储桶要存储齨的文件都不允许用户访方问，建议选择私有读写，更安全。

默认告警一定要勾选！因为对象存储服务的存储和访问流量都是计费的，超限后我们要第一时间得到通知并进相应的处理。

1)

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MGU1ZTg3ZWY3OWM0Y2ZlYTY2MjMwNjUxMTc1NGQwNjNfMkQ5ZWVXc2ZDbEZKRXN2Tm5XRVJQUThDSmZpY1h1Ym9fVG9rZW46VDN6OGJ4Zk01b3V5NjF4OVlJZmMwSkJkbnBmXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

2)   

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTY4YTYwYzczNjQ4YjQwNDAxN2NiMzBjOGM1YWI1ODRfTjY3Z256MGpjY1owQUsyaHkxZHkweWU2SXVHUDFJR05fVG9rZW46UE5Fd2JZVTVzb2JUR1d4T3pGUmM5M3NibnNiXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

3)   

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NDNmMWVmNDY5OGEyYTAxYTk3ZjQ1YzRjYzFlOWMzNDZfQWJFOHl3N3ZiV0FNSTF6RzJMUVlqelhUbER0OU96QVZfVG9rZW46R1hGWmJ6RllGb2pQSGV4dUR6NWN2UzBQbnVmXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

开通成功后,我们可以使用web控制台上传和浏览文件

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YTRiNGU2N2ZkOWFiYmVhZjg3Y2U5MjRhM2NiODhlNjBfYWliTGNlYWhIVXgwNkc5b012NFFSV29rSnA5eHM1NmdfVG9rZW46WGo2QmJKZ0lYb1dLVk14VG91Z2NDVWdVbldiXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

上传文件后，可以使用对象存储服务为我们生成的默认域名，在线访问图片：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQyZTlmNjBjNTVjYWQzODI5YWE1YmE2ZTlmNjUyM2VfWDVBNFlDeFZNRU9xeEZHZWpPeXlwUW5Cb3ZCOUVJOVhfVG9rZW46QWxGMmJqQXdPb3BBdGh4YnNMcmNjTDBibmhkXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

#### 后端操作对象存储

如何在Java程序中使用对象存储呢？

其实非常简单，一般情况下，第三方服务都会提供比较贴心的文档教程，比如这里我们参考官方的快速入门或Java SDK文档，就能快速入门基本操作（增删改查都有）

>   [cloud.tencent.com](https://cloud.tencent.com/document/product/436/10199)对象存储sdk文档

还有更高级的学习操作方法，如果你是腾讯云熟练用户，可以直接使用AP川Explorer,在线寻找操作和示例代码。

>   https://console.cloud.tencent.com/api/explorer?Product=cvm&Version=2017-03-12&Action=DescribeRegions

1.  ##### 初始化客户端

由于我们的后端万用模板已经集成了 cos 这块不需要自己编写配置文件 初始化 COS 客户端了

具体配置类在`azhang-generator-web-backEnd/src/main/java/com/azhang/web/config/CosClientConfig.java`代码如下：

```Java
package com.azhang.web.config;

import com.qcloud.cos.COSClient;
import com.qcloud.cos.ClientConfig;
import com.qcloud.cos.auth.BasicCOSCredentials;
import com.qcloud.cos.auth.COSCredentials;
import com.qcloud.cos.region.Region;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 腾讯云对象存储客户端
 *
 * @author codeZhang
 */
@Configuration
@ConfigurationProperties(prefix = "cos.client")
@Data
public class CosClientConfig {

    /**
     * accessKey
     */
    private String accessKey;

    /**
     * secretKey
     */
    private String secretKey;

    /**
     * 区域
     */
    private String region;

    /**
     * 桶名
     */
    private String bucket;

    @Bean
    public COSClient cosClient() {
        // 初始化用户身份信息(secretId, secretKey)
        COSCredentials cred = new BasicCOSCredentials(accessKey, secretKey);
        // 设置bucket的区域, COS地域的简称请参照 https://www.qcloud.com/document/product/436/6224
        ClientConfig clientConfig = new ClientConfig(new Region(region));
        // 生成cos客户端
        return new COSClient(cred, clientConfig);
    }
}
```

我们需要在对应的配置文件下填写从腾讯云获取的 `accessKey`、`secretKey`、`region`、`bucket`

**一定要注意防止密码泄露！** 所以我们新建 `application-local.yml` 文件，并且在 .gitignore 中忽略该文件的提交，这样就不会将代码等敏感配置提交到代码仓库了。

`.gitignore`增加：

```YAML
# 忽略提交本地配置文件 防止密码泄露
application-local.yml
```

新建配置文件`application-local.yml`新增如下配置：

```YAML
 # 对象存储
cos:
  client:
    accessKey: xxx
    secretKey: xxx
    region: xxx
    bucket: xxx
```

`accessKey`、`secretKey` 密钥管理中获 https://console.cloud.tencent.com/cam/capi

`bucket`就是我们刚刚创建的存储桶的名称`region`(`ap-beijing`)就是存储桶的地区信息

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MGFkNTI1OGI4NTFlMDVmMzcxZWE5NDI4MmQ3MWRkMzVfYUZNSDE2emZiRTFKOGZNYm5qT0w0c0liUXRKbWUxS0pfVG9rZW46WkVvZGJTOU14b1d2RGh4U1ZDdGNkWmZWbllmXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

1.  ##### 通用能力

`CosManager`提供通用的对象存储操作，比如文件上传、文件下载

目录`azhang-generator-web-backEnd/src/main/java/com/azhang/web/manager/CosManager.java`

1.  ##### 文件上传

我们在`CosManager`新增两个通用方法：

参考官方文档的“上传对象”部分，可以编写出文件上传的代码。

地址：

https://cloud.tencent.com/document/product/436/65935

```Java
package com.azhang.web.manager;

import com.azhang.web.config.CosClientConfig;
import com.qcloud.cos.COSClient;
import com.qcloud.cos.model.PutObjectRequest;
import com.qcloud.cos.model.PutObjectResult;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.io.File;

/**
 * Cos 对象存储操作
 *
 * @author codeZhang
 */
@Component
public class CosManager {

    @Resource
    private CosClientConfig cosClientConfig;

    @Resource
    private COSClient cosClient;

    /**
     * 上传对象
     *
     * @param key 唯一键
     * @param localFilePath 本地文件路径
     * @return 上传结果
     */
    public PutObjectResult putObject(String key, String localFilePath) {
        PutObjectRequest putObjectRequest = new PutObjectRequest(cosClientConfig.getBucket(), key,
                new File(localFilePath));
        return cosClient.putObject(putObjectRequest);
    }

    /**
     * 上传对象
     *
     * @param key 唯一键
     * @param file 文件
     * @return 上传结果
     */
    public PutObjectResult putObject(String key, File file) {
        PutObjectRequest putObjectRequest = new PutObjectRequest(cosClientConfig.getBucket(), key,
                file);
        return cosClient.putObject(putObjectRequest);
    }
}
```

修改 `FileConstant` 常量中的 COS 访问域名

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NmEyNjU0NDJkMWQ4ZWQwODQyOGMwMjA5MzcxYTA0ZmRfUURjV0ZQVHpaYW9oT0U2a2lWOWZ4Z2czUm40cUQzY3JfVG9rZW46Q3hGcGJPMjVYb1NibzJ4aVZyemNiRFNIbnVlXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

这里不写测试方法了，直接使用`uploadFile`方法做测试：

若出现错误

```Java
com.qcloud.cos.exception.CosClientException: java.lang.RuntimeException: Unexpected error: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty
```

说明缺少ssl证书或ssl证书过期, 可忽略证书或者添加

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YjkxMDBjMWRkYWY2NzZjNzcxN2Y4MTZmMGE5NjhmZTBfZ3BmMHl6a2tLR0VqSVF5R1k1MVBnUmtZMDgzNWlmRktfVG9rZW46TExHeWJWQmdIb3BtaTR4VEM3MmMyT3FFbnNmXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

1.  ##### 文件下载

官方文档介绍了 2 种文件下载方式。一种是直接下载 COS 的文件到后端服务器（适合服务器端处理文件），另一种是获取到文件下载输入流（适合返回给前端用户）。

参考官方文档：

-   https://cloud.tencent.com/document/product/436/65937
-   https://cloud.tencent.com/document/product/436/10199#.E4.B8.8B.E8.BD.BD.E5.AF.B9.E8.B1.A1

项目中的代码生成器产物包文件，通过后端服务器从 COS 下载文件并返回给前端，这样可以在后端限制只有登录用户才能下载。

在 `CosManager` 中新增对象下载方法，根据对象的 key 获取存储信息：

```Java
package com.azhang.web.manager;

import com.azhang.web.config.CosClientConfig;
import com.qcloud.cos.COSClient;
import com.qcloud.cos.model.COSObject;
import com.qcloud.cos.model.GetObjectRequest;
import com.qcloud.cos.model.PutObjectRequest;
import com.qcloud.cos.model.PutObjectResult;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.io.File;

/**
 * Cos 对象存储操作
 *
 * @author codeZhang
 */
@Component
public class CosManager {

    @Resource
    private CosClientConfig cosClientConfig;

    @Resource
    private COSClient cosClient;

    ............

    /**
     * 下载对象
     *
     * @param key 唯一键
     * @return 下载结果
     */
    public COSObject getObject(String key) {
        GetObjectRequest getObjectRequest = new GetObjectRequest(cosClientConfig.getBucket(), key);
        return cosClient.getObject(getObjectRequest);
    }
}
```

在`FileController`中新增文件下载测试方法：

```Java
/**
 * 测试文件下载
 *
 * @param filepath 文件路径
 * @param response 响应信息
 * @throws IOException IO异常
 */
@AuthCheck(mustRole = UserConstant.ADMIN_ROLE)
@GetMapping("/test/download")
public void testDownloadFile(
        String filepath,
        HttpServletResponse response) throws IOException {
    COSObjectInputStream cosObjectInput = null;
    try {
        COSObject cosObject = cosManager.getObject(filepath);
        cosObjectInput = cosObject.getObjectContent();
        // 处理下载到的流
        byte[] bytes = IOUtils.toByteArray(cosObjectInput);
        // 设置响应头
        response.setContentType("application/octet-stream;charset=UTF-8");
        response.setHeader("Content-Disposition","attachment;filename=" + filepath);
        // 写入响应
        response.getOutputStream().write(bytes);
        response.getOutputStream().flush();
    } catch (Exception e) {
        log.error("file download error, filepath = " + filepath, e);
        throw new BusinessException(ErrorCode.SYSTEM_ERROR, "下载失败");
    } finally {
        if (cosObjectInput != null) {
            cosObjectInput.close();
        }
    }
}
```

使用接口文档测试：

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MzgzODc1YWQ1OTQ4OTkxN2I2MTdiOTlkNWRjYjI3MjNfdzRxS3lsQlc5UHVaQWFGVENpRHZuOUc0bXJYR0toRVJfVG9rZW46RDdwNWIxbEZlb0ZiZkF4MFR1cGMyamM4bmpiXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

swagger 文档无法展示，但是直接在浏览器中输入接口文档地址以及参数 可以直接下载成功！！

后端操作对象存储的代码编写完成，下面写一个前端页面来测试文件的上传和下载。

1.  ##### 前端文件上传/下载

使用 openApi 工具重新生成接口 将后端刚刚的上传接口和下载接口生成 一会可以直接使用

新建路由配置 创建测试页面：

```TypeScript
{
  path: '/test/file',
  icon: 'home',
  component: './Test/File',
  name: '文件上传下载测试',
  hideInMenu: true,
},
```

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=MTBlOTkzZDkzNzdmZmEzNTdjNTEwYzNmMjkxM2RlZmJfaHcwS2pYY1lLUmhUcXVrbDZiOFZXUXMyTEZrNDlRSmVfVG9rZW46SHU0RmJGRnNFb3F2UkJ4cVVsZWNoRmUxblVnXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

```TypeScript
import React from 'react';

const TestFilePage: React.FC = () => {
  return <></>;
};
export default TestFilePage;
```

修改 constants/index.ts 文件，添加下列代码：

```TypeScript
export const COS_HOST = 'https://generate-bucket-1313437750.cos.ap-beijing.myqcloud.com';
```

完整页面代码：

```TypeScript
import { COS_HOST } from '@/constants';
import { testDownloadFileUsingGet, uploadFileUsingPost } from '@/services/backend/fileController';
import { InboxOutlined } from '@ant-design/icons';
import { PageContainer } from '@ant-design/pro-components';
import { Button, Card, Divider, Flex, Image, message, Upload, UploadProps } from 'antd';
import React, { useState } from 'react';
import {saveAs} from "file-saver";

const { Dragger } = Upload;

const TestFilePage: React.FC = () => {
  const [value, setValue] = useState<string>();
  const props: UploadProps = {
    name: 'file',
    multiple: false,
    maxCount: 1,
    onChange(info) {
      const { status } = info.file;
      if (status !== 'uploading') {
        console.log(info.file, info.fileList);
      }
      if (status === 'done') {
        message.success(`${info.file.name} file uploaded successfully.`).then(() => {});
      } else if (status === 'error') {
        message.error(`${info.file.name} file upload failed.`).then(() => {});
      }
    },
    onDrop(e) {
      console.log('Dropped files', e.dataTransfer.files);
    },
    customRequest: async (fileObj: any) => {
      try {
        const res = await uploadFileUsingPost({ biz: 'user_avatar' }, {}, fileObj.file);
        fileObj.onSuccess(res.data);
        setValue(res.data);
      } catch (e: any) {
        message.error('上传失败,' + e.message);
        fileObj.onError(e);
      }
    },
    onRemove() {
      setValue(undefined);
    },
  };
  return (
    <PageContainer>
      <Flex gap={16}>
        <Card title="文件上传">
          <Dragger {...props}>
            <p className="ant-upload-drag-icon">
              {/*@ts-ignore*/}
              <InboxOutlined />
            </p>
            <p className="ant-upload-text">Click or drag file to this area to upload</p>
            <p className="ant-upload-hint">
              Support for a single or bulk upload. Strictly prohibited from uploading company data
              or other banned files.
            </p>
          </Dragger>
        </Card>
        <Card title="文件下载">
          <div>文件地址: {COS_HOST + value}</div>
          <Divider />
          <Image src={COS_HOST + value} height="200" />
          <Divider />
          <Button
            onClick={async () => {
              const blob = await testDownloadFileUsingGet(
                { filepath: value },
                {
                  responseType: 'blob',
                },
              );
                const fullPath = COS_HOST + value;
                saveAs(blob, fullPath.substring(fullPath.lastIndexOf('/') + 1));
            }}
          >
            点击下载
          </Button>
        </Card>
      </Flex>
    </PageContainer>
  );
};
export default TestFilePage;
```

使用 file-saver 库，可以下载后端返回的 blob 内容为文件。

先安装 file-saver 库：

```Shell
npm install file-saver
npm i --save-dev @types/file-saver
```

由于后端下载文件接口不返回 code 状态码，所以需要修改响应拦截器，对于文件下载请求，直接返回 blob 对象。修改 `requestConfig.ts` 的部分代码如下：

```TypeScript
// 文件下载时，直接返回
if (requestPath.includes("download")) {
    return response;
}
```

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGEyMGQxN2I5YWY3OTM4MzZmM2Y4Zjg0MWYwZjk0NzhfWW1DalJyT2o1MHMwa1hKeUFEYkVDd0xLaVI4SU1JTjRfVG9rZW46QmNKZ2JzU3c4b2NaSUN4Yks4TWNxdFNpbmxkXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

### 三、创建代码生成器功能

开发创建代码生成器功能，允许用户创建发布代码生成器。

先开发后端，创建代码生成器页面依赖的接口如下：

1.  创建代码生成器
2.  文件上传，包括上传代码生成器的图片和 dist 产物包

第一个接口之前已经完成，主要开发文件上传接口。

但是在那之前，我们要先解决一个问题。我们现在得到的代码生成器成品是一个 dist 目录，包含多个文件。想要上传和下载多文件都很不方便，所以需要对目录进行压缩打包。

#### 文件压缩打包

如何压缩打包文件呢

有2种方案：

1)使用C0S自带的能力，上传文件后执行压缩打包任务。参考官方文档：

2)   在制作工具生成代码生成器产物包时，同时得到一个压缩包文件。更推荐这种方式

修改制作工具 `maker `项目的 `GenerateTemplate.java` 文件。新增一个制作压缩包的方法，可供子类调用。

使用 Hutool 工具类可以轻松实现压缩，代码如下：

```Java
/**
 * 构建压缩包
 *
 * @param outputPath 输出路径
 * @return 返回压缩包路径
 */
protected String buildZip(String outputPath) {
    String zipPath = outputPath + ".zip";
    ZipUtil.zip(outputPath, zipPath);
    return zipPath;
}
```

然后修改模板类的 buildDist 方法，返回 dist 包的文件路径。代码如下：

需要同步修改 `MainGenerator` 的返回值

```Java
/**
 * 构建dist精简版代码
 *
 * @param outputPath          输出路径
 * @param sourceCopyDestPath  原始模板复制到的路径
 * @param shellOutputFilePath shell脚本路径
 * @param jarPath             jar包路径
 */
protected String buildDist(String outputPath, String sourceCopyDestPath, String shellOutputFilePath, String jarPath) {
    String distOutputPath = outputPath + "-dist";
    // 拷贝jar包,
    String targetAbsolutePath = distOutputPath + File.separator + "target";
    FileUtil.mkdir(targetAbsolutePath);
    String jarAbsolutePath = outputPath + File.separator + jarPath;
    FileUtil.copy(jarAbsolutePath, targetAbsolutePath, true);
    // 拷贝脚本文件,
    FileUtil.copy(shellOutputFilePath, distOutputPath, true);
    FileUtil.copy(shellOutputFilePath + ".bat", distOutputPath, true);
    // 拷贝原始模板文件
    FileUtil.copy(sourceCopyDestPath, distOutputPath, true);
    return distOutputPath;
}
```

在 `maker.generator.main` 包下，新增压缩包生成器 `ZipGenerator` 子类，同时生成产物包和压缩包：

```Java
package com.manneia.maker.generator;

import com.manneia.maker.generator.main.GenerateTemplate;

/**
 * @author lkx
 */
public class ZipGenerator extends GenerateTemplate {

    @Override
    protected String buildDist(String outputPath, String jarPath, String shellOutputPath, String sourceOutputPath) {
        String distPath = super.buildDist(outputPath, jarPath, shellOutputPath, sourceOutputPath);
        return super.buildZip(distPath);
    }
}
```

最后修改主类的 main 方法，测试生成代码生成器的压缩包：

```Java
package com.manneia.maker.generator.main;

import com.manneia.maker.generator.ZipGenerator;
import freemarker.template.TemplateException;

import java.io.IOException;

/**
 * @author manneia
 */
public class MainGenerator extends GenerateTemplate{
    public static void main(String[] args) throws TemplateException, IOException, InterruptedException {
        GenerateTemplate generateTemplate = new ZipGenerator();
        generateTemplate.doGenerate();
    }
}
```

测试执行:

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YWY1YjQyMjllOTZjMDgyNDAyNjVkNWUyYzUxYzQ1YzVfR3ZNT2JsZll6MjBNbUprZEJlVUd0MHVuVDl2YmVGb3pfVG9rZW46S3QzdmJFMldqb0FWbWl4SmVtZWM3U3lvblViXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

#### 文件上传接口

万用模板中已经有`upload`接口我们只需要在返回值，不再拼接 FileConstant.COS_HOST，而是直接返回 filepath 相对路径

在`FileController`中编写文件上传接口

```Java
/**
 * 文件上传
 *
 * @param multipartFile 文件
 * @param uploadFileRequest 上传文件请求
 * @param request 请求
 * @return 返回上传文件的的可访问地址
 */
@PostMapping("/upload")
public BaseResponse<String> uploadFile(@RequestPart("file") MultipartFile multipartFile,
        UploadFileRequest uploadFileRequest, HttpServletRequest request) {
    String biz = uploadFileRequest.getBiz();
    FileUploadBizEnum fileUploadBizEnum = FileUploadBizEnum.getEnumByValue(biz);
    if (fileUploadBizEnum == null) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    validFile(multipartFile, fileUploadBizEnum);
    User loginUser = userService.getLoginUser(request);
    // 文件目录：根据业务、用户来划分
    String uuid = RandomStringUtils.randomAlphanumeric(8);
    String filename = uuid + "-" + multipartFile.getOriginalFilename();
    String filepath = String.format("/%s/%s/%s", fileUploadBizEnum.getValue(), loginUser.getId(), filename);
    File file = null;
    try {
        // 上传文件
        file = File.createTempFile(filepath, null);
        multipartFile.transferTo(file);
        cosManager.putObject(filepath, file);
        // 返回可访问地址
        return ResultUtils.success(filepath);
    } catch (Exception e) {
        log.error("file upload error, filepath = " + filepath, e);
        throw new BusinessException(ErrorCode.SYSTEM_ERROR, "上传失败");
    } finally {
        if (file != null) {
            // 删除临时文件
            boolean delete = file.delete();
            if (!delete) {
                log.error("file delete error, filepath = {}", filepath);
            }
        }
    }
}
```

需要注意的一点是，我们要修改上述方法的返回值，不再拼接`FileConstant.COS_HOST`，而是直接返回

filepath相对路径，便于后续直接根据filepath下载。

其实和我们之前编写的测试文件上传方法很像，只不过我们为了更方便地管理文件，引入了biz参数，用来区

分业务，让不同业务的文件上传到不同的目录中。后面甚至还可以根据目录来设置不同的问权限，提高安全性。

根据我们的项目情况，还要修改`FileUploadBizEnum`枚举类，增加几种业务类型。代码如下：

```Java
package com.manneia.generateweb.model.enums;

import lombok.Getter;
import org.apache.commons.lang3.ObjectUtils;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * 文件上传业务类型枚举
 *
 * @author lkx
 * 
 */
@Getter
public enum FileUploadBizEnum {

    USER_AVATAR("用户头像", "user_avatar"),
    GENERATOR_PICTURE("生成器图片", "generator_picture"),
    GENERATOR_DIST("生成器产物包", "generator_dist");

    private final String text;

    private final String value;

    FileUploadBizEnum(String text, String value) {
        this.text = text;
        this.value = value;
    }

    /**
     * 获取值列表
     *
     * @return 返回值列表
     */
    public static List<String> getValues() {
        return Arrays.stream(values()).map(item -> item.value).collect(Collectors.toList());
    }

    /**
     * 根据 value 获取枚举
     *
     * @param value 值
     * @return 返回枚举
     */
    public static FileUploadBizEnum getEnumByValue(String value) {
        if (ObjectUtils.isEmpty(value)) {
            return null;
        }
        for (FileUploadBizEnum anEnum : FileUploadBizEnum.values()) {
            if (anEnum.value.equals(value)) {
                return anEnum;
            }
        }
        return null;
    }

}
```

#### 通用文件上传接口

编写好接口后，下面我们要开发通用的文件上传组件，便于我们创建代码生成器表单页面直接引用。

编写组件可是个技术活，首先我们要足够了解 Ant Design 组件库的运行机制，比如此处需要遵循自定义表单控件的规范。一定要阅读文档：https://ant.design/components/form-cn#components-form-demo-customized-form-controls

根据规范，我们要给组件指定 value 和 onChange 两个属性，明确这点后，就可以开发了。

分别需要开发文件上传和图片上传 2 个组件。

##### 文件上传组件

在`components` 组件目录下新建 `FileUploader` 组件

完整代码如下:

```TypeScript
import { uploadFileUsingPost } from '@/services/backend/fileController';
import { InboxOutlined } from '@ant-design/icons';
import { message, UploadFile, UploadProps } from 'antd';
import Dragger from 'antd/es/upload/Dragger';
import React, { useState } from 'react';

interface Props {
  biz: string;
  onChange?: (fileList: UploadFile[]) => void;
  value?: UploadFile[];
  description?: string;
}

/**
 * 文件上传组件
 * @constructor
 */
const FileUploader: React.FC<Props> = (props) => {
  const { biz, value, description, onChange } = props;
  const [loading, setLoading] = useState(false);

  const uploadProps: UploadProps = {
    name: 'file',
    listType: 'text',
    multiple: false,
    maxCount: 1,
    fileList: value,
    disabled: loading,
    onChange: ({ fileList }) => {
      onChange?.(fileList);
    },
    customRequest: async (fileObj: any) => {
      setLoading(true);
      try {
        const res = await uploadFileUsingPost(
          {
            biz,
          },
          {},
          fileObj.file,
        );
        fileObj.onSuccess(res.data);
      } catch (e: any) {
        message.error('上传失败，' + e.message);
        fileObj.onError(e);
      }
      setLoading(false);
    },
  };

  return (
    <Dragger {...uploadProps}>
      <p className="ant-upload-drag-icon">
        {/*@ts-ignore*/}
        <InboxOutlined />
      </p>
      <p className="ant-upload-text">点击或拖拽文件上传</p>
      <p className="ant-upload-hint">{description}</p>
    </Dragger>
  );
};

export default FileUploader;
```

##### **图片上传**

和文件上传类似，我们可以参考 Ant Design 现有的图片上传组件和之前的文件上传代码。文档地址：https://ant.design/components/upload-cn#components-upload-demo-avatar在 `components` 组件目录下新建 `PictureUploader` 组件，完整代码如下：

```TypeScript
import { COS_HOST } from '@/constants';
import { uploadFileUsingPost } from '@/services/backend/fileController';
import { LoadingOutlined, PlusOutlined } from '@ant-design/icons';
import { message, Upload, UploadProps } from 'antd';
import React, { useState } from 'react';

interface Props {
  biz: string;
  onChange?: (url: string) => void;
  value?: string;
}

/**
 * 图片上传组件
 * @constructor
 */
const PictureUploader: React.FC<Props> = (props) => {
  const { biz, value, onChange } = props;
  const [loading, setLoading] = useState(false);

  const uploadProps: UploadProps = {
    name: 'file',
    listType: 'picture-card',
    showUploadList: false,
    multiple: false,
    maxCount: 1,
    disabled: loading,
    customRequest: async (fileObj: any) => {
      setLoading(true);
      try {
        const res = await uploadFileUsingPost(
          {
            biz: 'user_avatar',
          },
          {},
          fileObj.file,
        );
        // 拼接完整路径
        const fullPath = COS_HOST + res.data;
        onChange?.(fullPath ?? '');
        fileObj.onSuccess(res.data);
      } catch (e: any) {
        message.error('上传失败，' + e.message);
        fileObj.onError(e);
      }
      setLoading(false);
    },
  };
  /**
   * 上传按钮
   */
  const uploadButton = (
    <button style={{ border: 0, background: 'none' }} type="button">
      {/*@ts-ignore*/}
      {loading ? <LoadingOutlined /> : <PlusOutlined />}
      <div style={{ marginTop: 8 }}>Upload</div>
    </button>
  );
  return (
    <Upload {...uploadProps}>
      {value ? <img src={value} alt="picture" style={{ width: '100%' }} /> : uploadButton}
    </Upload>
  );
};

export default PictureUploader;
```

#### 创建页面开发

有了通用的文件上传和图片上传组件后，我们就可以开发代码生成器创建页面了。

由于创建代码生成器时，需要填写的字段较多，所以此处我们使用分步表单，官方文档已经给了非常成熟的 Demo。地址：https://procomponents.ant.design/components/steps-form

1)   新建路由和对应的页面文件：

```TypeScript
{
  path: '/generator/add',
  icon: 'home',
  component: './Generator/Add',
  name: '创建生成器',
},
```

目录结构如下:

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YzQ4M2MzODdlNGQyOGRmOGFjYzk1NGNlODEwMjc5MjZfbVJmbmlYS0tseEkwWlpwUW5KbU52aXZzdExkNnFWbERfVG9rZW46TmtGbmJUZVl4bzFPNTF4TTh0WmNLSWJObjVkXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

2)   先根据 Ant Design Procomponents 的分步表单组件，完成基本表单，实现基本的分步流程，并尝试输出用户填写的全部参数。

这里我们假设用户已经有了制作好的代码生成器压缩包，先不编写 fileConfig 和 modelConfig 这些结构复杂的表单项。

创建生成器页面代码如下：

```TypeScript
import FileUploader from '@/components/FileUploader';
import PictureUploader from '@/components/PictureUploader';
import { COS_HOST } from '@/constants';
import {
  addGeneratorUsingPost,
  editGeneratorUsingPost,
  getGeneratorVoByIdUsingGet,
} from '@/services/backend/generatorController';
import { useSearchParams } from '@@/exports';
import type { ProFormInstance } from '@ant-design/pro-components';
import {
  ProCard,
  ProFormItem,
  ProFormSelect,
  ProFormText,
  ProFormTextArea,
  StepsForm,
} from '@ant-design/pro-components';
import { history } from '@umijs/max';
import { message, UploadFile } from 'antd';
import React, { useEffect, useRef, useState } from 'react';

/**
 * 生成器创建页面
 * @constructor
 */
const GeneratorAddPage: React.FC = () => {
  const formRef = useRef<ProFormInstance>();

  const [searchParams] = useSearchParams();
  const id = searchParams.get('id');
  const [oldData, setOldData] = useState<API.GeneratorEditRequest>();

  const loadData = async () => {
    if (!id) {
      return;
    }
    try {
      // @ts-ignore
      const res = await getGeneratorVoByIdUsingGet({ id });
      // 处理文件路径
      if (res.data) {
        const { distPath } = res.data ?? {};
        if (distPath) {
          // @ts-ignore
          res.data.distPath = [
            {
              uid: id,
              name: '文件' + id,
              status: 'done',
              url: COS_HOST + res,
              response: res,
            } as UploadFile,
          ];
        }
        setOldData(res.data);
      }
    } catch (e: any) {
      message.error('加载数据失败' + e.message);
    }
  };
  useEffect(() => {
    if (id) {
      loadData().then(() => {});
    }
  }, [id]);

  /**
   * 创建
   * @param values
   */
  const doAdd = async (values: API.GeneratorAddRequest) => {
    // 调用接口
    try {
      const res = await addGeneratorUsingPost(values);
      if (res.data) {
        message.success('创建成功');
        history.push(`/generator/detail/${res.data}`);
      }
    } catch (e: any) {
      message.error('创建失败.' + e.message);
    }
  };

  /**
   * 更新
   * @param values
   */
  const doUpdate = async (values: API.GeneratorEditRequest) => {
    // 调用接口
    try {
      const res = await editGeneratorUsingPost(values);
      if (res.data) {
        message.success('更新成功');
        history.push(`/generator/detail/${id}`);
      }
    } catch (e: any) {
      message.error('更新失败.' + e.message);
    }
  };

  const doSubmit = async (values: API.GeneratorAddRequest) => {
    // 数据转换
    if (!values.fileConfig) {
      values.fileConfig = {};
    }
    if (!values.modelConfig) {
      values.modelConfig = {};
    }
    // 文件列表转换为url
    if (values.distPath && values.distPath.length > 0) {
      // @ts-ignore
      values.distPath = values.distPath[0].response;
    }
    if (id) {
      await doUpdate({
        // @ts-ignore
        id,
        ...values,
      });
    } else {
      await doAdd(values);
    }
  };

  return (
    <ProCard>
      {/*创建或者已加载要更新的数据时,才渲染表单,顺利填充默认值*/}
      {(!id || oldData) && (
        <StepsForm<API.GeneratorAddRequest | API.GeneratorEditRequest>
          formRef={formRef}
          formProps={{ initialValues: oldData }}
          onFinish={doSubmit}
        >
          <StepsForm.StepForm
            name="base"
            title="基本信息"
            onFinish={async () => {
              console.log(formRef.current?.getFieldsValue());
              return true;
            }}
          >
            <ProFormText name="name" label="名称" placeholder="请输入名称" />
            <ProFormTextArea name="description" label="描述" placeholder="请输入描述" />
            <ProFormText name="basePackage" label="基础包" placeholder="请输入基础包" />
            <ProFormText name="version" label="版本" placeholder="请输入版本" />
            <ProFormText name="author" label="作者" placeholder="请输入作者" />
            <ProFormSelect label="标签" mode="tags" placeholder="请输入标签列表" />
            <ProFormItem name="picture" label="图片">
              <PictureUploader biz="generator_picture" />
            </ProFormItem>
          </StepsForm.StepForm>
          <StepsForm.StepForm name="fileConfig" title="文件配置">
            {/*  todo 待补充*/}
          </StepsForm.StepForm>
          <StepsForm.StepForm name="modelConfig" title="模型配置">
            {/*  todo 待补充*/}
          </StepsForm.StepForm>
          <StepsForm.StepForm name="dist" title="生成器文件">
            <ProFormItem label="产物包" name="distPath">
              <FileUploader biz="generator_dist" description="请上传生成器压缩包" />
            </ProFormItem>
          </StepsForm.StepForm>
        </StepsForm>
      )}
    </ProCard>
  );
};

export default GeneratorAddPage;
```

页面效果如图

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NzFjOWIwOGZmZWZlZGRjYmI3ZTMxMTNmYjQyOTRiMzVfMjFmcFNHZWNoUFFNYkI4UTB1cEpPdkNyVms0R0V1QTZfVG9rZW46R1pzSGJFcmk0bzNRU3N4c0JoaGMyUncwbmdGXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

#### 修改页面开发

完成创建页面后，开发修改页面就很简单了，可以直接在创建页面的基础上支持读取老数据并修改的能力。

1)   新增修改页面路由，指向创建页面文件：

```TypeScript
{
    path: '/generator/update',
    icon: 'plus',
    component: './Generator/Add',
    name: '修改生成器',
    hideInMenu: true,
  },
```

2)   创建页面增加逻辑：通过url的查询参数传递要修改的数据id,并且根据id查询老数据。

```TypeScript
const [searchParams] = useSearchParams();
const id = searchParams.get('id');
const [oldData, setOldData] = useState<API.GeneratorEditRequest>();

const loadData = async () => {
  if (!id) {
    return;
  }
  try {
    // @ts-ignore
    const res = await getGeneratorVoByIdUsingGet({ id });
    // 处理文件路径
    if (res.data) {
      const { distPath } = res.data ?? {};
      if (distPath) {
        // @ts-ignore
        res.data.distPath = [
          {
            uid: id,
            name: '文件' + id,
            status: 'done',
            url: COS_HOST + res,
            response: res,
          } as UploadFile,
        ];
      }
      setOldData(res.data);
    }
  } catch (e: any) {
    message.error('加载数据失败' + e.message);
  }
};
useEffect(() => {
  if (id) {
    loadData().then(() => {});
  }
}, [id]);
```

上述代码中，比较关键的是将distPath从路径转换为文件上传组件的UploadFile对象，用于将之前上传过的文

件回显在文件上传组件中。其中，ur川（打开链接）要补充COS HOST前缀，而response(实际的值)不用补

充。

```TypeScript
  res.data.distPath = [
          {
            uid: id,
            name: '文件' + id,
            status: 'done',
            url: COS_HOST + res,
            response: res,
          } as UploadFile,
        ];
```

效果如下:

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=YjRhM2NlMTRjZDdkN2QxODkyMDk4YzYxYWI3ZTQ2ZGJfc0w5RzF0eGdBcFVBRTVuRjZDQzI0ZWMxMklGQVNZcjBfVG9rZW46S1BuaGJRdklyb1lDdWR4VUtoRWNpaGJhbjJiXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

3)   区分创建和修改

```TypeScript
/**
 * 创建
 * @param values
 */
const doAdd = async (values: API.GeneratorAddRequest) => {
  // 调用接口
  try {
    const res = await addGeneratorUsingPost(values);
    if (res.data) {
      message.success('创建成功');
      history.push(`/generator/detail/${res.data}`);
    }
  } catch (e: any) {
    message.error('创建失败.' + e.message);
  }
};

/**
 * 更新
 * @param values
 */
const doUpdate = async (values: API.GeneratorEditRequest) => {
  // 调用接口
  try {
    const res = await editGeneratorUsingPost(values);
    if (res.data) {
      message.success('更新成功');
      history.push(`/generator/detail/${id}`);
    }
  } catch (e: any) {
    message.error('更新失败.' + e.message);
  }
};

const doSubmit = async (values: API.GeneratorAddRequest) => {
  // 数据转换
  if (!values.fileConfig) {
    values.fileConfig = {};
  }
  if (!values.modelConfig) {
    values.modelConfig = {};
  }
  // 文件列表转换为url
  if (values.distPath && values.distPath.length > 0) {
    // @ts-ignore
    values.distPath = values.distPath[0].response;
  }
  if (id) {
    await doUpdate({
      // @ts-ignore
      id,
      ...values,
    });
  } else {
    await doAdd(values);
  }
};
```

4)   测试编写好的页面,会发现除了第一步之外的表单项,并没有回填默认值`

```TypeScript
{/*创建或者已加载要更新的数据时,才渲染表单,顺利填充默认值*/}
{(!id || oldData) && (
  <StepsForm<API.GeneratorAddRequest | API.GeneratorEditRequest>
    formRef={formRef}
    formProps={{ initialValues: oldData }}
    onFinish={doSubmit}
  >
```

完整的页面代码如下:

```TypeScript
import FileUploader from '@/components/FileUploader';
import PictureUploader from '@/components/PictureUploader';
import { COS_HOST } from '@/constants';
import {
  addGeneratorUsingPost,
  editGeneratorUsingPost,
  getGeneratorVoByIdUsingGet,
} from '@/services/backend/generatorController';
import { useSearchParams } from '@@/exports';
import type { ProFormInstance } from '@ant-design/pro-components';
import {
  ProCard,
  ProFormItem,
  ProFormSelect,
  ProFormText,
  ProFormTextArea,
  StepsForm,
} from '@ant-design/pro-components';
import { history } from '@umijs/max';
import { message, UploadFile } from 'antd';
import React, { useEffect, useRef, useState } from 'react';

/**
 * 生成器创建页面
 * @constructor
 */
const GeneratorAddPage: React.FC = () => {
  const formRef = useRef<ProFormInstance>();

  const [searchParams] = useSearchParams();
  const id = searchParams.get('id');
  const [oldData, setOldData] = useState<API.GeneratorEditRequest>();

  const loadData = async () => {
    if (!id) {
      return;
    }
    try {
      // @ts-ignore
      const res = await getGeneratorVoByIdUsingGet({ id });
      // 处理文件路径
      if (res.data) {
        const { distPath } = res.data ?? {};
        if (distPath) {
          // @ts-ignore
          res.data.distPath = [
            {
              uid: id,
              name: '文件' + id,
              status: 'done',
              url: COS_HOST + res,
              response: res,
            } as UploadFile,
          ];
        }
        setOldData(res.data);
      }
    } catch (e: any) {
      message.error('加载数据失败' + e.message);
    }
  };
  useEffect(() => {
    if (id) {
      loadData().then(() => {});
    }
  }, [id]);

  /**
   * 创建
   * @param values
   */
  const doAdd = async (values: API.GeneratorAddRequest) => {
    // 调用接口
    try {
      const res = await addGeneratorUsingPost(values);
      if (res.data) {
        message.success('创建成功');
        history.push(`/generator/detail/${res.data}`);
      }
    } catch (e: any) {
      message.error('创建失败.' + e.message);
    }
  };

  /**
   * 更新
   * @param values
   */
  const doUpdate = async (values: API.GeneratorEditRequest) => {
    // 调用接口
    try {
      const res = await editGeneratorUsingPost(values);
      if (res.data) {
        message.success('更新成功');
        history.push(`/generator/detail/${id}`);
      }
    } catch (e: any) {
      message.error('更新失败.' + e.message);
    }
  };

  const doSubmit = async (values: API.GeneratorAddRequest) => {
    // 数据转换
    if (!values.fileConfig) {
      values.fileConfig = {};
    }
    if (!values.modelConfig) {
      values.modelConfig = {};
    }
    // 文件列表转换为url
    if (values.distPath && values.distPath.length > 0) {
      // @ts-ignore
      values.distPath = values.distPath[0].response;
    }
    if (id) {
      await doUpdate({
        // @ts-ignore
        id,
        ...values,
      });
    } else {
      await doAdd(values);
    }
  };

  return (
    <ProCard>
      {/*创建或者已加载要更新的数据时,才渲染表单,顺利填充默认值*/}
      {(!id || oldData) && (
        <StepsForm<API.GeneratorAddRequest | API.GeneratorEditRequest>
          formRef={formRef}
          formProps={{ initialValues: oldData }}
          onFinish={doSubmit}
        >
          <StepsForm.StepForm
            name="base"
            title="基本信息"
            onFinish={async () => {
              console.log(formRef.current?.getFieldsValue());
              return true;
            }}
          >
            <ProFormText name="name" label="名称" placeholder="请输入名称" />
            <ProFormTextArea name="description" label="描述" placeholder="请输入描述" />
            <ProFormText name="basePackage" label="基础包" placeholder="请输入基础包" />
            <ProFormText name="version" label="版本" placeholder="请输入版本" />
            <ProFormText name="author" label="作者" placeholder="请输入作者" />
            <ProFormSelect label="标签" mode="tags" placeholder="请输入标签列表" />
            <ProFormItem name="picture" label="图片">
              <PictureUploader biz="generator_picture" />
            </ProFormItem>
          </StepsForm.StepForm>
          <StepsForm.StepForm name="fileConfig" title="文件配置">
            {/*  todo 待补充*/}
          </StepsForm.StepForm>
          <StepsForm.StepForm name="modelConfig" title="模型配置">
            {/*  todo 待补充*/}
          </StepsForm.StepForm>
          <StepsForm.StepForm name="dist" title="生成器文件">
            <ProFormItem label="产物包" name="distPath">
              <FileUploader biz="generator_dist" description="请上传生成器压缩包" />
            </ProFormItem>
          </StepsForm.StepForm>
        </StepsForm>
      )}
    </ProCard>
  );
};

export default GeneratorAddPage;
```

#### 代码生成器详情页面

完成了创建修改页面后，我们来开发详情页，能够展示代码生成器的详细信息，并且让用户下载生成器文件。

详情页依赖的后端接口如下：

1.  根据 id 获取生成器详情
2.  根据 id 下载代码生成器文件

第一个接口之前已经实现，还需要开发下载文件接口。

1)   在 `GeneratorController` 类中引入 `cosManager` 的 `Bean`：

```TypeScript
@Resource
private CosManager cosManager;
```

2)   新增下载接口，根据 id 获取到生成器的 `distPath` 并调用 `cosManager.getObject` 完成下载。

```Java
/**
 * 根据id下载代码生成器
 *
 * @param id       id
 * @param request  请求
 * @param response 响应
 * @throws IOException 异常
 */
@GetMapping("/download")
public void downloadGeneratorById(long id, HttpServletRequest request, HttpServletResponse response) throws IOException {
    if (id <= 0) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    User loginUser = userService.getLoginUser(request);
    Generator generator = generatorService.getById(id);
    if (generator == null) {
        throw new BusinessException(ErrorCode.NOT_FOUND_ERROR);
    }
    String filePath = generator.getDistPath();
    if (StrUtil.isBlank(filePath)) {
        throw new BusinessException(ErrorCode.NOT_FOUND_ERROR, "产物包不存在");
    }
    // 追踪事件日志
    log.info("用户{} 下载了 {}", loginUser, filePath);

    COSObjectInputStream cosObjectInput = null;
    try {
        COSObject cosObject = cosManager.getObject(filePath);
        cosObjectInput = cosObject.getObjectContent();
        // 处理下载到的流
        byte[] bytes = IOUtils.toByteArray(cosObjectInput);
        // 设置响应头
        response.setContentType("application/octet-stream;charset=UTF-8");
        response.setHeader("Content-Disposition", "attachment; filename=" + filePath);
        // 写入响应
        response.getOutputStream().write(bytes);
        response.getOutputStream().flush();
    } catch (Exception e) {
        log.error("file download error, filepath = " + filePath, e);
        throw new BusinessException(ErrorCode.SYSTEM_ERROR, "下载失败");
    } finally {
        if (cosObjectInput != null) {
            cosObjectInput.close();
        }
    }
}
```

##### 详情页面开发

1)   先定义路由，需要将路径指定为动态的，根据生成器的 id 加载不同的内容

```TypeScript
{
  path: '/generator/detail/:id',
  icon: 'home',
  component: './Generator/Detail',
  name: '生成器详情',
  hideInMenu: true,
},
```

2)   在详情页中，可以通过 useParams 钩子函数获取到动态路由的 id：

```TypeScript
const { id } = useParams();
```

就可以根据 id 获取到生成器的信息了，代码如下：

```TypeScript
const [loading, setLoading] = useState<boolean>(true);
const [data, setData] = useState<API.GeneratorVo>({});

const loadData = async () => {
  if (!id) {
    return;
  }
  setLoading(true);
  try {
    // @ts-ignore
    const res = await getGeneratorVoByIdUsingGet({ id });
    setData(res.data ?? {});
  } catch (e: any) {
    message.error('获取数据失败' + e.message);
  }
  setLoading(false);
};
useEffect(() => {
  if (id) {
    loadData().then(() => {});
  }
}, [id]);
```

3)自上而下开发页面，展示信息即可。

可以先编写出基本的结构，具体下载功能的实现、详细配置等最后再写。

页面上半部分展示生成器的基本信息、以及一些操作按钮，示例代码如下：

```TypeScript
<Card>
  <Row justify="space-between" gutter={[32, 32]}>
    <Col flex="auto">
      <Space size="large" align="center">
        <Typography.Title level={4}>{data.name}</Typography.Title>
        {tagListView(data.tags)}
      </Space>
      <Typography.Paragraph>{data.description}</Typography.Paragraph>
      <Typography.Paragraph type="secondary">
        创建时间: {moment(data.createTime).format('YYYY-MM-DD hh:mm:ss')}
      </Typography.Paragraph>
      <Typography.Paragraph type="secondary">基础包: {data.basePackage}</Typography.Paragraph>
      <Typography.Paragraph type="secondary">版本: {data.version}</Typography.Paragraph>
      <Typography.Paragraph type="secondary">作者: {data.author}</Typography.Paragraph>
      <div style={{ marginBottom: 24 }} />
      <Space size="middle">
        <Button type="primary">立即使用</Button>
        {downloadButton}
        {editButton}
      </Space>
    </Col>
    <Col flex="320px">
      <Image src={data.picture} />
    </Col>
  </Row>
</Card>
```

下半部分展示详细配置和作者信息。总共有 3 个 tab 栏，可以分别将每个 tab 栏的内容定义为组件，这样父页面就很干净。

```TypeScript
const items: TabsProps['items'] = [
  { key: 'fileConfig', label: '文件配置', children: <FileConfig data={data} /> },
  { key: 'modelConfig', label: '模型配置', children: <ModelConfig data={data} /> },
  { key: 'userInfo', label: '作者信息', children: <AuthorInfo data={data} /> },
];
```

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2ViYzk5YjBmYjQ3ZDNmODhlZTdjMTg4NmFjODJhY2NfdU5LU3hvRXFDNDVKOVpseUlEN0gyalZoTEV5WldhaUJfVG9rZW46S1lyc2JycWRvb2ZSaG54SnBhNmNjWXBubmNoXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

4)   开发详细信息组件

文件配置组件`FileConfig`组件

```TypeScript
import { FileOutlined, InfoCircleOutlined } from '@ant-design/icons';
import { Descriptions, DescriptionsProps, Divider } from 'antd';
import React from 'react';

interface Props {
  data: API.GeneratorVo;
}

/**
 * 文件配置
 * @constructor
 */
const FileConfig: React.FC<Props> = (props) => {
  const { data } = props;

  const fileConfig = data?.fileConfig;
  if (!fileConfig) {
    return <></>;
  }

  const items: DescriptionsProps['items'] = [
    {
      key: 'inputRootPath',
      label: '输入根路径',
      children: <p>{fileConfig.inputRootPath}</p>,
    },
    {
      key: 'outputRootPath',
      label: '输出根路径',
      children: <p>{fileConfig.outputRootPath}</p>,
    },
    {
      key: 'sourceRootPath',
      label: '项目根路径',
      children: <p>{fileConfig.sourceRootPath}</p>,
    },
    {
      key: 'type',
      label: '文件类别',
      children: <p>{fileConfig.type}</p>,
    },
  ];

  const fileListView = (files?: API.FileInfo[]) => {
    if (!files) {
      return <></>;
    }

    return (
      <>
        {files.map((file, index) => {
          // 是分组
          if (file.groupKey) {
            const groupFileItems: DescriptionsProps['items'] = [
              {
                key: 'groupKey',
                label: '分组key',
                children: <p>{file.groupKey}</p>,
              },
              {
                key: 'groupName',
                label: '分组名',
                children: <p>{file.groupName}</p>,
              },
              {
                key: 'condition',
                label: '条件',
                children: <p>{file.condition}</p>,
              },
              {
                key: 'files',
                label: '组内文件',
                children: <p>{fileListView(file.files)}</p>,
              },
            ];

            return (
              <Descriptions key={index} column={1} title={file.groupName} items={groupFileItems} />
            );
          }

          const fileItems: DescriptionsProps['items'] = [
            {
              key: 'inputPath',
              label: '输入路径',
              children: <p>{file.inputPath}</p>,
            },
            {
              key: 'outputPath',
              label: '输出路径',
              children: <p>{file.outputPath}</p>,
            },
            {
              key: 'type',
              label: '文件类别',
              children: <p>{file.type}</p>,
            },
            {
              key: 'generateType',
              label: '文件生成类别',
              children: <p>{file.generateType}</p>,
            },
            {
              key: 'condition',
              label: '条件',
              children: <p>{file.condition}</p>,
            },
          ];

          return (
            <>
              <Descriptions column={2} key={index} items={fileItems} />
              <Divider />
            </>
          );
        })}
      </>
    );
  };

  return (
    <div>
      <Descriptions
        title={
          <>
            {/*@ts-ignore*/}
            <InfoCircleOutlined /> 基本信息
          </>
        }
        column={2}
        items={items}
      />
      <div style={{ marginBottom: 16 }} />
      <Descriptions
        title={
          <>
            {/*@ts-ignore*/}
            <FileOutlined /> 文件列表
          </>
        }
      />
      {fileListView(fileConfig.files)}
    </div>
  );
};

export default FileConfig;
```

模型配置组件`ModelConfig`

```TypeScript
import { FileOutlined } from '@ant-design/icons';
import { Descriptions, DescriptionsProps, Divider } from 'antd';
import React from 'react';

interface Props {
  data: API.GeneratorVo;
}

/**
 * 模型配置
 * @constructor
 */
const ModelConfig: React.FC<Props> = (props) => {
  const { data } = props;

  const modelConfig = data?.modelConfig;
  if (!modelConfig) {
    return <></>;
  }

  const modelListView = (models?: API.ModelInfo[]) => {
    if (!models) {
      return <></>;
    }

    return (
      <>
        {models.map((model, index) => {
          // 是分组
          if (model.groupKey) {
            const groupModelItems: DescriptionsProps['items'] = [
              {
                key: 'groupKey',
                label: '分组key',
                children: <p>{model.groupKey}</p>,
              },
              {
                key: 'groupName',
                label: '分组名',
                children: <p>{model.groupName}</p>,
              },
              {
                key: 'condition',
                label: '条件',
                children: <p>{model.condition}</p>,
              },
              {
                key: 'models',
                label: '组内模型',
                children: <p>{modelListView(model.models)}</p>,
              },
            ];

            return (
              <Descriptions
                key={index}
                column={1}
                title={model.groupName}
                items={groupModelItems}
              />
            );
          }

          const modelItems: DescriptionsProps['items'] = [
            {
              key: 'fieldName',
              label: '字段名称',
              children: <p>{model.fieldName}</p>,
            },
            {
              key: 'type',
              label: '类型',
              children: <p>{model.type}</p>,
            },
            {
              key: 'description',
              label: '描述',
              children: <p>{model.description}</p>,
            },
            {
              key: 'defaultValue',
              label: '默认值',
              children: <p>{model.defaultValue as any}</p>,
            },
            {
              key: 'abbr',
              label: '缩写',
              children: <p>{model.abbr}</p>,
            },
            {
              key: 'condition',
              label: '条件',
              children: <p>{model.condition}</p>,
            },
          ];

          return (
            <>
              <Descriptions column={2} key={index} items={modelItems} />
              <Divider />
            </>
          );
        })}
      </>
    );
  };

  return (
    <div>
      <Descriptions
        title={
          <>
            {/*@ts-ignore*/}
            <FileOutlined /> 模型列表
          </>
        }
      />
      {modelListView(modelConfig.models)}
    </div>
  );
};

export default ModelConfig;
```

作者信息组件`AuthorInfo`

```TypeScript
import { Card } from 'antd';
import React from 'react';

interface Props {
  data: API.GeneratorVo;
}

/**
 * 作者信息
 * @param props
 * @constructor
 */
const AuthorInfoPage: React.FC<Props> = (props) => {
  const { data } = props;
  const user = data?.user;
  if (!user) {
    return <></>;
  }
  return (
    <div style={{ marginTop: 16 }}>
      <Card.Meta title={user.userName} description={user.userProfile} avatar={user.userAvatar} />
    </div>
  );
};

export default AuthorInfoPage;
```

##### 下载功能实现

```TypeScript
/**
 * 下载按钮
 */
const downloadButton = data.distPath && currentUser && (
  <Button
    //@ts-ignore
    icon={<DownloadOutlined />}
    onClick={async () => {
      const blob = await downloadGeneratorByIdUsingGet(
        {
          // @ts-ignore
          id,
        },
        {
          responseType: 'blob',
        },
      );
      const fullPath = data.distPath || '';
      saveAs(blob, fullPath.substring(fullPath.lastIndexOf('/') + 1));
    }}
  >
    下载
  </Button>
);

/**
 * 编辑按钮
 */
const editButton = my && (
    <Link to={`/generator/update?id=${data.id}`}>
      {/*@ts-ignore*/}
      <Button icon={<EditOutlined />}>编辑</Button>
    </Link>

);
```

然后在详情页中引用这两个按钮

```TypeScript
import { COS_HOST } from '@/constants';
import AuthorInfo from '@/pages/Generator/Detail/components/AuthorInfo';
import FileConfig from '@/pages/Generator/Detail/components/FileConfig';
import ModelConfig from '@/pages/Generator/Detail/components/ModelConfig';
import {
  downloadGeneratorByIdUsingGet,
  getGeneratorVoByIdUsingGet,
} from '@/services/backend/generatorController';
import {Link, useModel, useParams} from '@@/exports';
import { DownloadOutlined, EditOutlined } from '@ant-design/icons';
import { PageContainer } from '@ant-design/pro-components';
import {
  Button,
  Card,
  Col,
  Image,
  message,
  Row,
  Space,
  Tabs,
  TabsProps,
  Tag,
  Typography,
} from 'antd';
import { saveAs } from 'file-saver';
import moment from 'moment';
import React, { useEffect, useState } from 'react';

/**
 * 生成器创建页面
 * @constructor
 */
const GeneratorDetailPage: React.FC = () => {
  const { id } = useParams();
  const [loading, setLoading] = useState<boolean>(true);
  const [data, setData] = useState<API.GeneratorVo>({});

  const loadData = async () => {
    if (!id) {
      return;
    }
    setLoading(true);
    try {
      // @ts-ignore
      const res = await getGeneratorVoByIdUsingGet({ id });
      setData(res.data ?? {});
    } catch (e: any) {
      message.error('获取数据失败' + e.message);
    }
    setLoading(false);
  };
  useEffect(() => {
    if (id) {
      loadData().then(() => {});
    }
  }, [id]);

  /**
   * 标签列表
   * @param tags 标签数组
   */
  const tagListView = (tags?: string[]) => {
    if (!tags) {
      return <></>;
    }
    return (
      <div style={{ marginBottom: 8 }}>
        {tags.map((tag) => (
          <Tag key={tag}>{tag}</Tag>
        ))}
      </div>
    );
  };

  const items: TabsProps['items'] = [
    { key: 'fileConfig', label: '文件配置', children: <FileConfig data={data} /> },
    { key: 'modelConfig', label: '模型配置', children: <ModelConfig data={data} /> },
    { key: 'userInfo', label: '作者信息', children: <AuthorInfo data={data} /> },
  ];

  const { initialState } = useModel('@@initialState');
  const { currentUser } = initialState ?? {};
  const my = data?.userId === currentUser.id;
  /**
   * 下载按钮
   */
  const downloadButton = data.distPath && currentUser && (
    <Button
      //@ts-ignore
      icon={<DownloadOutlined />}
      onClick={async () => {
        const blob = await downloadGeneratorByIdUsingGet(
          {
            // @ts-ignore
            id,
          },
          {
            responseType: 'blob',
          },
        );
        const fullPath = data.distPath || '';
        saveAs(blob, fullPath.substring(fullPath.lastIndexOf('/') + 1));
      }}
    >
      下载
    </Button>
  );

  /**
   * 编辑按钮
   */
  const editButton = my && (
      <Link to={`/generator/update?id=${data.id}`}>
        {/*@ts-ignore*/}
        <Button icon={<EditOutlined />}>编辑</Button>
      </Link>

  );

  return (
    <PageContainer title={<></>} loading={loading}>
      <Card>
        <Row justify="space-between" gutter={[32, 32]}>
          <Col flex="auto">
            <Space size="large" align="center">
              <Typography.Title level={4}>{data.name}</Typography.Title>
              {tagListView(data.tags)}
            </Space>
            <Typography.Paragraph>{data.description}</Typography.Paragraph>
            <Typography.Paragraph type="secondary">
              创建时间: {moment(data.createTime).format('YYYY-MM-DD hh:mm:ss')}
            </Typography.Paragraph>
            <Typography.Paragraph type="secondary">基础包: {data.basePackage}</Typography.Paragraph>
            <Typography.Paragraph type="secondary">版本: {data.version}</Typography.Paragraph>
            <Typography.Paragraph type="secondary">作者: {data.author}</Typography.Paragraph>
            <div style={{ marginBottom: 24 }} />
            <Space size="middle">
              <Button type="primary">立即使用</Button>
              {downloadButton}
              {editButton}
            </Space>
          </Col>
          <Col flex="320px">
            <Image src={data.picture} />
          </Col>
        </Row>
      </Card>
      <div style={{ marginBottom: 24 }} />
      <Card>
        <Tabs defaultActiveKey="fileConfig" items={items} onChange={() => {}} />
      </Card>
    </PageContainer>
  );
};

export default GeneratorDetailPage;
```

给主页的生成器卡片增加跳转到详情页的功能

```TypeScript
<Link to={`/generator/detail/${data.id}`}>
  <Card hoverable cover={<Image alt={data.name} src={data.picture} />}>
    <Card.Meta
      title={<a>{data.name}</a>}
      description={
        <Typography.Paragraph
          ellipsis={{
            rows: 2,
          }}
          style={{ height: 44 }}
        >
          {data.description}
        </Typography.Paragraph>
      }
    />
    {tagListView(data.tags ?? [])}
    <Flex justify="space-between" align="center">
      <Typography.Paragraph type="secondary" style={{ fontSize: 12 }}>
        {moment(data.createTime).fromNow()}
      </Typography.Paragraph>
      <div>
        {/*@ts-ignore*/}
        <Avatar src={data.user?.userAvatar ?? UserOutlined}></Avatar>
      </div>
    </Flex>
  </Card>
</Link>
```

## 十、代码生成器在线使用

### 需求分析

之前用户想要使用平台上的代码生成器，必须要将生成器文件下载到本地、解压、熟悉参数再交互式运行，对不熟悉平台和命令行工具的朋友来说，其实是比较麻烦的。

既然我们有了平台，为什么不直接让用户在平台上使用代码生成器呢？

所以，现在我们的需求就是：让用户能够在线使用代码生成器，在表单页面输入数据模型的值，就能直接下载生成的代码。

### 核心设计

#### 业务流程

让我们先来梳理一下业务流程：

1)用户打开某个生成器的使用页面，从后端请求需要用户填写的数据模型

2)用户填写表单并提交，向后端发送请求

3)后端从数据库中查间生成器信息，得到生成器产物文件路径

4)后端从对象存储中下载生成器产物文件到本地

5)后端操作代码生成器，输入用户填写的数据，得到生成的代码

6)后端将生成的代码返回给用户，前端下载

业务流程图如下:

暂时无法在飞书文档外展示此内容

#### 问题分析

分析上述流程，我们要思考几个问题：

1)生成器使用页面需要展示哪些表单项？数据模型信息从哪里来？

2)web后端怎么操作代码生成器文件去生成代码？

##### 数据模型从哪来?

第一个问题很简单，最原始的数据模型信息肯定是由用户创建生成器时填写的，所以我们需要完善创建生成器页面的"模型配置”表单。有了模型配置，生成器使用页面就可以渲染出对应的表单项，供用户填写。

##### 如何操作生成器?

对于第二个问题，我们要先思考：之前是怎么生成代码的？

答案是：通过执行脚本文件、传入指定的参数、交互式输入、最终得到生成的代码。

那现在，让web后端执行生成器的脚本文件，不就可以了么？之前已经讲过，在Java后端项目中，使用Process类就能执行命令行脚本了。

但是之前执行生成器时，只能通过交互式输入、或者拼接命令的方式给生成器程序传递参数，而前端传递给后端的用户参数通常是JSON对象格式，如果要转换就比较复杂了。

那我们不妨让代码生成器支持一种新的使用方式：通过读取JSON文件获取数据模型，并生成代码。

>   问: 为什么不直接传入json数据而是要读取json文件呢?
>
>   答: json数据结构可能很复杂,担心控制台输入字符出现特殊问题

这样一来，wb后端项目就可以将用户输入的数据模型值SON保存为本地文件，然后将文件路径作为输入参数去执行生成器脚本了。相比于将每个生成器都改造为wb项目提供接口，这种方式成本更低，也更合理。

明确了实现思路后，我们依次完成后端和前端开发。

### 后端开发

后端开发工作分为：

1.  单个代码生成器改造，支持JSON输入
2.  修改制作工具，生成支持JSON输入的代码生成器
3.  使用生成器接口开发

#### 0、准备工作

##### 示例数据

在此之前,我们先往数据库中插入一条代码生成器数据,便于后续测试

```SQL
INSERT INTO manneia_generator_db.generator (id, name, description, basePackage, version, author, tags, picture,
                                            fileConfig, modelConfig, distPath, status, userId, createTime, updateTime,
                                            isDelete)
VALUES (18, 'acm-template-pro-generator', 'ACM 模板项目生成器','com.manneia','1.0','lkx','[\"Java\"]','https://pic.yupi.icu/1/_r0_c1851-bf115939332e.jpg',
        '{\"type\": \"dir\", \"files\": [{\"type\": \"file\", \"inputPath\": \"src/com/manneia/acm/MainTemplate.java.ftl\", \"outputPath\": \"src/com/manneia/acm/MainTemplate.java\", \"generateType\": \"dynamic\"}, {\"type\": \"group\", \"files\": [{\"type\": \"file\", \"condition\": \"needGit\", \"inputPath\": \".gitignore\", \"outputPath\": \".gitignore\", \"generateType\": \"static\"}, {\"type\": \"file\", \"inputPath\": \"README.md\", \"outputPath\": \"README.md\", \"generateType\": \"static\"}], \"groupKey\": \"acmTemplate\", \"condition\": \"needGit\", \"groupName\": \"gitignore 和 README.md\"}], \"inputRootPath\": \".source/acm-template-pro\", \"outputRootPath\": \"generated\", \"sourceRootPath\": \"D:/Project/project/manneia-generator/manneia-generator-demo-projects/acm-template-pro\"}',
        '{\"models\": [{\"abbr\": \"n\", \"type\": \"Boolean\", \"fieldName\": \"needGit\", \"description\": \"是否生成.gitignore文件\", \"defaultValue\": true}, {\"abbr\": \"l\", \"type\": \"Boolean\", \"fieldName\": \"loop\", \"description\": \"是否生成循环\", \"defaultValue\": false}, {\"type\": \"MainTemplate\", \"models\": [{\"abbr\": \"a\", \"type\": \"String\", \"fieldName\": \"author\", \"description\": \"作者注释\", \"defaultValue\": \"azhang\"}, {\"abbr\": \"o\", \"type\": \"String\", \"fieldName\": \"outputText\", \"description\": \"输出信息\", \"defaultValue\": \"sum = \"}], \"groupKey\": \"mainTemplate\", \"condition\": \"loop\", \"groupName\": \"核心模板\", \"description\": \"核心模板参数\"}]}',
        '/generator_dist/1770443805628088322/acm-template-pro-generator.zip',
        0,
        1770443805628088322,
        '2024-02-04 21:57:59',
        '2024-02-11 18:53:05',
        0);
```

#### 1、单个代码生成器改造

在修改maker制作工具项目前，我们先从之前已经生成的单个代码生成器`acm-template-pro-generator`下

手，让它能支持JSON输入并生成代码。

1)打开ACM模板代码生成器项目，在cli.command包下新增一个JSON生成命令类`JsonGenerateCommand`。

定义一个文件路径(filePath)属性来接受JSON文件路径，在执行时读取该文件并转换为DataModel数据模型类，之后调用`MainGenerator.doGenerate`生成代码即可。

```Java
package com.manneia.cli.command;

import cn.hutool.core.io.FileUtil;
import cn.hutool.json.JSONUtil;
import com.manneia.generator.MainGenerator;
import com.manneia.model.DataModel;
import lombok.Data;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;

import java.util.concurrent.Callable;

/**
 * 读取json文件生成代码
 *
 * @author manneia
 */
@Command(name = "json-generate", description = "读取json文件 生成代码", mixinStandardHelpOptions = true)
@Data
public class JsonGenerateCommand implements Callable<Integer> {

    @Option(names = {"-f", "--file"}, arity = "0..1", description = "json 文件路径",
            interactive = true, echo = true)
    private String filePath;

    @Override
    public Integer call() throws Exception {
        // 读取json 文件 转换为数据模型
        String jsonStr = FileUtil.readUtf8String(filePath);
        DataModel datamodel = JSONUtil.toBean(jsonStr, DataModel.class);
        MainGenerator.doGenerator(datamodel);
        return 0;
    }
}
```

2)   修改`CommandExecutor`类,补充刚创建的子命令

修改的部分代码如下:

```Java
{
    commandLine = new CommandLine(this)
            .addSubcommand(new GenerateCommand())
            .addSubcommand(new ListCommand())
            .addSubcommand(new ConfigCommand())
            .addSubcommand(new JsonGenerateCommand());
}
```

3)   测试

先在生成器项目根目录下新建文件`test.json`

代码如下:

```JSON
{
  "needGit":true,
  "loop":false,
  "mainTemplate":{
    "author":"lkx",
    "outputText":"sum = "
  }
}
```

修改Main方法,硬编码参数值.代码如下:

```Java
package com.azhang;


import com.azhang.cli.CommandExecutor;

/**
 * @author azhang
 * @date 2024-2-11 18:50:48
 */
public class Main {
    public static void main(String[] args) {
        CommandExecutor commandExecutor = new CommandExecutor();
        args = new String[]{"json-generate", "--file=D:/Project/project/manneia-generator/manneia-generator-maker/Generated/acm-template-pro-generator/test.json"};
        commandExecutor.doExecute(args);
    }
}
```

检查生成的代码, 测试成功

#### 2、修改制作工具

需要修改maker项目，支持动态生成上述我们手动编写的代码。

1)在资源文件的模板泪录下新建JSON生成命令类对应的FTL文件`JsonGenerateCommand.java.ftl`,

除了包名外不用做其他变动，完整代码如下：

```Java
package ${basePackage}.cli.command;

import cn.hutool.core.io.FileUtil;
import cn.hutool.json.JSONUtil;
import ${basePackage}.cli.util.ReflexUtil;
import ${basePackage}.generator.MainGenerator;
import ${basePackage}.model.DataModel;
import lombok.Data;
import lombok.SneakyThrows;
import picocli.CommandLine;


/**
 * @author ${author}
 * @date ${.now}
 * @description 读取json生成命令
 */
@Data
@CommandLine.Command(name = "json-generate", mixinStandardHelpOptions = true, description = "读取json生成命令")
public class JsonGenerateCommand implements Runnable {


    /**
     * json文件路径
     */
    @CommandLine.Option(
            names = {"-f", "--file"},
            arity = "0..1",
            description = "json文件路径",
            echo = true,
            interactive = true)
    private String filePath;


    @SneakyThrows
    @Override
    public void run() {
        <#if forcedInteractiveSwitch>
        ReflexUtil.setFieldsWithInteractiveAnnotation(this, this.getClass());
        </#if>

        String dataModelStr = FileUtil.readUtf8String(filePath);
        DataModel dataModel = JSONUtil.toBean(dataModelStr, DataModel.class);
        MainGenerator.doGenerate(dataModel);
    }
}
```

2)   修改`CommandExecutor.java.ftl`文件

补充命令的引入

```Java
package ${basePackage}.cli;

import ${basePackage}.cli.command.ConfigCommand;
import ${basePackage}.cli.command.GenerateCommand;
import ${basePackage}.cli.command.JsonGenerateCommand;
import ${basePackage}.cli.command.ListCommand;
import picocli.CommandLine;
import picocli.CommandLine.Command;

/**
 * @author ${author}
 * @date ${.now}
 * @description 绑定所有子命令
 */
@Command(name = "${name}", mixinStandardHelpOptions = true, version = "1.0")
public class CommandExecutor implements Runnable {

    private final CommandLine commandLine;

    {
        commandLine = new CommandLine(this)
                .addSubcommand(new GenerateCommand())
                .addSubcommand(new ListCommand())
                .addSubcommand(new ConfigCommand())
                .addSubcommand(new JsonGenerateCommand());
    }


    @Override
    public void run() {
        // 不执行子命令时候 打印帮助信息
        commandLine.usage(System.out);
    }

    /**
     * 执行子命令
     *
     * @param args 命令行参数
     */
    public void doExecute(String[] args) {
        commandLine.execute(args);
    }

}
```

3)   修改生成器制作类`GenerateTemplate`的`generateCode`方法,补充对新命令文件的生成

```Java
// command JsonGenerateCommand
inputFilePath = inputResourcePath + File.separator + "templates/java/cli/command" + File.separator + "JsonGenerateCommand.java.ftl";
outputFilePath = outputBaseJavaPackagePath + File.separator + "/cli/command/JsonGenerateCommand.java";
DynamicFileGenerator.doGenerate(inputFilePath, outputFilePath, meta);
```

4)   执行maker项目的Main方法,进行测试,能够顺利生成符合要求的代码生成器

#### 3、使用生成器接口

按照之前设计的业务流程，开发使用生成器的接口。

1)定义接口

先明确接口的定义：接受用户输入的模型参数，返回生成的文件。

在`model.dto.generator`,包下新建请求类`GeneratorUseRequest`,代a码如下：

```Java
package com.manneia.generateweb.model.dto.Generator;

import lombok.Data;

import java.io.Serializable;
import java.util.Map;

/**
 * 使用代码生成器
 *
 * @author lkx
 */
@Data
public class GeneratorUseRequest implements Serializable {

    /**
     * 生成器的 id
     */
    private long id;

    /**
     * 数据模型
     */
    private Map<String, Object> dataModel;

    private static final long serialVersionUID = -9036927636842835234L;
}
```

在`GeneratorController`中新增接口,代码如下:

```Java
/**
 * 使用代码生成器
 *
 * @param generatorUseRequest 代码生成器使用参数
 * @param request             请求
 * @param response            响应
 * @throws IOException 异常
 */
@PostMapping("/use")
public void useGenerator(@RequestBody GeneratorUseRequest generatorUseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException {}
```

2)   从对象存储下载生成器压缩包

先获取到代码生成器的存储路径

```Java
// 获取用户输入的请求参数
long id = generatorUseRequest.getId();
Map<String, Object> dataModel = generatorUseRequest.getDataModel();

// 需要用户登录
User loginUser = userService.getLoginUser(request);
log.info("userId = {} 使用了生成器 id = {}", loginUser.getId(), id);
Generator generator = generatorService.getById(id);
if (generator == null) {
    throw new BusinessException(ErrorCode.NOT_FOUND_ERROR);
}
// 生成器的存储路径
String distPath = generator.getDistPath();
if (StrUtil.isBlank(distPath)) {
    throw new BusinessException(ErrorCode.NOT_FOUND_ERROR, "产物包不存在");
}
```

定义一个独立的工作空间,用来存放下载的生成器压缩包等临时文件.

```Java
// 定义独立的工作空间
String projectPath = System.getProperty("user.dir");
String tempDirPath = String.format("%s/.temp/use/%s", projectPath, id);
```

由于本次需要根据产物包路径 将产物包下载到本地 我们需要通过腾讯云官方文档来获取如何下载文件到本地 文档地址: https://cloud.tencent.com/document/product/436/65937#.E4.B8.8B.E8.BD.BD.E5.AF.B9.E8.B1.A1

修改 `CosManager`补充下载方法,需要注意使用线程池提高下载效率：

```Java
package com.manneia.generateweb.manager;

import com.manneia.generateweb.config.CosClientConfig;
import com.qcloud.cos.COSClient;
import com.qcloud.cos.model.COSObject;
import com.qcloud.cos.model.GetObjectRequest;
import com.qcloud.cos.model.PutObjectRequest;
import com.qcloud.cos.model.PutObjectResult;
import com.qcloud.cos.transfer.Download;
import com.qcloud.cos.transfer.TransferManager;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import java.io.File;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Cos 对象存储操作
 *
 * @author lkx
 * 
 */
@Component
public class CosManager {

    @Resource
    private CosClientConfig cosClientConfig;

    @Resource
    private COSClient cosClient;

    //复用下载对象
    private TransferManager transferManager;


    // bean 加载完成后执行
    @PostConstruct
    public void init() {
        // 自定义线程池大小，建议在客户端与 COS 网络充足（例如使用腾讯云的 CVM，同地域上传 COS）的情况下，设置成16或32即可，可较充分的利用网络资源
        // 对于使用公网传输且网络带宽质量不高的情况，建议减小该值，避免因网速过慢，造成请求超时。
        ExecutorService threadPool = Executors.newFixedThreadPool(32);


        // 传入一个 threadpool, 若不传入线程池，默认 TransferManager 中会生成一个单线程的线程池。
        transferManager = new TransferManager(cosClient, threadPool);

    }

    /**
     * 上传对象
     *
     * @param key 唯一键
     * @param localFilePath 本地文件路径
     * @return
     */
    public PutObjectResult putObject(String key, String localFilePath) {
        PutObjectRequest putObjectRequest = new PutObjectRequest(cosClientConfig.getBucket(), key,
                new File(localFilePath));
        return cosClient.putObject(putObjectRequest);
    }

    /**
     * 上传对象
     *
     * @param key 唯一键
     * @param file 文件
     * @return
     */
    public PutObjectResult putObject(String key, File file) {
        PutObjectRequest putObjectRequest = new PutObjectRequest(cosClientConfig.getBucket(), key,
                file);
        return cosClient.putObject(putObjectRequest);
    }

    /**
     * 下载对象
     *
     * @param key 唯一键
     * @return 下载结果
     */
    public COSObject getObject(String key) {
        GetObjectRequest getObjectRequest = new GetObjectRequest(cosClientConfig.getBucket(), key);
        return cosClient.getObject(getObjectRequest);
    }

    /**
     * 下载文件到服务器
     *
     * @param key           唯一键
     * @param localFilePath 本地文件路径
     * @return 返回一个下载对象
     */
    public Download download(String key, String localFilePath) throws InterruptedException {
        File downloadFile = new File(localFilePath);
        GetObjectRequest getObjectRequest = new GetObjectRequest(cosClientConfig.getBucket(), key);
        Download download = transferManager.download(getObjectRequest, downloadFile);
        download.waitForCompletion();
        return download;
    }
}
```

上述代码中的`@PostConstruct`注解，用于等Bean加载完成后，初始化对象存储下载对像。

然后就可以在接口中调用，实现压缩包的下载了：

```Java
String zipFilePath = tempDirPath + "/dist.zip";
// 新建文件
if (!FileUtil.exist(zipFilePath)) {
    FileUtil.touch(zipFilePath);
}
try {
    cosManager.download(distPath, zipFilePath);
} catch (InterruptedException e) {
    throw new BusinessException(ErrorCode.SYSTEM_ERROR, "生成器下载失败");
}
```

3)   解压文件,得到用户上传的生成器文件

```Java
// 解压压缩包
File unzipDistDir = ZipUtil.unzip(zipFilePath);
```

4)   将用户输入的参数,写入json文件

```Java
// 将用户输入的参数写入json文件中
String dataModelFilePath = tempDirPath + "/dataModel.json";
String jsonStr = JSONUtil.toJsonStr(dataModel);
FileUtil.writeUtf8String(jsonStr, dataModelFilePath);
```

5)   执行脚本

首先要找到代码生成器文件中的脚本路径，通过递归目录找到第一个名称为“generator”的文件。

注意如果是非windows系统，还要添加可执行权限。

```Java
// 执行脚本
// 找到脚本文件所在路径
// 要注意, 如果不是windows系统,找 generator 文件而不是bat 文件
File scriptFile = FileUtil.loopFiles(unzipDistDir, 2, null)
        .stream().filter(file -> file.isFile() && "generator.bat".equals(file.getName()))
        .findFirst()
        .orElseThrow(RuntimeException::new);
// 添加可执行权限
try {
    Set<PosixFilePermission> permissions = PosixFilePermissions.fromString("rwxrwxrwx");
    Files.setPosixFilePermissions(scriptFile.toPath(), permissions);
} catch (Exception e) {
}
```

然后构造脚本调用命令，传入之前写入的SON文件路径，调用脚本并获取输出结果。需要格外注意！windows系统和其他操作系统执行脚本的规则不同，需要对路径进行转义。

代码如下：

```Java
File scriptDir = scriptFile.getParentFile();
String scriptAbsolutePath = scriptFile.getAbsolutePath().replace("\\", "/");
String[] commands = new String[]{scriptAbsolutePath, "json-generate", "--file=" + dataModelFilePath};
// 创建ProcessBuilder并设置执行的命令
ProcessBuilder processBuilder = new ProcessBuilder(commands);
// 如果项目目录非空，则设置命令执行的目录
processBuilder.directory(scriptDir);
try {
    // 启动进程
    Process process = processBuilder.start();
    // 获取进程的输出流，并读取输出信息
    InputStream inputStream = process.getInputStream();
    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
    String line;
    while ((line = bufferedReader.readLine()) != null) {
        System.out.println(line); // 打印命令执行的输出信息
    }
    int exitCode = process.waitFor();
    System.out.println("命令执行结束,退出码:" + exitCode);
} catch (InterruptedException e) {
    log.error(e.getMessage());
    throw new BusinessException(ErrorCode.SYSTEM_ERROR, "执行生成器脚本错误");
}
```

6)   返回生成的代码结果压缩包

执行上述脚本后，默认生成的代码在代码生成器根目录下的generated目录中。为了便于用户下载，需要先将生成的代码制作为压缩包，再下载。

```Java
// 压缩得到的生成结果, 返回给前端
String generatedPath = scriptDir.getAbsolutePath() + "/generated";
String resultPath = tempDirPath + "/result.zip";
File resultFile = ZipUtil.zip(generatedPath, resultPath);
// 下载文件
// 设置响应头
response.setContentType("application/octet-stream;charset=UTF-8");
response.setHeader("Content-Disposition", "attachment; filename=" + resultFile.getName());
Files.copy(resultFile.toPath(), response.getOutputStream());
```

7)   清理文件

已经将结果返回给前端了，最后可以异步清理无用文件，目前可以直接清理整个工作空间。

```Java
// 清理工作空间临时文件
CompletableFuture.runAsync(() -> {
    FileUtil.del(tempDirPath);
});
```

该接口的完整代码如下:

```Java
/**
 * 使用代码生成器
 *
 * @param generatorUseRequest 代码生成器使用参数
 * @param request             请求
 * @param response            响应
 * @throws IOException 异常
 */
@PostMapping("/use")
public void useGenerator(@RequestBody GeneratorUseRequest generatorUseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException {
    // 获取用户输入的请求参数
    long id = generatorUseRequest.getId();
    Map<String, Object> dataModel = generatorUseRequest.getDataModel();

    // 需要用户登录
    User loginUser = userService.getLoginUser(request);
    log.info("userId = {} 使用了生成器 id = {}", loginUser.getId(), id);
    Generator generator = generatorService.getById(id);
    if (generator == null) {
        throw new BusinessException(ErrorCode.NOT_FOUND_ERROR);
    }
    // 生成器的存储路径
    String distPath = generator.getDistPath();
    if (StrUtil.isBlank(distPath)) {
        throw new BusinessException(ErrorCode.NOT_FOUND_ERROR, "产物包不存在");
    }
    // 从对象存储下载代码生成器压缩包
    // 定义独立的工作空间
    String projectPath = System.getProperty("user.dir");
    String tempDirPath = String.format("%s/.temp/use/%s", projectPath, id);
    String zipFilePath = tempDirPath + "/dist.zip";
    // 新建文件
    if (!FileUtil.exist(zipFilePath)) {
        FileUtil.touch(zipFilePath);
    }
    try {
        cosManager.download(distPath, zipFilePath);
    } catch (InterruptedException e) {
        throw new BusinessException(ErrorCode.SYSTEM_ERROR, "生成器下载失败");
    }
    // 解压压缩包
    File unzipDistDir = ZipUtil.unzip(zipFilePath);
    // 将用户输入的参数写入json文件中
    String dataModelFilePath = tempDirPath + "/dataModel.json";
    String jsonStr = JSONUtil.toJsonStr(dataModel);
    FileUtil.writeUtf8String(jsonStr, dataModelFilePath);
    // 执行脚本
    // 找到脚本文件所在路径
    // 要注意, 如果不是windows系统,找 generator 文件而不是bat 文件
    File scriptFile = FileUtil.loopFiles(unzipDistDir, 2, null)
            .stream().filter(file -> file.isFile() && "generator.bat".equals(file.getName()))
            .findFirst()
            .orElseThrow(RuntimeException::new);
    // 添加可执行权限
    try {
        Set<PosixFilePermission> permissions = PosixFilePermissions.fromString("rwxrwxrwx");
        Files.setPosixFilePermissions(scriptFile.toPath(), permissions);
    } catch (Exception e) {
    }
    File scriptDir = scriptFile.getParentFile();
    String scriptAbsolutePath = scriptFile.getAbsolutePath().replace("\\", "/");
    String[] commands = new String[]{scriptAbsolutePath, "json-generate", "--file=" + dataModelFilePath};
    // 创建ProcessBuilder并设置执行的命令
    ProcessBuilder processBuilder = new ProcessBuilder(commands);
    // 如果项目目录非空，则设置命令执行的目录
    processBuilder.directory(scriptDir);
    try {
        // 启动进程
        Process process = processBuilder.start();
        // 获取进程的输出流，并读取输出信息
        InputStream inputStream = process.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        String line;
        while ((line = bufferedReader.readLine()) != null) {
            System.out.println(line); // 打印命令执行的输出信息
        }
        int exitCode = process.waitFor();
        System.out.println("命令执行结束,退出码:" + exitCode);
    } catch (InterruptedException e) {
        log.error(e.getMessage());
        throw new BusinessException(ErrorCode.SYSTEM_ERROR, "执行生成器脚本错误");
    }
    // 压缩得到的生成结果, 返回给前端
    String generatedPath = scriptDir.getAbsolutePath() + "/generated";
    String resultPath = tempDirPath + "/result.zip";
    File resultFile = ZipUtil.zip(generatedPath, resultPath);
    // 下载文件
    // 设置响应头
    response.setContentType("application/octet-stream;charset=UTF-8");
    response.setHeader("Content-Disposition", "attachment; filename=" + resultFile.getName());
    Files.copy(resultFile.toPath(), response.getOutputStream());
    // 清理工作空间临时文件
    CompletableFuture.runAsync(() -> {
        FileUtil.del(tempDirPath);
    });
}
```

#### 4、测试

测试执行，可以先通过Swagger测试整个流程能否正确跑通。但是直接用Swagger测试下载文件可能会有问题(无法下载文件、或者下载的文件无法打开)。这种情况下，可以在网络控制台中复制请求为C川命令，然后用curl工具测试。

![img](https://yligd3y4pd.feishu.cn/space/api/box/stream/download/asynccode/?code=NTk5Njk4OGYxZjc4ODIyYjFkNWJkNzE3YmVmN2U2ZGNfRWxDaGFTZzMwcVpET1hBWWVFVE1UYUVJeHJOYjZvQXlfVG9rZW46SDB5WGJIY0N0b1FWbXh4QnlaSmNpT3hmbkRlXzE3MTEwNzgxODA6MTcxMTA4MTc4MF9WNA)

需要注意，如果是windows系统，最后使用代码生成器时护行的是.bat脚本文件。但之前maker工具制作生成器时，没有打包.bat脚本，此处建议补充。

修改maker制作工具的buildDist方法，代码如下：

### 前端页面开发

下面我们开发前端，依次完成：

1.  创建生成器的模型配置
2.  使用代码生成器页面